{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyChain = void 0;\n/*\nCopyright 2022 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst error_1 = require(\"../../error\");\nconst cert_1 = require(\"../../x509/cert\");\nconst verify_1 = require(\"../../x509/verify\");\nfunction verifyChain(certificate, certificateAuthorities) {\n  const untrustedCert = cert_1.x509Certificate.parse(certificate.rawBytes);\n  // Filter the list of certificate authorities to those which are valid for the\n  // signing certificate's notBefore date.\n  const validCAs = filterCertificateAuthorities(certificateAuthorities, untrustedCert.notBefore);\n  if (validCAs.length === 0) {\n    throw new error_1.VerificationError('No valid certificate authorities');\n  }\n  let trustedChain = [];\n  // Loop through all valid CAs and attempt to verify the certificate chain\n  const verified = validCAs.find(ca => {\n    const trustedCerts = parseCerts(ca.certChain?.certificates || []);\n    try {\n      trustedChain = (0, verify_1.verifyCertificateChain)({\n        untrustedCert,\n        trustedCerts,\n        validAt: untrustedCert.notBefore\n      });\n      return true;\n    } catch (e) {\n      return false;\n    }\n  });\n  if (!verified) {\n    throw new error_1.VerificationError('No valid certificate chain');\n  }\n  return trustedChain;\n}\nexports.verifyChain = verifyChain;\n// Filter the list of certificate authorities to those which are valid for the\n// given date.\nfunction filterCertificateAuthorities(certificateAuthorities, validAt) {\n  return certificateAuthorities.filter(ca => ca.validFor && ca.validFor.start && ca.validFor.start <= validAt && (!ca.validFor.end || validAt <= ca.validFor.end));\n}\n// Parse the raw bytes of a certificate into an x509Certificate object.\nfunction parseCerts(certs) {\n  return certs.map(cert => cert_1.x509Certificate.parse(cert.rawBytes));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","verifyChain","error_1","require","cert_1","verify_1","certificate","certificateAuthorities","untrustedCert","x509Certificate","parse","rawBytes","validCAs","filterCertificateAuthorities","notBefore","length","VerificationError","trustedChain","verified","find","ca","trustedCerts","parseCerts","certChain","certificates","verifyCertificateChain","validAt","e","filter","validFor","start","end","certs","map","cert"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/ca/verify/chain.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyChain = void 0;\n/*\nCopyright 2022 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst error_1 = require(\"../../error\");\nconst cert_1 = require(\"../../x509/cert\");\nconst verify_1 = require(\"../../x509/verify\");\nfunction verifyChain(certificate, certificateAuthorities) {\n    const untrustedCert = cert_1.x509Certificate.parse(certificate.rawBytes);\n    // Filter the list of certificate authorities to those which are valid for the\n    // signing certificate's notBefore date.\n    const validCAs = filterCertificateAuthorities(certificateAuthorities, untrustedCert.notBefore);\n    if (validCAs.length === 0) {\n        throw new error_1.VerificationError('No valid certificate authorities');\n    }\n    let trustedChain = [];\n    // Loop through all valid CAs and attempt to verify the certificate chain\n    const verified = validCAs.find((ca) => {\n        const trustedCerts = parseCerts(ca.certChain?.certificates || []);\n        try {\n            trustedChain = (0, verify_1.verifyCertificateChain)({\n                untrustedCert,\n                trustedCerts,\n                validAt: untrustedCert.notBefore,\n            });\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    });\n    if (!verified) {\n        throw new error_1.VerificationError('No valid certificate chain');\n    }\n    return trustedChain;\n}\nexports.verifyChain = verifyChain;\n// Filter the list of certificate authorities to those which are valid for the\n// given date.\nfunction filterCertificateAuthorities(certificateAuthorities, validAt) {\n    return certificateAuthorities.filter((ca) => ca.validFor &&\n        ca.validFor.start &&\n        ca.validFor.start <= validAt &&\n        (!ca.validFor.end || validAt <= ca.validFor.end));\n}\n// Parse the raw bytes of a certificate into an x509Certificate object.\nfunction parseCerts(certs) {\n    return certs.map((cert) => cert_1.x509Certificate.parse(cert.rawBytes));\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,aAAa,CAAC;AACtC,MAAMC,MAAM,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AACzC,MAAME,QAAQ,GAAGF,OAAO,CAAC,mBAAmB,CAAC;AAC7C,SAASF,WAAWA,CAACK,WAAW,EAAEC,sBAAsB,EAAE;EACtD,MAAMC,aAAa,GAAGJ,MAAM,CAACK,eAAe,CAACC,KAAK,CAACJ,WAAW,CAACK,QAAQ,CAAC;EACxE;EACA;EACA,MAAMC,QAAQ,GAAGC,4BAA4B,CAACN,sBAAsB,EAAEC,aAAa,CAACM,SAAS,CAAC;EAC9F,IAAIF,QAAQ,CAACG,MAAM,KAAK,CAAC,EAAE;IACvB,MAAM,IAAIb,OAAO,CAACc,iBAAiB,CAAC,kCAAkC,CAAC;EAC3E;EACA,IAAIC,YAAY,GAAG,EAAE;EACrB;EACA,MAAMC,QAAQ,GAAGN,QAAQ,CAACO,IAAI,CAAEC,EAAE,IAAK;IACnC,MAAMC,YAAY,GAAGC,UAAU,CAACF,EAAE,CAACG,SAAS,EAAEC,YAAY,IAAI,EAAE,CAAC;IACjE,IAAI;MACAP,YAAY,GAAG,CAAC,CAAC,EAAEZ,QAAQ,CAACoB,sBAAsB,EAAE;QAChDjB,aAAa;QACba,YAAY;QACZK,OAAO,EAAElB,aAAa,CAACM;MAC3B,CAAC,CAAC;MACF,OAAO,IAAI;IACf,CAAC,CACD,OAAOa,CAAC,EAAE;MACN,OAAO,KAAK;IAChB;EACJ,CAAC,CAAC;EACF,IAAI,CAACT,QAAQ,EAAE;IACX,MAAM,IAAIhB,OAAO,CAACc,iBAAiB,CAAC,4BAA4B,CAAC;EACrE;EACA,OAAOC,YAAY;AACvB;AACAlB,OAAO,CAACE,WAAW,GAAGA,WAAW;AACjC;AACA;AACA,SAASY,4BAA4BA,CAACN,sBAAsB,EAAEmB,OAAO,EAAE;EACnE,OAAOnB,sBAAsB,CAACqB,MAAM,CAAER,EAAE,IAAKA,EAAE,CAACS,QAAQ,IACpDT,EAAE,CAACS,QAAQ,CAACC,KAAK,IACjBV,EAAE,CAACS,QAAQ,CAACC,KAAK,IAAIJ,OAAO,KAC3B,CAACN,EAAE,CAACS,QAAQ,CAACE,GAAG,IAAIL,OAAO,IAAIN,EAAE,CAACS,QAAQ,CAACE,GAAG,CAAC,CAAC;AACzD;AACA;AACA,SAAST,UAAUA,CAACU,KAAK,EAAE;EACvB,OAAOA,KAAK,CAACC,GAAG,CAAEC,IAAI,IAAK9B,MAAM,CAACK,eAAe,CAACC,KAAK,CAACwB,IAAI,CAACvB,QAAQ,CAAC,CAAC;AAC3E"},"metadata":{},"sourceType":"script","externalDependencies":[]}