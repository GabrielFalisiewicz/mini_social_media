{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function () {\n    return validate_1.KeywordCxt;\n  }\n});\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.CodeGen;\n  }\n});\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]);\nconst removedOptions = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\"\n};\nconst deprecatedOptions = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n  const s = o.strict;\n  const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n  const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n  const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n  return {\n    strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n    strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n    strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n    strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n    strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n    code: o.code ? {\n      ...o.code,\n      optimize,\n      regExp\n    } : {\n      optimize,\n      regExp\n    },\n    loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n    loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n    meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n    messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n    inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n    schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n    addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n    validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n    validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n    unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n    int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n    uriResolver: uriResolver\n  };\n}\nclass Ajv {\n  constructor(opts = {}) {\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    opts = this.opts = {\n      ...opts,\n      ...requiredOptions(opts)\n    };\n    const {\n      es5,\n      lines\n    } = this.opts.code;\n    this.scope = new codegen_2.ValueScope({\n      scope: {},\n      prefixes: EXT_SCOPE_NAMES,\n      es5,\n      lines\n    });\n    this.logger = getLogger(opts.logger);\n    const formatOpt = opts.validateFormats;\n    opts.validateFormats = false;\n    this.RULES = (0, rules_1.getRules)();\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n    this._metaOpts = getMetaSchemaOptions.call(this);\n    if (opts.formats) addInitialFormats.call(this);\n    this._addVocabularies();\n    this._addDefaultMetaSchema();\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords);\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta);\n    addInitialSchemas.call(this);\n    opts.validateFormats = formatOpt;\n  }\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n  _addDefaultMetaSchema() {\n    const {\n      $data,\n      meta,\n      schemaId\n    } = this.opts;\n    let _dataRefSchema = $dataRefSchema;\n    if (schemaId === \"id\") {\n      _dataRefSchema = {\n        ...$dataRefSchema\n      };\n      _dataRefSchema.id = _dataRefSchema.$id;\n      delete _dataRefSchema.$id;\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n  }\n  defaultMeta() {\n    const {\n      meta,\n      schemaId\n    } = this.opts;\n    return this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined;\n  }\n  validate(schemaKeyRef,\n  // key, ref or schema object\n  data // to be validated\n  ) {\n    let v;\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema(schemaKeyRef);\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n    } else {\n      v = this.compile(schemaKeyRef);\n    }\n    const valid = v(data);\n    if (!(\"$async\" in v)) this.errors = v.errors;\n    return valid;\n  }\n  compile(schema, _meta) {\n    const sch = this._addSchema(schema, _meta);\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  compileAsync(schema, meta) {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\");\n    }\n    const {\n      loadSchema\n    } = this.opts;\n    return runCompileAsync.call(this, schema, meta);\n    function runCompileAsync(_x2, _x3) {\n      return _runCompileAsync.apply(this, arguments);\n    }\n    function _runCompileAsync() {\n      _runCompileAsync = _asyncToGenerator(function* (_schema, _meta) {\n        yield loadMetaSchema.call(this, _schema.$schema);\n        const sch = this._addSchema(_schema, _meta);\n        return sch.validate || _compileAsync.call(this, sch);\n      });\n      return _runCompileAsync.apply(this, arguments);\n    }\n    function loadMetaSchema(_x4) {\n      return _loadMetaSchema.apply(this, arguments);\n    }\n    function _loadMetaSchema() {\n      _loadMetaSchema = _asyncToGenerator(function* ($ref) {\n        if ($ref && !this.getSchema($ref)) {\n          yield runCompileAsync.call(this, {\n            $ref\n          }, true);\n        }\n      });\n      return _loadMetaSchema.apply(this, arguments);\n    }\n    function _compileAsync(_x5) {\n      return _compileAsync2.apply(this, arguments);\n    }\n    function _compileAsync2() {\n      _compileAsync2 = _asyncToGenerator(function* (sch) {\n        try {\n          return this._compileSchemaEnv(sch);\n        } catch (e) {\n          if (!(e instanceof ref_error_1.default)) throw e;\n          checkLoaded.call(this, e);\n          yield loadMissingSchema.call(this, e.missingSchema);\n          return _compileAsync.call(this, sch);\n        }\n      });\n      return _compileAsync2.apply(this, arguments);\n    }\n    function checkLoaded({\n      missingSchema: ref,\n      missingRef\n    }) {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n      }\n    }\n    function loadMissingSchema(_x6) {\n      return _loadMissingSchema.apply(this, arguments);\n    }\n    function _loadMissingSchema() {\n      _loadMissingSchema = _asyncToGenerator(function* (ref) {\n        const _schema = yield _loadSchema.call(this, ref);\n        if (!this.refs[ref]) yield loadMetaSchema.call(this, _schema.$schema);\n        if (!this.refs[ref]) this.addSchema(_schema, ref, meta);\n      });\n      return _loadMissingSchema.apply(this, arguments);\n    }\n    function _loadSchema(_x7) {\n      return _loadSchema2.apply(this, arguments);\n    }\n    function _loadSchema2() {\n      _loadSchema2 = _asyncToGenerator(function* (ref) {\n        const p = this._loading[ref];\n        if (p) return p;\n        try {\n          return yield this._loading[ref] = loadSchema(ref);\n        } finally {\n          delete this._loading[ref];\n        }\n      });\n      return _loadSchema2.apply(this, arguments);\n    }\n  }\n  // Adds schema to the instance\n  addSchema(schema,\n  // If array is passed, `key` will be ignored\n  key,\n  // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n  _meta,\n  // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n  _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ) {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema);\n      return this;\n    }\n    let id;\n    if (typeof schema === \"object\") {\n      const {\n        schemaId\n      } = this.opts;\n      id = schema[schemaId];\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`);\n      }\n    }\n    key = (0, resolve_1.normalizeId)(key || id);\n    this._checkUnique(key);\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n    return this;\n  }\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(schema, key,\n  // schema key\n  _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ) {\n    this.addSchema(schema, key, true, _validateSchema);\n    return this;\n  }\n  //  Validate schema against its meta-schema\n  validateSchema(schema, throwOrLogError) {\n    if (typeof schema == \"boolean\") return true;\n    let $schema;\n    $schema = schema.$schema;\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\");\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\");\n      this.errors = null;\n      return true;\n    }\n    const valid = this.validate($schema, schema);\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText();\n      if (this.opts.validateSchema === \"log\") this.logger.error(message);else throw new Error(message);\n    }\n    return valid;\n  }\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema(keyRef) {\n    let sch;\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch;\n    if (sch === undefined) {\n      const {\n        schemaId\n      } = this.opts;\n      const root = new compile_1.SchemaEnv({\n        schema: {},\n        schemaId\n      });\n      sch = compile_1.resolveSchema.call(this, root, keyRef);\n      if (!sch) return;\n      this.refs[keyRef] = sch;\n    }\n    return sch.validate || this._compileSchemaEnv(sch);\n  }\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef);\n      this._removeAllSchemas(this.refs, schemaKeyRef);\n      return this;\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n        this._removeAllSchemas(this.refs);\n        this._cache.clear();\n        return this;\n      case \"string\":\n        {\n          const sch = getSchEnv.call(this, schemaKeyRef);\n          if (typeof sch == \"object\") this._cache.delete(sch.schema);\n          delete this.schemas[schemaKeyRef];\n          delete this.refs[schemaKeyRef];\n          return this;\n        }\n      case \"object\":\n        {\n          const cacheKey = schemaKeyRef;\n          this._cache.delete(cacheKey);\n          let id = schemaKeyRef[this.opts.schemaId];\n          if (id) {\n            id = (0, resolve_1.normalizeId)(id);\n            delete this.schemas[id];\n            delete this.refs[id];\n          }\n          return this;\n        }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  }\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions) {\n    for (const def of definitions) this.addKeyword(def);\n    return this;\n  }\n  addKeyword(kwdOrDef, def // deprecated\n  ) {\n    let keyword;\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef;\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n        def.keyword = keyword;\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef;\n      keyword = def.keyword;\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\");\n    }\n    checkKeyword.call(this, keyword, def);\n    if (!def) {\n      (0, util_1.eachItem)(keyword, kwd => addRule.call(this, kwd));\n      return this;\n    }\n    keywordMetaschema.call(this, def);\n    const definition = {\n      ...def,\n      type: (0, dataType_1.getJSONTypes)(def.type),\n      schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)\n    };\n    (0, util_1.eachItem)(keyword, definition.type.length === 0 ? k => addRule.call(this, k, definition) : k => definition.type.forEach(t => addRule.call(this, k, definition, t)));\n    return this;\n  }\n  getKeyword(keyword) {\n    const rule = this.RULES.all[keyword];\n    return typeof rule == \"object\" ? rule.definition : !!rule;\n  }\n  // Remove keyword\n  removeKeyword(keyword) {\n    // TODO return type should be Ajv\n    const {\n      RULES\n    } = this;\n    delete RULES.keywords[keyword];\n    delete RULES.all[keyword];\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex(rule => rule.keyword === keyword);\n      if (i >= 0) group.rules.splice(i, 1);\n    }\n    return this;\n  }\n  // Add format\n  addFormat(name, format) {\n    if (typeof format == \"string\") format = new RegExp(format);\n    this.formats[name] = format;\n    return this;\n  }\n  errorsText(errors = this.errors,\n  // optional array of validation errors\n  {\n    separator = \", \",\n    dataVar = \"data\"\n  } = {} // optional options with properties `separator` and `dataVar`\n  ) {\n    if (!errors || errors.length === 0) return \"No errors\";\n    return errors.map(e => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);\n  }\n  $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n    const rules = this.RULES.all;\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n      let keywords = metaSchema;\n      for (const seg of segments) keywords = keywords[seg];\n      for (const key in rules) {\n        const rule = rules[key];\n        if (typeof rule != \"object\") continue;\n        const {\n          $data\n        } = rule.definition;\n        const schema = keywords[key];\n        if ($data && schema) keywords[key] = schemaOrData(schema);\n      }\n    }\n    return metaSchema;\n  }\n  _removeAllSchemas(schemas, regex) {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef];\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef];\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema);\n          delete schemas[keyRef];\n        }\n      }\n    }\n  }\n  _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n    let id;\n    const {\n      schemaId\n    } = this.opts;\n    if (typeof schema == \"object\") {\n      id = schema[schemaId];\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\");\n    }\n    let sch = this._cache.get(schema);\n    if (sch !== undefined) return sch;\n    baseId = (0, resolve_1.normalizeId)(id || baseId);\n    const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n    sch = new compile_1.SchemaEnv({\n      schema,\n      schemaId,\n      meta,\n      baseId,\n      localRefs\n    });\n    this._cache.set(sch.schema, sch);\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId);\n      this.refs[baseId] = sch;\n    }\n    if (validateSchema) this.validateSchema(schema, true);\n    return sch;\n  }\n  _checkUnique(id) {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`);\n    }\n  }\n  _compileSchemaEnv(sch) {\n    if (sch.meta) this._compileMetaSchema(sch);else compile_1.compileSchema.call(this, sch);\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\");\n    return sch.validate;\n  }\n  _compileMetaSchema(sch) {\n    const currentOpts = this.opts;\n    this.opts = this._metaOpts;\n    try {\n      compile_1.compileSchema.call(this, sch);\n    } finally {\n      this.opts = currentOpts;\n    }\n  }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n  for (const key in checkOpts) {\n    const opt = key;\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n  }\n}\nfunction getSchEnv(keyRef) {\n  keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n  const optsSchemas = this.opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas);else for (const key in optsSchemas) this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name];\n    if (format) this.addFormat(name, format);\n  }\n}\nfunction addInitialKeywords(defs) {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs);\n    return;\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\");\n  for (const keyword in defs) {\n    const def = defs[keyword];\n    if (!def.keyword) def.keyword = keyword;\n    this.addKeyword(def);\n  }\n}\nfunction getMetaSchemaOptions() {\n  const metaOpts = {\n    ...this.opts\n  };\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt];\n  return metaOpts;\n}\nconst noLogs = {\n  log() {},\n  warn() {},\n  error() {}\n};\nfunction getLogger(logger) {\n  if (logger === false) return noLogs;\n  if (logger === undefined) return console;\n  if (logger.log && logger.warn && logger.error) return logger;\n  throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n  const {\n    RULES\n  } = this;\n  (0, util_1.eachItem)(keyword, kwd => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`);\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`);\n  });\n  if (!def) return;\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function');\n  }\n}\nfunction addRule(keyword, definition, dataType) {\n  var _a;\n  const post = definition === null || definition === void 0 ? void 0 : definition.post;\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const {\n    RULES\n  } = this;\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({\n    type: t\n  }) => t === dataType);\n  if (!ruleGroup) {\n    ruleGroup = {\n      type: dataType,\n      rules: []\n    };\n    RULES.rules.push(ruleGroup);\n  }\n  RULES.keywords[keyword] = true;\n  if (!definition) return;\n  const rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: (0, dataType_1.getJSONTypes)(definition.type),\n      schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)\n    }\n  };\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before);else ruleGroup.rules.push(rule);\n  RULES.all[keyword] = rule;\n  (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach(kwd => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n  const i = ruleGroup.rules.findIndex(_rule => _rule.keyword === before);\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule);\n  } else {\n    ruleGroup.rules.push(rule);\n    this.logger.warn(`rule ${before} is not defined`);\n  }\n}\nfunction keywordMetaschema(def) {\n  let {\n    metaSchema\n  } = def;\n  if (metaSchema === undefined) return;\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema);\n  def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\nfunction schemaOrData(schema) {\n  return {\n    anyOf: [schema, $dataRef]\n  };\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","CodeGen","Name","nil","stringify","str","_","KeywordCxt","validate_1","enumerable","get","codegen_1","validation_error_1","ref_error_1","rules_1","compile_1","codegen_2","resolve_1","dataType_1","util_1","$dataRefSchema","uri_1","defaultRegExp","flags","RegExp","code","META_IGNORE_OPTIONS","EXT_SCOPE_NAMES","Set","removedOptions","errorDataPath","format","nullable","jsonPointers","extendRefs","missingRefs","processCode","sourceCode","strictDefaults","strictKeywords","uniqueItems","unknownFormats","cache","serialize","ajvErrors","deprecatedOptions","ignoreKeywordsWithRef","jsPropertySyntax","unicode","MAX_EXPRESSION","requiredOptions","o","_a","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_s","_t","_u","_v","_w","_x","_y","_z","_0","s","strict","_optz","optimize","undefined","regExp","uriResolver","strictSchema","strictNumbers","strictTypes","strictTuples","strictRequired","loopRequired","loopEnum","meta","messages","inlineRefs","schemaId","addUsedSchema","validateSchema","validateFormats","unicodeRegExp","int32range","Ajv","constructor","opts","schemas","refs","formats","_compilations","_loading","_cache","Map","es5","lines","scope","ValueScope","prefixes","logger","getLogger","formatOpt","RULES","getRules","checkOptions","call","_metaOpts","getMetaSchemaOptions","addInitialFormats","_addVocabularies","_addDefaultMetaSchema","keywords","addInitialKeywords","addMetaSchema","addInitialSchemas","addKeyword","$data","_dataRefSchema","id","$id","defaultMeta","validate","schemaKeyRef","data","v","getSchema","Error","compile","valid","errors","schema","_meta","sch","_addSchema","_compileSchemaEnv","compileAsync","loadSchema","runCompileAsync","_x2","_x3","_runCompileAsync","apply","arguments","_schema","loadMetaSchema","$schema","_compileAsync","_x4","_loadMetaSchema","$ref","_x5","_compileAsync2","e","checkLoaded","loadMissingSchema","missingSchema","ref","missingRef","_x6","_loadMissingSchema","_loadSchema","addSchema","_x7","_loadSchema2","p","key","_validateSchema","Array","isArray","normalizeId","_checkUnique","throwOrLogError","warn","message","errorsText","error","keyRef","getSchEnv","root","SchemaEnv","resolveSchema","removeSchema","_removeAllSchemas","clear","delete","cacheKey","addVocabulary","definitions","def","kwdOrDef","keyword","length","checkKeyword","eachItem","kwd","addRule","keywordMetaschema","definition","type","getJSONTypes","schemaType","k","forEach","t","getKeyword","rule","all","removeKeyword","group","rules","i","findIndex","splice","addFormat","name","separator","dataVar","map","instancePath","reduce","text","msg","$dataMetaSchema","metaSchema","keywordsJsonPointers","JSON","parse","jsonPointer","segments","split","slice","seg","schemaOrData","regex","test","baseId","jtd","localRefs","getSchemaRefs","set","startsWith","_compileMetaSchema","compileSchema","currentOpts","ValidationError","MissingRefError","checkOpts","options","log","opt","optsSchemas","defs","metaOpts","noLogs","console","KEYWORD_NAME","dataType","post","ruleGroup","find","push","before","addBeforeRule","implements","_rule","$dataRef","anyOf"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/ajv/dist/core.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = require(\"./compile/validate\");\nObject.defineProperty(exports, \"KeywordCxt\", { enumerable: true, get: function () { return validate_1.KeywordCxt; } });\nvar codegen_1 = require(\"./compile/codegen\");\nObject.defineProperty(exports, \"_\", { enumerable: true, get: function () { return codegen_1._; } });\nObject.defineProperty(exports, \"str\", { enumerable: true, get: function () { return codegen_1.str; } });\nObject.defineProperty(exports, \"stringify\", { enumerable: true, get: function () { return codegen_1.stringify; } });\nObject.defineProperty(exports, \"nil\", { enumerable: true, get: function () { return codegen_1.nil; } });\nObject.defineProperty(exports, \"Name\", { enumerable: true, get: function () { return codegen_1.Name; } });\nObject.defineProperty(exports, \"CodeGen\", { enumerable: true, get: function () { return codegen_1.CodeGen; } });\nconst validation_error_1 = require(\"./runtime/validation_error\");\nconst ref_error_1 = require(\"./compile/ref_error\");\nconst rules_1 = require(\"./compile/rules\");\nconst compile_1 = require(\"./compile\");\nconst codegen_2 = require(\"./compile/codegen\");\nconst resolve_1 = require(\"./compile/resolve\");\nconst dataType_1 = require(\"./compile/validate/dataType\");\nconst util_1 = require(\"./compile/util\");\nconst $dataRefSchema = require(\"./refs/data.json\");\nconst uri_1 = require(\"./runtime/uri\");\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = \"new RegExp\";\nconst META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"];\nconst EXT_SCOPE_NAMES = new Set([\n    \"validate\",\n    \"serialize\",\n    \"parse\",\n    \"wrapper\",\n    \"root\",\n    \"schema\",\n    \"keyword\",\n    \"pattern\",\n    \"formats\",\n    \"validate$data\",\n    \"func\",\n    \"obj\",\n    \"Error\",\n]);\nconst removedOptions = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : \"log\",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : \"log\",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : \"$id\",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\");\n        checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == \"object\")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword(\"$async\");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === \"id\") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == \"string\") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!(\"$async\" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != \"function\") {\n            throw new Error(\"options.loadSchema should be a function\");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === \"object\") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != \"string\") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == \"boolean\")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != \"string\") {\n            throw new Error(\"$schema must be a string\");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn(\"meta-schema not available\");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = \"schema is invalid: \" + this.errorsText();\n            if (this.opts.validateSchema === \"log\")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case \"undefined\":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case \"string\": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == \"object\")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case \"object\": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error(\"ajv.removeSchema: invalid parameter\");\n        }\n    }\n    // add \"vocabulary\" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == \"string\") {\n            keyword = kwdOrDef;\n            if (typeof def == \"object\") {\n                this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == \"object\" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n            }\n        }\n        else {\n            throw new Error(\"invalid addKeywords parameters\");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == \"object\" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == \"string\")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = \", \", dataVar = \"data\" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return \"No errors\";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split(\"/\").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != \"object\")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == \"string\") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == \"object\") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error(\"schema must be object\");\n            else if (typeof schema != \"boolean\")\n                throw new Error(\"schema must be object or boolean\");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith(\"#\")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id \"${id}\" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error(\"ajv implementation error\");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports.default = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = \"error\") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error(\"logger must implement log, warn and error methods\");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n        throw new Error('$data keyword must have \"code\" or \"validate\" function');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error('keyword with \"post\" flag cannot have \"type\"');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}