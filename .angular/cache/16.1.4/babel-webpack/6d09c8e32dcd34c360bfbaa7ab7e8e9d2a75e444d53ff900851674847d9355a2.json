{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst utils_1 = require(\"../../json/utils\");\nconst definitions_1 = require(\"../definitions\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nconst ANGULAR_WORKSPACE_EXTENSIONS = Object.freeze(['cli', 'newProjectRoot', 'schematics']);\nconst ANGULAR_PROJECT_EXTENSIONS = Object.freeze(['cli', 'schematics', 'projectType', 'i18n']);\nfunction readJsonWorkspace(_x, _x2) {\n  return _readJsonWorkspace.apply(this, arguments);\n}\nfunction _readJsonWorkspace() {\n  _readJsonWorkspace = _asyncToGenerator(function* (path, host, options = {}) {\n    const raw = yield host.readFile(path);\n    if (raw === undefined) {\n      throw new Error('Unable to read workspace file.');\n    }\n    const ast = (0, jsonc_parser_1.parseTree)(raw, undefined, {\n      allowTrailingComma: true,\n      disallowComments: false\n    });\n    if (ast?.type !== 'object' || !ast.children) {\n      throw new Error('Invalid workspace file - expected JSON object.');\n    }\n    // Version check\n    const versionNode = (0, jsonc_parser_1.findNodeAtLocation)(ast, ['version']);\n    if (!versionNode) {\n      throw new Error('Unknown format - version specifier not found.');\n    }\n    const version = versionNode.value;\n    if (version !== 1) {\n      throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${version} ]`);\n    }\n    const context = {\n      host,\n      metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n      trackChanges: true,\n      unprefixedWorkspaceExtensions: new Set([...ANGULAR_WORKSPACE_EXTENSIONS, ...(options.allowedWorkspaceExtensions ?? [])]),\n      unprefixedProjectExtensions: new Set([...ANGULAR_PROJECT_EXTENSIONS, ...(options.allowedProjectExtensions ?? [])]),\n      error(message, _node) {\n        // TODO: Diagnostic reporting support\n        throw new Error(message);\n      },\n      warn(message, _node) {\n        // TODO: Diagnostic reporting support\n        // eslint-disable-next-line no-console\n        console.warn(message);\n      }\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n  });\n  return _readJsonWorkspace.apply(this, arguments);\n}\nexports.readJsonWorkspace = readJsonWorkspace;\nfunction parseWorkspace(workspaceNode, context) {\n  const jsonMetadata = context.metadata;\n  let projects;\n  let extensions;\n  if (!context.trackChanges) {\n    extensions = Object.create(null);\n  }\n  // TODO: `getNodeValue` - looks potentially expensive since it walks the whole tree and instantiates the full object structure each time.\n  // Might be something to look at moving forward to optimize.\n  const workspaceNodeValue = (0, jsonc_parser_1.getNodeValue)(workspaceNode);\n  for (const [name, value] of Object.entries(workspaceNodeValue)) {\n    if (name === '$schema' || name === 'version') {\n      // skip\n    } else if (name === 'projects') {\n      const nodes = (0, jsonc_parser_1.findNodeAtLocation)(workspaceNode, ['projects']);\n      if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n        context.error('Invalid \"projects\" field found; expected an object.', value);\n        continue;\n      }\n      projects = parseProjectsObject(nodes, context);\n    } else {\n      if (!context.unprefixedWorkspaceExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n        context.warn(`Workspace extension with invalid name (${name}) found.`, name);\n      }\n      if (extensions) {\n        extensions[name] = value;\n      }\n    }\n  }\n  let collectionListener;\n  if (context.trackChanges) {\n    collectionListener = (name, newValue) => {\n      jsonMetadata.addChange(['projects', name], newValue, 'project');\n    };\n  }\n  const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n  return {\n    [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n    projects: projectCollection,\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions ?? (0, utilities_1.createVirtualAstObject)(workspaceNodeValue, {\n      exclude: ['$schema', 'version', 'projects'],\n      listener(path, value) {\n        jsonMetadata.addChange(path, value);\n      }\n    })\n  };\n}\nfunction parseProjectsObject(projectsNode, context) {\n  const projects = Object.create(null);\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(projectsNode))) {\n    const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectsNode, [name]);\n    if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n      context.warn('Skipping invalid project value; expected an object.', value);\n      continue;\n    }\n    projects[name] = parseProject(name, nodes, context);\n  }\n  return projects;\n}\nfunction parseProject(projectName, projectNode, context) {\n  const jsonMetadata = context.metadata;\n  let targets;\n  let hasTargets = false;\n  let extensions;\n  let properties;\n  if (!context.trackChanges) {\n    // If not tracking changes, the parser will store the values directly in standard objects\n    extensions = Object.create(null);\n    properties = Object.create(null);\n  }\n  const projectNodeValue = (0, jsonc_parser_1.getNodeValue)(projectNode);\n  if (!('root' in projectNodeValue)) {\n    throw new Error(`Project \"${projectName}\" is missing a required property \"root\".`);\n  }\n  for (const [name, value] of Object.entries(projectNodeValue)) {\n    switch (name) {\n      case 'targets':\n      case 'architect':\n        const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectNode, [name]);\n        if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n          context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n          break;\n        }\n        hasTargets = true;\n        targets = parseTargetsObject(projectName, nodes, context);\n        jsonMetadata.hasLegacyTargetsName = name === 'architect';\n        break;\n      case 'prefix':\n      case 'root':\n      case 'sourceRoot':\n        if (typeof value !== 'string') {\n          context.warn(`Project property \"${name}\" should be a string.`, value);\n        }\n        if (properties) {\n          properties[name] = value;\n        }\n        break;\n      default:\n        if (!context.unprefixedProjectExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n          context.warn(`Project '${projectName}' contains extension with invalid name (${name}).`, name);\n        }\n        if (extensions) {\n          extensions[name] = value;\n        }\n        break;\n    }\n  }\n  let collectionListener;\n  if (context.trackChanges) {\n    collectionListener = (name, newValue, collection) => {\n      if (hasTargets) {\n        jsonMetadata.addChange(['projects', projectName, 'targets', name], newValue, 'target');\n      } else {\n        jsonMetadata.addChange(['projects', projectName, 'targets'], collection, 'targetcollection');\n      }\n    };\n  }\n  const base = {\n    targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions ?? (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n      exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n      listener(path, value) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n    })\n  };\n  const baseKeys = new Set(Object.keys(base));\n  const project = properties ?? (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n    include: ['prefix', 'root', 'sourceRoot', ...baseKeys],\n    listener(path, value) {\n      if (!baseKeys.has(path[0])) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n    }\n  });\n  return Object.assign(project, base);\n}\nfunction parseTargetsObject(projectName, targetsNode, context) {\n  const jsonMetadata = context.metadata;\n  const targets = Object.create(null);\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(targetsNode))) {\n    if (!(0, utils_1.isJsonObject)(value)) {\n      context.warn('Skipping invalid target value; expected an object.', value);\n      continue;\n    }\n    if (context.trackChanges) {\n      targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n        include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n        listener(path, value) {\n          jsonMetadata.addChange(['projects', projectName, 'targets', name, ...path], value);\n        }\n      });\n    } else {\n      targets[name] = value;\n    }\n  }\n  return targets;\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","readJsonWorkspace","jsonc_parser_1","utils_1","definitions_1","metadata_1","utilities_1","ANGULAR_WORKSPACE_EXTENSIONS","freeze","ANGULAR_PROJECT_EXTENSIONS","_x","_x2","_readJsonWorkspace","apply","arguments","path","host","options","raw","readFile","undefined","Error","ast","parseTree","allowTrailingComma","disallowComments","type","children","versionNode","findNodeAtLocation","version","context","metadata","JsonWorkspaceMetadata","trackChanges","unprefixedWorkspaceExtensions","Set","allowedWorkspaceExtensions","unprefixedProjectExtensions","allowedProjectExtensions","error","message","_node","warn","console","workspace","parseWorkspace","workspaceNode","jsonMetadata","projects","extensions","create","workspaceNodeValue","getNodeValue","name","entries","nodes","isJsonObject","parseProjectsObject","has","test","collectionListener","newValue","addChange","projectCollection","ProjectDefinitionCollection","JsonWorkspaceSymbol","createVirtualAstObject","exclude","listener","projectsNode","parseProject","projectName","projectNode","targets","hasTargets","properties","projectNodeValue","parseTargetsObject","hasLegacyTargetsName","collection","base","TargetDefinitionCollection","baseKeys","keys","project","include","assign","targetsNode"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular-devkit/core/src/workspace/json/reader.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readJsonWorkspace = void 0;\nconst jsonc_parser_1 = require(\"jsonc-parser\");\nconst utils_1 = require(\"../../json/utils\");\nconst definitions_1 = require(\"../definitions\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nconst ANGULAR_WORKSPACE_EXTENSIONS = Object.freeze(['cli', 'newProjectRoot', 'schematics']);\nconst ANGULAR_PROJECT_EXTENSIONS = Object.freeze(['cli', 'schematics', 'projectType', 'i18n']);\nasync function readJsonWorkspace(path, host, options = {}) {\n    const raw = await host.readFile(path);\n    if (raw === undefined) {\n        throw new Error('Unable to read workspace file.');\n    }\n    const ast = (0, jsonc_parser_1.parseTree)(raw, undefined, { allowTrailingComma: true, disallowComments: false });\n    if (ast?.type !== 'object' || !ast.children) {\n        throw new Error('Invalid workspace file - expected JSON object.');\n    }\n    // Version check\n    const versionNode = (0, jsonc_parser_1.findNodeAtLocation)(ast, ['version']);\n    if (!versionNode) {\n        throw new Error('Unknown format - version specifier not found.');\n    }\n    const version = versionNode.value;\n    if (version !== 1) {\n        throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${version} ]`);\n    }\n    const context = {\n        host,\n        metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n        trackChanges: true,\n        unprefixedWorkspaceExtensions: new Set([\n            ...ANGULAR_WORKSPACE_EXTENSIONS,\n            ...(options.allowedWorkspaceExtensions ?? []),\n        ]),\n        unprefixedProjectExtensions: new Set([\n            ...ANGULAR_PROJECT_EXTENSIONS,\n            ...(options.allowedProjectExtensions ?? []),\n        ]),\n        error(message, _node) {\n            // TODO: Diagnostic reporting support\n            throw new Error(message);\n        },\n        warn(message, _node) {\n            // TODO: Diagnostic reporting support\n            // eslint-disable-next-line no-console\n            console.warn(message);\n        },\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n}\nexports.readJsonWorkspace = readJsonWorkspace;\nfunction parseWorkspace(workspaceNode, context) {\n    const jsonMetadata = context.metadata;\n    let projects;\n    let extensions;\n    if (!context.trackChanges) {\n        extensions = Object.create(null);\n    }\n    // TODO: `getNodeValue` - looks potentially expensive since it walks the whole tree and instantiates the full object structure each time.\n    // Might be something to look at moving forward to optimize.\n    const workspaceNodeValue = (0, jsonc_parser_1.getNodeValue)(workspaceNode);\n    for (const [name, value] of Object.entries(workspaceNodeValue)) {\n        if (name === '$schema' || name === 'version') {\n            // skip\n        }\n        else if (name === 'projects') {\n            const nodes = (0, jsonc_parser_1.findNodeAtLocation)(workspaceNode, ['projects']);\n            if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n                context.error('Invalid \"projects\" field found; expected an object.', value);\n                continue;\n            }\n            projects = parseProjectsObject(nodes, context);\n        }\n        else {\n            if (!context.unprefixedWorkspaceExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                context.warn(`Workspace extension with invalid name (${name}) found.`, name);\n            }\n            if (extensions) {\n                extensions[name] = value;\n            }\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        collectionListener = (name, newValue) => {\n            jsonMetadata.addChange(['projects', name], newValue, 'project');\n        };\n    }\n    const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n    return {\n        [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n        projects: projectCollection,\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions ??\n            (0, utilities_1.createVirtualAstObject)(workspaceNodeValue, {\n                exclude: ['$schema', 'version', 'projects'],\n                listener(path, value) {\n                    jsonMetadata.addChange(path, value);\n                },\n            }),\n    };\n}\nfunction parseProjectsObject(projectsNode, context) {\n    const projects = Object.create(null);\n    for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(projectsNode))) {\n        const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectsNode, [name]);\n        if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n            context.warn('Skipping invalid project value; expected an object.', value);\n            continue;\n        }\n        projects[name] = parseProject(name, nodes, context);\n    }\n    return projects;\n}\nfunction parseProject(projectName, projectNode, context) {\n    const jsonMetadata = context.metadata;\n    let targets;\n    let hasTargets = false;\n    let extensions;\n    let properties;\n    if (!context.trackChanges) {\n        // If not tracking changes, the parser will store the values directly in standard objects\n        extensions = Object.create(null);\n        properties = Object.create(null);\n    }\n    const projectNodeValue = (0, jsonc_parser_1.getNodeValue)(projectNode);\n    if (!('root' in projectNodeValue)) {\n        throw new Error(`Project \"${projectName}\" is missing a required property \"root\".`);\n    }\n    for (const [name, value] of Object.entries(projectNodeValue)) {\n        switch (name) {\n            case 'targets':\n            case 'architect':\n                const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectNode, [name]);\n                if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n                    context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n                    break;\n                }\n                hasTargets = true;\n                targets = parseTargetsObject(projectName, nodes, context);\n                jsonMetadata.hasLegacyTargetsName = name === 'architect';\n                break;\n            case 'prefix':\n            case 'root':\n            case 'sourceRoot':\n                if (typeof value !== 'string') {\n                    context.warn(`Project property \"${name}\" should be a string.`, value);\n                }\n                if (properties) {\n                    properties[name] = value;\n                }\n                break;\n            default:\n                if (!context.unprefixedProjectExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                    context.warn(`Project '${projectName}' contains extension with invalid name (${name}).`, name);\n                }\n                if (extensions) {\n                    extensions[name] = value;\n                }\n                break;\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        collectionListener = (name, newValue, collection) => {\n            if (hasTargets) {\n                jsonMetadata.addChange(['projects', projectName, 'targets', name], newValue, 'target');\n            }\n            else {\n                jsonMetadata.addChange(['projects', projectName, 'targets'], collection, 'targetcollection');\n            }\n        };\n    }\n    const base = {\n        targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions ??\n            (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n                exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n                listener(path, value) {\n                    jsonMetadata.addChange(['projects', projectName, ...path], value);\n                },\n            }),\n    };\n    const baseKeys = new Set(Object.keys(base));\n    const project = properties ??\n        (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n            include: ['prefix', 'root', 'sourceRoot', ...baseKeys],\n            listener(path, value) {\n                if (!baseKeys.has(path[0])) {\n                    jsonMetadata.addChange(['projects', projectName, ...path], value);\n                }\n            },\n        });\n    return Object.assign(project, base);\n}\nfunction parseTargetsObject(projectName, targetsNode, context) {\n    const jsonMetadata = context.metadata;\n    const targets = Object.create(null);\n    for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(targetsNode))) {\n        if (!(0, utils_1.isJsonObject)(value)) {\n            context.warn('Skipping invalid target value; expected an object.', value);\n            continue;\n        }\n        if (context.trackChanges) {\n            targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n                include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n                listener(path, value) {\n                    jsonMetadata.addChange(['projects', projectName, 'targets', name, ...path], value);\n                },\n            });\n        }\n        else {\n            targets[name] = value;\n        }\n    }\n    return targets;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}