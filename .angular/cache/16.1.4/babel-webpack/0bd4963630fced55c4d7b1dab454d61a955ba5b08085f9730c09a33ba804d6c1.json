{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyToSubtree = exports.composeFileOperators = exports.forEach = exports.partitionApplyMerge = exports.when = exports.branchAndMerge = exports.asSource = exports.filter = exports.noop = exports.mergeWith = exports.apply = exports.chain = exports.empty = exports.source = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst exception_1 = require(\"../exception/exception\");\nconst host_tree_1 = require(\"../tree/host-tree\");\nconst interface_1 = require(\"../tree/interface\");\nconst scoped_1 = require(\"../tree/scoped\");\nconst static_1 = require(\"../tree/static\");\nconst call_1 = require(\"./call\");\n/**\n * A Source that returns an tree as its single value.\n */\nfunction source(tree) {\n  return () => tree;\n}\nexports.source = source;\n/**\n * A source that returns an empty tree.\n */\nfunction empty() {\n  return () => (0, static_1.empty)();\n}\nexports.empty = empty;\n/**\n * Chain multiple rules into a single rule.\n */\nfunction chain(rules) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (initialTree, context) {\n      let intermediateTree;\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(rules), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const rule = _step.value;\n          {\n            intermediateTree = (0, call_1.callRule)(rule, intermediateTree ?? initialTree, context);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return () => intermediateTree;\n    });\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\nexports.chain = chain;\n/**\n * Apply multiple rules to a source, and returns the source transformed.\n */\nfunction apply(source, rules) {\n  return context => (0, call_1.callRule)(chain(rules), (0, call_1.callSource)(source, context), context);\n}\nexports.apply = apply;\n/**\n * Merge an input tree with the source passed in.\n */\nfunction mergeWith(source, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callSource)(source, context).pipe((0, rxjs_1.map)(sourceTree => tree.merge(sourceTree, strategy || context.strategy)), (0, rxjs_1.mapTo)(tree));\n  };\n}\nexports.mergeWith = mergeWith;\nfunction noop() {\n  return () => {};\n}\nexports.noop = noop;\nfunction filter(predicate) {\n  return tree => {\n    if (host_tree_1.HostTree.isHostTree(tree)) {\n      return new host_tree_1.FilterHostTree(tree, predicate);\n    } else {\n      throw new exception_1.SchematicsException('Tree type is not supported.');\n    }\n  };\n}\nexports.filter = filter;\nfunction asSource(rule) {\n  return context => (0, call_1.callRule)(rule, (0, static_1.empty)(), context);\n}\nexports.asSource = asSource;\nfunction branchAndMerge(rule, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callRule)(rule, tree.branch(), context).pipe((0, rxjs_1.map)(branch => tree.merge(branch, strategy || context.strategy)), (0, rxjs_1.mapTo)(tree));\n  };\n}\nexports.branchAndMerge = branchAndMerge;\nfunction when(predicate, operator) {\n  return entry => {\n    if (predicate(entry.path, entry)) {\n      return operator(entry);\n    } else {\n      return entry;\n    }\n  };\n}\nexports.when = when;\nfunction partitionApplyMerge(predicate, ruleYes, ruleNo) {\n  return (tree, context) => {\n    const [yes, no] = (0, static_1.partition)(tree, predicate);\n    return (0, rxjs_1.concat)((0, call_1.callRule)(ruleYes, yes, context), (0, call_1.callRule)(ruleNo || noop(), no, context)).pipe((0, rxjs_1.toArray)(), (0, rxjs_1.map)(([yesTree, noTree]) => {\n      yesTree.merge(noTree, context.strategy);\n      return yesTree;\n    }));\n  };\n}\nexports.partitionApplyMerge = partitionApplyMerge;\nfunction forEach(operator) {\n  return tree => {\n    tree.visit((path, entry) => {\n      if (!entry) {\n        return;\n      }\n      const newEntry = operator(entry);\n      if (newEntry === entry) {\n        return;\n      }\n      if (newEntry === null) {\n        tree.delete(path);\n        return;\n      }\n      if (newEntry.path != path) {\n        tree.rename(path, newEntry.path);\n      }\n      if (!newEntry.content.equals(entry.content)) {\n        tree.overwrite(newEntry.path, newEntry.content);\n      }\n    });\n  };\n}\nexports.forEach = forEach;\nfunction composeFileOperators(operators) {\n  return entry => {\n    let current = entry;\n    for (const op of operators) {\n      current = op(current);\n      if (current === null) {\n        // Deleted, just return.\n        return null;\n      }\n    }\n    return current;\n  };\n}\nexports.composeFileOperators = composeFileOperators;\nfunction applyToSubtree(path, rules) {\n  return (tree, context) => {\n    const scoped = new scoped_1.ScopedTree(tree, path);\n    return (0, call_1.callRule)(chain(rules), scoped, context).pipe((0, rxjs_1.map)(result => {\n      if (result === scoped) {\n        return tree;\n      } else {\n        throw new exception_1.SchematicsException('Original tree must be returned from all rules when using \"applyToSubtree\".');\n      }\n    }));\n  };\n}\nexports.applyToSubtree = applyToSubtree;","map":{"version":3,"names":["_asyncToGenerator","require","default","_asyncIterator","Object","defineProperty","exports","value","applyToSubtree","composeFileOperators","forEach","partitionApplyMerge","when","branchAndMerge","asSource","filter","noop","mergeWith","apply","chain","empty","source","rxjs_1","exception_1","host_tree_1","interface_1","scoped_1","static_1","call_1","tree","rules","_ref","initialTree","context","intermediateTree","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","rule","callRule","err","return","_x","_x2","arguments","callSource","strategy","MergeStrategy","Default","pipe","map","sourceTree","merge","mapTo","predicate","HostTree","isHostTree","FilterHostTree","SchematicsException","branch","operator","entry","path","ruleYes","ruleNo","yes","no","partition","concat","toArray","yesTree","noTree","visit","newEntry","delete","rename","content","equals","overwrite","operators","current","op","scoped","ScopedTree","result"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular-devkit/schematics/src/rules/base.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyToSubtree = exports.composeFileOperators = exports.forEach = exports.partitionApplyMerge = exports.when = exports.branchAndMerge = exports.asSource = exports.filter = exports.noop = exports.mergeWith = exports.apply = exports.chain = exports.empty = exports.source = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst exception_1 = require(\"../exception/exception\");\nconst host_tree_1 = require(\"../tree/host-tree\");\nconst interface_1 = require(\"../tree/interface\");\nconst scoped_1 = require(\"../tree/scoped\");\nconst static_1 = require(\"../tree/static\");\nconst call_1 = require(\"./call\");\n/**\n * A Source that returns an tree as its single value.\n */\nfunction source(tree) {\n    return () => tree;\n}\nexports.source = source;\n/**\n * A source that returns an empty tree.\n */\nfunction empty() {\n    return () => (0, static_1.empty)();\n}\nexports.empty = empty;\n/**\n * Chain multiple rules into a single rule.\n */\nfunction chain(rules) {\n    return async (initialTree, context) => {\n        let intermediateTree;\n        for await (const rule of rules) {\n            intermediateTree = (0, call_1.callRule)(rule, intermediateTree ?? initialTree, context);\n        }\n        return () => intermediateTree;\n    };\n}\nexports.chain = chain;\n/**\n * Apply multiple rules to a source, and returns the source transformed.\n */\nfunction apply(source, rules) {\n    return (context) => (0, call_1.callRule)(chain(rules), (0, call_1.callSource)(source, context), context);\n}\nexports.apply = apply;\n/**\n * Merge an input tree with the source passed in.\n */\nfunction mergeWith(source, strategy = interface_1.MergeStrategy.Default) {\n    return (tree, context) => {\n        return (0, call_1.callSource)(source, context).pipe((0, rxjs_1.map)((sourceTree) => tree.merge(sourceTree, strategy || context.strategy)), (0, rxjs_1.mapTo)(tree));\n    };\n}\nexports.mergeWith = mergeWith;\nfunction noop() {\n    return () => { };\n}\nexports.noop = noop;\nfunction filter(predicate) {\n    return (tree) => {\n        if (host_tree_1.HostTree.isHostTree(tree)) {\n            return new host_tree_1.FilterHostTree(tree, predicate);\n        }\n        else {\n            throw new exception_1.SchematicsException('Tree type is not supported.');\n        }\n    };\n}\nexports.filter = filter;\nfunction asSource(rule) {\n    return (context) => (0, call_1.callRule)(rule, (0, static_1.empty)(), context);\n}\nexports.asSource = asSource;\nfunction branchAndMerge(rule, strategy = interface_1.MergeStrategy.Default) {\n    return (tree, context) => {\n        return (0, call_1.callRule)(rule, tree.branch(), context).pipe((0, rxjs_1.map)((branch) => tree.merge(branch, strategy || context.strategy)), (0, rxjs_1.mapTo)(tree));\n    };\n}\nexports.branchAndMerge = branchAndMerge;\nfunction when(predicate, operator) {\n    return (entry) => {\n        if (predicate(entry.path, entry)) {\n            return operator(entry);\n        }\n        else {\n            return entry;\n        }\n    };\n}\nexports.when = when;\nfunction partitionApplyMerge(predicate, ruleYes, ruleNo) {\n    return (tree, context) => {\n        const [yes, no] = (0, static_1.partition)(tree, predicate);\n        return (0, rxjs_1.concat)((0, call_1.callRule)(ruleYes, yes, context), (0, call_1.callRule)(ruleNo || noop(), no, context)).pipe((0, rxjs_1.toArray)(), (0, rxjs_1.map)(([yesTree, noTree]) => {\n            yesTree.merge(noTree, context.strategy);\n            return yesTree;\n        }));\n    };\n}\nexports.partitionApplyMerge = partitionApplyMerge;\nfunction forEach(operator) {\n    return (tree) => {\n        tree.visit((path, entry) => {\n            if (!entry) {\n                return;\n            }\n            const newEntry = operator(entry);\n            if (newEntry === entry) {\n                return;\n            }\n            if (newEntry === null) {\n                tree.delete(path);\n                return;\n            }\n            if (newEntry.path != path) {\n                tree.rename(path, newEntry.path);\n            }\n            if (!newEntry.content.equals(entry.content)) {\n                tree.overwrite(newEntry.path, newEntry.content);\n            }\n        });\n    };\n}\nexports.forEach = forEach;\nfunction composeFileOperators(operators) {\n    return (entry) => {\n        let current = entry;\n        for (const op of operators) {\n            current = op(current);\n            if (current === null) {\n                // Deleted, just return.\n                return null;\n            }\n        }\n        return current;\n    };\n}\nexports.composeFileOperators = composeFileOperators;\nfunction applyToSubtree(path, rules) {\n    return (tree, context) => {\n        const scoped = new scoped_1.ScopedTree(tree, path);\n        return (0, call_1.callRule)(chain(rules), scoped, context).pipe((0, rxjs_1.map)((result) => {\n            if (result === scoped) {\n                return tree;\n            }\n            else {\n                throw new exception_1.SchematicsException('Original tree must be returned from all rules when using \"applyToSubtree\".');\n            }\n        }));\n    };\n}\nexports.applyToSubtree = applyToSubtree;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}