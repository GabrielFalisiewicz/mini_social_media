{"ast":null,"code":"\"use strict\";\n\n/**\n * @module LRUCache\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classPrivateMethodInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldSet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classStaticPrivateFieldSpecGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecGet.js\").default;\nvar _classStaticPrivateFieldSpecSet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classStaticPrivateFieldSpecSet.js\").default;\nvar _defineProperty = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nlet _Symbol$iterator;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' && performance && typeof performance.now === 'function' ? performance : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = typeof process === 'object' && !!process ? process : {};\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n  typeof PROCESS.emitWarning === 'function' ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    constructor() {\n      _defineProperty(this, \"onabort\", void 0);\n      _defineProperty(this, \"_onabort\", []);\n      _defineProperty(this, \"reason\", void 0);\n      _defineProperty(this, \"aborted\", false);\n    }\n    addEventListener(_, fn) {\n      this._onabort.push(fn);\n    }\n  };\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      _defineProperty(this, \"signal\", new AS());\n      warnACPolyfill();\n    }\n    abort(reason) {\n      if (this.signal.aborted) return;\n      //@ts-ignore\n      this.signal.reason = reason;\n      //@ts-ignore\n      this.signal.aborted = true;\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason);\n      }\n      this.signal.onabort?.(reason);\n    }\n  };\n  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return;\n    printACPolyfillWarning = false;\n    emitWarning('AbortController is not defined. If using lru-cache in ' + 'node 14, load an AbortController polyfill from the ' + '`node-abort-controller` package. A minimal polyfill is ' + 'provided for use by LRUCache.fetch(), but it should not be ' + 'relied upon in other contexts (eg, passing it to other APIs that ' + 'use AbortController/AbortSignal might have undesirable effects). ' + 'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n  };\n}\n/* c8 ignore stop */\nconst shouldWarn = code => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = n => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = max => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n  constructor(size) {\n    super(size);\n    this.fill(0);\n  }\n}\nclass Stack {\n  static create(max) {\n    const HeapCls = getUintArray(max);\n    if (!HeapCls) return [];\n    _classStaticPrivateFieldSpecSet(Stack, Stack, _constructing, true);\n    const s = new Stack(max, HeapCls);\n    _classStaticPrivateFieldSpecSet(Stack, Stack, _constructing, false);\n    return s;\n  }\n  constructor(max, HeapCls) {\n    _defineProperty(this, \"heap\", void 0);\n    _defineProperty(this, \"length\", void 0);\n    /* c8 ignore start */\n    if (!_classStaticPrivateFieldSpecGet(Stack, Stack, _constructing)) {\n      throw new TypeError('instantiate Stack using Stack.create(n)');\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max);\n    this.length = 0;\n  }\n  push(n) {\n    this.heap[this.length++] = n;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\n// private constructor\nvar _constructing = {\n  writable: true,\n  value: false\n};\nvar _max = /*#__PURE__*/new WeakMap();\nvar _maxSize = /*#__PURE__*/new WeakMap();\nvar _dispose = /*#__PURE__*/new WeakMap();\nvar _disposeAfter = /*#__PURE__*/new WeakMap();\nvar _fetchMethod = /*#__PURE__*/new WeakMap();\nvar _size = /*#__PURE__*/new WeakMap();\nvar _calculatedSize = /*#__PURE__*/new WeakMap();\nvar _keyMap = /*#__PURE__*/new WeakMap();\nvar _keyList = /*#__PURE__*/new WeakMap();\nvar _valList = /*#__PURE__*/new WeakMap();\nvar _next = /*#__PURE__*/new WeakMap();\nvar _prev = /*#__PURE__*/new WeakMap();\nvar _head = /*#__PURE__*/new WeakMap();\nvar _tail = /*#__PURE__*/new WeakMap();\nvar _free = /*#__PURE__*/new WeakMap();\nvar _disposed = /*#__PURE__*/new WeakMap();\nvar _sizes = /*#__PURE__*/new WeakMap();\nvar _starts = /*#__PURE__*/new WeakMap();\nvar _ttls = /*#__PURE__*/new WeakMap();\nvar _hasDispose = /*#__PURE__*/new WeakMap();\nvar _hasFetchMethod = /*#__PURE__*/new WeakMap();\nvar _hasDisposeAfter = /*#__PURE__*/new WeakMap();\nvar _initializeTTLTracking = /*#__PURE__*/new WeakSet();\nvar _updateItemAge = /*#__PURE__*/new WeakMap();\nvar _statusTTL = /*#__PURE__*/new WeakMap();\nvar _setItemTTL = /*#__PURE__*/new WeakMap();\nvar _isStale = /*#__PURE__*/new WeakMap();\nvar _initializeSizeTracking = /*#__PURE__*/new WeakSet();\nvar _removeItemSize = /*#__PURE__*/new WeakMap();\nvar _addItemSize = /*#__PURE__*/new WeakMap();\nvar _requireSize = /*#__PURE__*/new WeakMap();\nvar _indexes = /*#__PURE__*/new WeakSet();\nvar _rindexes = /*#__PURE__*/new WeakSet();\nvar _isValidIndex = /*#__PURE__*/new WeakSet();\nvar _evict = /*#__PURE__*/new WeakSet();\nvar _backgroundFetch = /*#__PURE__*/new WeakSet();\nvar _isBackgroundFetch = /*#__PURE__*/new WeakSet();\nvar _connect = /*#__PURE__*/new WeakSet();\nvar _moveToTail = /*#__PURE__*/new WeakSet();\n_Symbol$iterator = Symbol.iterator;\nclass LRUCache {\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals(c) {\n    return {\n      // properties\n      starts: _classPrivateFieldGet(c, _starts),\n      ttls: _classPrivateFieldGet(c, _ttls),\n      sizes: _classPrivateFieldGet(c, _sizes),\n      keyMap: _classPrivateFieldGet(c, _keyMap),\n      keyList: _classPrivateFieldGet(c, _keyList),\n      valList: _classPrivateFieldGet(c, _valList),\n      next: _classPrivateFieldGet(c, _next),\n      prev: _classPrivateFieldGet(c, _prev),\n      get head() {\n        return _classPrivateFieldGet(c, _head);\n      },\n      get tail() {\n        return _classPrivateFieldGet(c, _tail);\n      },\n      free: _classPrivateFieldGet(c, _free),\n      // methods\n      isBackgroundFetch: p => _classPrivateMethodGet(c, _isBackgroundFetch, _isBackgroundFetch2).call(c, p),\n      backgroundFetch: (k, index, options, context) => _classPrivateMethodGet(c, _backgroundFetch, _backgroundFetch2).call(c, k, index, options, context),\n      moveToTail: index => _classPrivateMethodGet(c, _moveToTail, _moveToTail2).call(c, index),\n      indexes: options => _classPrivateMethodGet(c, _indexes, _indexes2).call(c, options),\n      rindexes: options => _classPrivateMethodGet(c, _rindexes, _rindexes2).call(c, options),\n      isStale: index => _classPrivateFieldGet(c, _isStale).call(c, index)\n    };\n  }\n  // Protected read-only members\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max() {\n    return _classPrivateFieldGet(this, _max);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize() {\n    return _classPrivateFieldGet(this, _maxSize);\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize() {\n    return _classPrivateFieldGet(this, _calculatedSize);\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size() {\n    return _classPrivateFieldGet(this, _size);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod() {\n    return _classPrivateFieldGet(this, _fetchMethod);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return _classPrivateFieldGet(this, _dispose);\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return _classPrivateFieldGet(this, _disposeAfter);\n  }\n  constructor(_options) {\n    _classPrivateMethodInitSpec(this, _moveToTail);\n    _classPrivateMethodInitSpec(this, _connect);\n    _classPrivateMethodInitSpec(this, _isBackgroundFetch);\n    _classPrivateMethodInitSpec(this, _backgroundFetch);\n    _classPrivateMethodInitSpec(this, _evict);\n    _classPrivateMethodInitSpec(this, _isValidIndex);\n    _classPrivateMethodInitSpec(this, _rindexes);\n    _classPrivateMethodInitSpec(this, _indexes);\n    _classPrivateMethodInitSpec(this, _initializeSizeTracking);\n    _classPrivateMethodInitSpec(this, _initializeTTLTracking);\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    _classPrivateFieldInitSpec(this, _max, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _maxSize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _dispose, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disposeAfter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fetchMethod, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    _defineProperty(this, \"ttl\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    _defineProperty(this, \"ttlResolution\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    _defineProperty(this, \"ttlAutopurge\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    _defineProperty(this, \"updateAgeOnGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    _defineProperty(this, \"updateAgeOnHas\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    _defineProperty(this, \"allowStale\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    _defineProperty(this, \"noDisposeOnSet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    _defineProperty(this, \"noUpdateTTL\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    _defineProperty(this, \"maxEntrySize\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    _defineProperty(this, \"sizeCalculation\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    _defineProperty(this, \"noDeleteOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    _defineProperty(this, \"noDeleteOnStaleGet\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    _defineProperty(this, \"allowStaleOnFetchAbort\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    _defineProperty(this, \"allowStaleOnFetchRejection\", void 0);\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    _defineProperty(this, \"ignoreFetchAbort\", void 0);\n    // computed properties\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _calculatedSize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _keyMap, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _keyList, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _valList, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _next, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _prev, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _head, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _tail, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _free, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disposed, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _sizes, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _starts, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _ttls, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasDispose, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasFetchMethod, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasDisposeAfter, {\n      writable: true,\n      value: void 0\n    });\n    // conditionally set private methods related to TTL\n    _classPrivateFieldInitSpec(this, _updateItemAge, {\n      writable: true,\n      value: () => {}\n    });\n    _classPrivateFieldInitSpec(this, _statusTTL, {\n      writable: true,\n      value: () => {}\n    });\n    _classPrivateFieldInitSpec(this, _setItemTTL, {\n      writable: true,\n      value: () => {}\n    });\n    /* c8 ignore stop */\n    _classPrivateFieldInitSpec(this, _isStale, {\n      writable: true,\n      value: () => false\n    });\n    _classPrivateFieldInitSpec(this, _removeItemSize, {\n      writable: true,\n      value: _i => {}\n    });\n    _classPrivateFieldInitSpec(this, _addItemSize, {\n      writable: true,\n      value: (_i, _s, _st) => {}\n    });\n    _classPrivateFieldInitSpec(this, _requireSize, {\n      writable: true,\n      value: (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n          throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n      }\n    });\n    const {\n      max = 0,\n      ttl: _ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale: _allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize: _maxSize2 = 0,\n      maxEntrySize = 0,\n      sizeCalculation: _sizeCalculation,\n      fetchMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort\n    } = _options;\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer');\n    }\n    const UintArray = max ? getUintArray(max) : Array;\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max);\n    }\n    _classPrivateFieldSet(this, _max, max);\n    _classPrivateFieldSet(this, _maxSize, _maxSize2);\n    this.maxEntrySize = maxEntrySize || _classPrivateFieldGet(this, _maxSize);\n    this.sizeCalculation = _sizeCalculation;\n    if (this.sizeCalculation) {\n      if (!_classPrivateFieldGet(this, _maxSize) && !this.maxEntrySize) {\n        throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function');\n      }\n    }\n    if (fetchMethod !== undefined && typeof fetchMethod !== 'function') {\n      throw new TypeError('fetchMethod must be a function if specified');\n    }\n    _classPrivateFieldSet(this, _fetchMethod, fetchMethod);\n    _classPrivateFieldSet(this, _hasFetchMethod, !!fetchMethod);\n    _classPrivateFieldSet(this, _keyMap, new Map());\n    _classPrivateFieldSet(this, _keyList, new Array(max).fill(undefined));\n    _classPrivateFieldSet(this, _valList, new Array(max).fill(undefined));\n    _classPrivateFieldSet(this, _next, new UintArray(max));\n    _classPrivateFieldSet(this, _prev, new UintArray(max));\n    _classPrivateFieldSet(this, _head, 0);\n    _classPrivateFieldSet(this, _tail, 0);\n    _classPrivateFieldSet(this, _free, Stack.create(max));\n    _classPrivateFieldSet(this, _size, 0);\n    _classPrivateFieldSet(this, _calculatedSize, 0);\n    if (typeof dispose === 'function') {\n      _classPrivateFieldSet(this, _dispose, dispose);\n    }\n    if (typeof disposeAfter === 'function') {\n      _classPrivateFieldSet(this, _disposeAfter, disposeAfter);\n      _classPrivateFieldSet(this, _disposed, []);\n    } else {\n      _classPrivateFieldSet(this, _disposeAfter, undefined);\n      _classPrivateFieldSet(this, _disposed, undefined);\n    }\n    _classPrivateFieldSet(this, _hasDispose, !!_classPrivateFieldGet(this, _dispose));\n    _classPrivateFieldSet(this, _hasDisposeAfter, !!_classPrivateFieldGet(this, _disposeAfter));\n    this.noDisposeOnSet = !!noDisposeOnSet;\n    this.noUpdateTTL = !!noUpdateTTL;\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n    this.ignoreFetchAbort = !!ignoreFetchAbort;\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (_classPrivateFieldGet(this, _maxSize) !== 0) {\n        if (!isPosInt(_classPrivateFieldGet(this, _maxSize))) {\n          throw new TypeError('maxSize must be a positive integer if specified');\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError('maxEntrySize must be a positive integer if specified');\n      }\n      _classPrivateMethodGet(this, _initializeSizeTracking, _initializeSizeTracking2).call(this);\n    }\n    this.allowStale = !!_allowStale;\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n    this.updateAgeOnGet = !!updateAgeOnGet;\n    this.updateAgeOnHas = !!updateAgeOnHas;\n    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n    this.ttlAutopurge = !!ttlAutopurge;\n    this.ttl = _ttl || 0;\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError('ttl must be a positive integer if specified');\n      }\n      _classPrivateMethodGet(this, _initializeTTLTracking, _initializeTTLTracking2).call(this);\n    }\n    // do not allow completely unbounded caches\n    if (_classPrivateFieldGet(this, _max) === 0 && this.ttl === 0 && _classPrivateFieldGet(this, _maxSize) === 0) {\n      throw new TypeError('At least one of max, maxSize, or ttl is required');\n    }\n    if (!this.ttlAutopurge && !_classPrivateFieldGet(this, _max) && !_classPrivateFieldGet(this, _maxSize)) {\n      const code = 'LRU_CACHE_UNBOUNDED';\n      if (shouldWarn(code)) {\n        warned.add(code);\n        const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' + 'result in unbounded memory consumption.';\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n      }\n    }\n  }\n  /**\n   * Return the remaining TTL time for a given entry key\n   */\n  getRemainingTTL(key) {\n    return _classPrivateFieldGet(this, _keyMap).has(key) ? Infinity : 0;\n  }\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      if (_classPrivateFieldGet(this, _valList)[i] !== undefined && _classPrivateFieldGet(this, _keyList)[i] !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield [_classPrivateFieldGet(this, _keyList)[i], _classPrivateFieldGet(this, _valList)[i]];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      if (_classPrivateFieldGet(this, _valList)[i] !== undefined && _classPrivateFieldGet(this, _keyList)[i] !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield [_classPrivateFieldGet(this, _keyList)[i], _classPrivateFieldGet(this, _valList)[i]];\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const k = _classPrivateFieldGet(this, _keyList)[i];\n      if (k !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const k = _classPrivateFieldGet(this, _keyList)[i];\n      if (k !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield k;\n      }\n    }\n  }\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      if (v !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield _classPrivateFieldGet(this, _valList)[i];\n      }\n    }\n  }\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      if (v !== undefined && !_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, _classPrivateFieldGet(this, _valList)[i])) {\n        yield _classPrivateFieldGet(this, _valList)[i];\n      }\n    }\n  }\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [_Symbol$iterator]() {\n    return this.entries();\n  }\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to Array.find().  fn is called as fn(value, key, cache).\n   */\n  find(fn, getOptions = {}) {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      if (fn(value, _classPrivateFieldGet(this, _keyList)[i], this)) {\n        return this.get(_classPrivateFieldGet(this, _keyList)[i], getOptions);\n      }\n    }\n  }\n  /**\n   * Call the supplied function on each item in the cache, in order from\n   * most recently used to least recently used.  fn is called as\n   * fn(value, key, cache).  Does not update age or recenty of use.\n   * Does not iterate over stale values.\n   */\n  forEach(fn, thisp = this) {\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(this, _keyList)[i], this);\n    }\n  }\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(fn, thisp = this) {\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this)) {\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined) continue;\n      fn.call(thisp, value, _classPrivateFieldGet(this, _keyList)[i], this);\n    }\n  }\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false;\n    for (const i of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this, {\n      allowStale: true\n    })) {\n      if (_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        this.delete(_classPrivateFieldGet(this, _keyList)[i]);\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to cache.load()\n   */\n  dump() {\n    const arr = [];\n    for (const i of _classPrivateMethodGet(this, _indexes, _indexes2).call(this, {\n      allowStale: true\n    })) {\n      const key = _classPrivateFieldGet(this, _keyList)[i];\n      const v = _classPrivateFieldGet(this, _valList)[i];\n      const value = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n      if (value === undefined || key === undefined) continue;\n      const entry = {\n        value\n      };\n      if (_classPrivateFieldGet(this, _ttls) && _classPrivateFieldGet(this, _starts)) {\n        entry.ttl = _classPrivateFieldGet(this, _ttls)[i];\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - _classPrivateFieldGet(this, _starts)[i];\n        entry.start = Math.floor(Date.now() - age);\n      }\n      if (_classPrivateFieldGet(this, _sizes)) {\n        entry.size = _classPrivateFieldGet(this, _sizes)[i];\n      }\n      arr.unshift([key, entry]);\n    }\n    return arr;\n  }\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   * Note that the shape of the resulting cache may be different if the\n   * same options are not used in both caches.\n   */\n  load(arr) {\n    this.clear();\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start;\n        entry.start = perf.now() - age;\n      }\n      this.set(key, entry.value, entry);\n    }\n  }\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   */\n  set(k, v, setOptions = {}) {\n    if (v === undefined) {\n      this.delete(k);\n      return this;\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status\n    } = setOptions;\n    let {\n      noUpdateTTL = this.noUpdateTTL\n    } = setOptions;\n    const size = _classPrivateFieldGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss';\n        status.maxEntrySizeExceeded = true;\n      }\n      // have to delete, in case something is there already.\n      this.delete(k);\n      return this;\n    }\n    let index = _classPrivateFieldGet(this, _size) === 0 ? undefined : _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index === undefined) {\n      var _this$size, _this$size2;\n      // addition\n      index = _classPrivateFieldGet(this, _size) === 0 ? _classPrivateFieldGet(this, _tail) : _classPrivateFieldGet(this, _free).length !== 0 ? _classPrivateFieldGet(this, _free).pop() : _classPrivateFieldGet(this, _size) === _classPrivateFieldGet(this, _max) ? _classPrivateMethodGet(this, _evict, _evict2).call(this, false) : _classPrivateFieldGet(this, _size);\n      _classPrivateFieldGet(this, _keyList)[index] = k;\n      _classPrivateFieldGet(this, _valList)[index] = v;\n      _classPrivateFieldGet(this, _keyMap).set(k, index);\n      _classPrivateFieldGet(this, _next)[_classPrivateFieldGet(this, _tail)] = index;\n      _classPrivateFieldGet(this, _prev)[index] = _classPrivateFieldGet(this, _tail);\n      _classPrivateFieldSet(this, _tail, index);\n      _classPrivateFieldSet(this, _size, (_this$size = _classPrivateFieldGet(this, _size), _this$size2 = _this$size++, _this$size)), _this$size2;\n      _classPrivateFieldGet(this, _addItemSize).call(this, index, size, status);\n      if (status) status.set = 'add';\n      noUpdateTTL = false;\n    } else {\n      // update\n      _classPrivateMethodGet(this, _moveToTail, _moveToTail2).call(this, index);\n      const oldVal = _classPrivateFieldGet(this, _valList)[index];\n      if (v !== oldVal) {\n        if (_classPrivateFieldGet(this, _hasFetchMethod) && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'));\n        } else if (!noDisposeOnSet) {\n          if (_classPrivateFieldGet(this, _hasDispose)) {\n            _classPrivateFieldGet(this, _dispose)?.call(this, oldVal, k, 'set');\n          }\n          if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n            _classPrivateFieldGet(this, _disposed)?.push([oldVal, k, 'set']);\n          }\n        }\n        _classPrivateFieldGet(this, _removeItemSize).call(this, index);\n        _classPrivateFieldGet(this, _addItemSize).call(this, index, size, status);\n        _classPrivateFieldGet(this, _valList)[index] = v;\n        if (status) {\n          status.set = 'replace';\n          const oldValue = oldVal && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;\n          if (oldValue !== undefined) status.oldValue = oldValue;\n        }\n      } else if (status) {\n        status.set = 'update';\n      }\n    }\n    if (ttl !== 0 && !_classPrivateFieldGet(this, _ttls)) {\n      _classPrivateMethodGet(this, _initializeTTLTracking, _initializeTTLTracking2).call(this);\n    }\n    if (_classPrivateFieldGet(this, _ttls)) {\n      if (!noUpdateTTL) {\n        _classPrivateFieldGet(this, _setItemTTL).call(this, index, ttl, start);\n      }\n      if (status) _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n    }\n    if (!noDisposeOnSet && _classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n    return this;\n  }\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop() {\n    try {\n      while (_classPrivateFieldGet(this, _size)) {\n        const val = _classPrivateFieldGet(this, _valList)[_classPrivateFieldGet(this, _head)];\n        _classPrivateMethodGet(this, _evict, _evict2).call(this, true);\n        if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching;\n          }\n        } else if (val !== undefined) {\n          return val;\n        }\n      }\n    } finally {\n      if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n        const dt = _classPrivateFieldGet(this, _disposed);\n        let task;\n        while (task = dt?.shift()) {\n          _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n        }\n      }\n    }\n  }\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k, hasOptions = {}) {\n    const {\n      updateAgeOnHas = this.updateAgeOnHas,\n      status\n    } = hasOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) && v.__staleWhileFetching === undefined) {\n        return false;\n      }\n      if (!_classPrivateFieldGet(this, _isStale).call(this, index)) {\n        if (updateAgeOnHas) {\n          _classPrivateFieldGet(this, _updateItemAge).call(this, index);\n        }\n        if (status) {\n          status.has = 'hit';\n          _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n        }\n        return true;\n      } else if (status) {\n        status.has = 'stale';\n        _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n      }\n    } else if (status) {\n      status.has = 'miss';\n    }\n    return false;\n  }\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k, peekOptions = {}) {\n    const {\n      allowStale = this.allowStale\n    } = peekOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined && (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, index))) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      // either stale and allowed, or forcing a refresh of non-stale value\n      return _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v) ? v.__staleWhileFetching : v;\n    }\n  }\n  fetch(k, fetchOptions = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        // get options\n        allowStale = _this.allowStale,\n        updateAgeOnGet = _this.updateAgeOnGet,\n        noDeleteOnStaleGet = _this.noDeleteOnStaleGet,\n        // set options\n        ttl = _this.ttl,\n        noDisposeOnSet = _this.noDisposeOnSet,\n        size = 0,\n        sizeCalculation = _this.sizeCalculation,\n        noUpdateTTL = _this.noUpdateTTL,\n        // fetch exclusive options\n        noDeleteOnFetchRejection = _this.noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection = _this.allowStaleOnFetchRejection,\n        ignoreFetchAbort = _this.ignoreFetchAbort,\n        allowStaleOnFetchAbort = _this.allowStaleOnFetchAbort,\n        context,\n        forceRefresh = false,\n        status,\n        signal\n      } = fetchOptions;\n      if (!_classPrivateFieldGet(_this, _hasFetchMethod)) {\n        if (status) status.fetch = 'get';\n        return _this.get(k, {\n          allowStale,\n          updateAgeOnGet,\n          noDeleteOnStaleGet,\n          status\n        });\n      }\n      const options = {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        ttl,\n        noDisposeOnSet,\n        size,\n        sizeCalculation,\n        noUpdateTTL,\n        noDeleteOnFetchRejection,\n        allowStaleOnFetchRejection,\n        allowStaleOnFetchAbort,\n        ignoreFetchAbort,\n        status,\n        signal\n      };\n      let index = _classPrivateFieldGet(_this, _keyMap).get(k);\n      if (index === undefined) {\n        if (status) status.fetch = 'miss';\n        const p = _classPrivateMethodGet(_this, _backgroundFetch, _backgroundFetch2).call(_this, k, index, options, context);\n        return p.__returned = p;\n      } else {\n        // in cache, maybe already fetching\n        const v = _classPrivateFieldGet(_this, _valList)[index];\n        if (_classPrivateMethodGet(_this, _isBackgroundFetch, _isBackgroundFetch2).call(_this, v)) {\n          const stale = allowStale && v.__staleWhileFetching !== undefined;\n          if (status) {\n            status.fetch = 'inflight';\n            if (stale) status.returnedStale = true;\n          }\n          return stale ? v.__staleWhileFetching : v.__returned = v;\n        }\n        // if we force a refresh, that means do NOT serve the cached value,\n        // unless we are already in the process of refreshing the cache.\n        const isStale = _classPrivateFieldGet(_this, _isStale).call(_this, index);\n        if (!forceRefresh && !isStale) {\n          if (status) status.fetch = 'hit';\n          _classPrivateMethodGet(_this, _moveToTail, _moveToTail2).call(_this, index);\n          if (updateAgeOnGet) {\n            _classPrivateFieldGet(_this, _updateItemAge).call(_this, index);\n          }\n          if (status) _classPrivateFieldGet(_this, _statusTTL).call(_this, status, index);\n          return v;\n        }\n        // ok, it is stale or a forced refresh, and not already fetching.\n        // refresh the cache.\n        const p = _classPrivateMethodGet(_this, _backgroundFetch, _backgroundFetch2).call(_this, k, index, options, context);\n        const hasStale = p.__staleWhileFetching !== undefined;\n        const staleVal = hasStale && allowStale;\n        if (status) {\n          status.fetch = isStale ? 'stale' : 'refresh';\n          if (staleVal && isStale) status.returnedStale = true;\n        }\n        return staleVal ? p.__staleWhileFetching : p.__returned = p;\n      }\n    })();\n  }\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k, getOptions = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status\n    } = getOptions;\n    const index = _classPrivateFieldGet(this, _keyMap).get(k);\n    if (index !== undefined) {\n      const value = _classPrivateFieldGet(this, _valList)[index];\n      const fetching = _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, value);\n      if (status) _classPrivateFieldGet(this, _statusTTL).call(this, status, index);\n      if (_classPrivateFieldGet(this, _isStale).call(this, index)) {\n        if (status) status.get = 'stale';\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.delete(k);\n          }\n          if (status && allowStale) status.returnedStale = true;\n          return allowStale ? value : undefined;\n        } else {\n          if (status && allowStale && value.__staleWhileFetching !== undefined) {\n            status.returnedStale = true;\n          }\n          return allowStale ? value.__staleWhileFetching : undefined;\n        }\n      } else {\n        if (status) status.get = 'hit';\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching;\n        }\n        _classPrivateMethodGet(this, _moveToTail, _moveToTail2).call(this, index);\n        if (updateAgeOnGet) {\n          _classPrivateFieldGet(this, _updateItemAge).call(this, index);\n        }\n        return value;\n      }\n    } else if (status) {\n      status.get = 'miss';\n    }\n  }\n  /**\n   * Deletes a key out of the cache.\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k) {\n    let deleted = false;\n    if (_classPrivateFieldGet(this, _size) !== 0) {\n      const index = _classPrivateFieldGet(this, _keyMap).get(k);\n      if (index !== undefined) {\n        deleted = true;\n        if (_classPrivateFieldGet(this, _size) === 1) {\n          this.clear();\n        } else {\n          var _this$size5, _this$size6;\n          _classPrivateFieldGet(this, _removeItemSize).call(this, index);\n          const v = _classPrivateFieldGet(this, _valList)[index];\n          if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n            v.__abortController.abort(new Error('deleted'));\n          } else if (_classPrivateFieldGet(this, _hasDispose) || _classPrivateFieldGet(this, _hasDisposeAfter)) {\n            if (_classPrivateFieldGet(this, _hasDispose)) {\n              _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'delete');\n            }\n            if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n              _classPrivateFieldGet(this, _disposed)?.push([v, k, 'delete']);\n            }\n          }\n          _classPrivateFieldGet(this, _keyMap).delete(k);\n          _classPrivateFieldGet(this, _keyList)[index] = undefined;\n          _classPrivateFieldGet(this, _valList)[index] = undefined;\n          if (index === _classPrivateFieldGet(this, _tail)) {\n            _classPrivateFieldSet(this, _tail, _classPrivateFieldGet(this, _prev)[index]);\n          } else if (index === _classPrivateFieldGet(this, _head)) {\n            _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[index]);\n          } else {\n            _classPrivateFieldGet(this, _next)[_classPrivateFieldGet(this, _prev)[index]] = _classPrivateFieldGet(this, _next)[index];\n            _classPrivateFieldGet(this, _prev)[_classPrivateFieldGet(this, _next)[index]] = _classPrivateFieldGet(this, _prev)[index];\n          }\n          _classPrivateFieldSet(this, _size, (_this$size5 = _classPrivateFieldGet(this, _size), _this$size6 = _this$size5--, _this$size5)), _this$size6;\n          _classPrivateFieldGet(this, _free).push(index);\n        }\n      }\n    }\n    if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)?.length) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n    return deleted;\n  }\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    for (const index of _classPrivateMethodGet(this, _rindexes, _rindexes2).call(this, {\n      allowStale: true\n    })) {\n      const v = _classPrivateFieldGet(this, _valList)[index];\n      if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n        v.__abortController.abort(new Error('deleted'));\n      } else {\n        const k = _classPrivateFieldGet(this, _keyList)[index];\n        if (_classPrivateFieldGet(this, _hasDispose)) {\n          _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'delete');\n        }\n        if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n          _classPrivateFieldGet(this, _disposed)?.push([v, k, 'delete']);\n        }\n      }\n    }\n    _classPrivateFieldGet(this, _keyMap).clear();\n    _classPrivateFieldGet(this, _valList).fill(undefined);\n    _classPrivateFieldGet(this, _keyList).fill(undefined);\n    if (_classPrivateFieldGet(this, _ttls) && _classPrivateFieldGet(this, _starts)) {\n      _classPrivateFieldGet(this, _ttls).fill(0);\n      _classPrivateFieldGet(this, _starts).fill(0);\n    }\n    if (_classPrivateFieldGet(this, _sizes)) {\n      _classPrivateFieldGet(this, _sizes).fill(0);\n    }\n    _classPrivateFieldSet(this, _head, 0);\n    _classPrivateFieldSet(this, _tail, 0);\n    _classPrivateFieldGet(this, _free).length = 0;\n    _classPrivateFieldSet(this, _calculatedSize, 0);\n    _classPrivateFieldSet(this, _size, 0);\n    if (_classPrivateFieldGet(this, _hasDisposeAfter) && _classPrivateFieldGet(this, _disposed)) {\n      const dt = _classPrivateFieldGet(this, _disposed);\n      let task;\n      while (task = dt?.shift()) {\n        _classPrivateFieldGet(this, _disposeAfter)?.call(this, ...task);\n      }\n    }\n  }\n}\nfunction _initializeTTLTracking2() {\n  const ttls = new ZeroArray(_classPrivateFieldGet(this, _max));\n  const starts = new ZeroArray(_classPrivateFieldGet(this, _max));\n  _classPrivateFieldSet(this, _ttls, ttls);\n  _classPrivateFieldSet(this, _starts, starts);\n  _classPrivateFieldSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {\n    starts[index] = ttl !== 0 ? start : 0;\n    ttls[index] = ttl;\n    if (ttl !== 0 && this.ttlAutopurge) {\n      const t = setTimeout(() => {\n        if (_classPrivateFieldGet(this, _isStale).call(this, index)) {\n          this.delete(_classPrivateFieldGet(this, _keyList)[index]);\n        }\n      }, ttl + 1);\n      // unref() not supported on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n  });\n\n  _classPrivateFieldSet(this, _updateItemAge, index => {\n    starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n  });\n  _classPrivateFieldSet(this, _statusTTL, (status, index) => {\n    if (ttls[index]) {\n      const ttl = ttls[index];\n      const start = starts[index];\n      status.ttl = ttl;\n      status.start = start;\n      status.now = cachedNow || getNow();\n      const age = status.now - start;\n      status.remainingTTL = ttl - age;\n    }\n  });\n  // debounce calls to perf.now() to 1s so we're not hitting\n  // that costly call repeatedly.\n  let cachedNow = 0;\n  const getNow = () => {\n    const n = perf.now();\n    if (this.ttlResolution > 0) {\n      cachedNow = n;\n      const t = setTimeout(() => cachedNow = 0, this.ttlResolution);\n      // not available on all platforms\n      /* c8 ignore start */\n      if (t.unref) {\n        t.unref();\n      }\n      /* c8 ignore stop */\n    }\n\n    return n;\n  };\n  this.getRemainingTTL = key => {\n    const index = _classPrivateFieldGet(this, _keyMap).get(key);\n    if (index === undefined) {\n      return 0;\n    }\n    const ttl = ttls[index];\n    const start = starts[index];\n    if (ttl === 0 || start === 0) {\n      return Infinity;\n    }\n    const age = (cachedNow || getNow()) - start;\n    return ttl - age;\n  };\n  _classPrivateFieldSet(this, _isStale, index => {\n    return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];\n  });\n}\nfunction _initializeSizeTracking2() {\n  const sizes = new ZeroArray(_classPrivateFieldGet(this, _max));\n  _classPrivateFieldSet(this, _calculatedSize, 0);\n  _classPrivateFieldSet(this, _sizes, sizes);\n  _classPrivateFieldSet(this, _removeItemSize, index => {\n    _classPrivateFieldSet(this, _calculatedSize, _classPrivateFieldGet(this, _calculatedSize) - sizes[index]);\n    sizes[index] = 0;\n  });\n  _classPrivateFieldSet(this, _requireSize, (k, v, size, sizeCalculation) => {\n    // provisionally accept background fetches.\n    // actual value size will be checked when they return.\n    if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n      return 0;\n    }\n    if (!isPosInt(size)) {\n      if (sizeCalculation) {\n        if (typeof sizeCalculation !== 'function') {\n          throw new TypeError('sizeCalculation must be a function');\n        }\n        size = sizeCalculation(v, k);\n        if (!isPosInt(size)) {\n          throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n        }\n      } else {\n        throw new TypeError('invalid size value (must be positive integer). ' + 'When maxSize or maxEntrySize is used, sizeCalculation ' + 'or size must be set.');\n      }\n    }\n    return size;\n  });\n  _classPrivateFieldSet(this, _addItemSize, (index, size, status) => {\n    sizes[index] = size;\n    if (_classPrivateFieldGet(this, _maxSize)) {\n      const maxSize = _classPrivateFieldGet(this, _maxSize) - sizes[index];\n      while (_classPrivateFieldGet(this, _calculatedSize) > maxSize) {\n        _classPrivateMethodGet(this, _evict, _evict2).call(this, true);\n      }\n    }\n    _classPrivateFieldSet(this, _calculatedSize, _classPrivateFieldGet(this, _calculatedSize) + sizes[index]);\n    if (status) {\n      status.entrySize = size;\n      status.totalCalculatedSize = _classPrivateFieldGet(this, _calculatedSize);\n    }\n  });\n}\nfunction* _indexes2({\n  allowStale = this.allowStale\n} = {}) {\n  if (_classPrivateFieldGet(this, _size)) {\n    for (let i = _classPrivateFieldGet(this, _tail); true;) {\n      if (!_classPrivateMethodGet(this, _isValidIndex, _isValidIndex2).call(this, i)) {\n        break;\n      }\n      if (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        yield i;\n      }\n      if (i === _classPrivateFieldGet(this, _head)) {\n        break;\n      } else {\n        i = _classPrivateFieldGet(this, _prev)[i];\n      }\n    }\n  }\n}\nfunction* _rindexes2({\n  allowStale = this.allowStale\n} = {}) {\n  if (_classPrivateFieldGet(this, _size)) {\n    for (let i = _classPrivateFieldGet(this, _head); true;) {\n      if (!_classPrivateMethodGet(this, _isValidIndex, _isValidIndex2).call(this, i)) {\n        break;\n      }\n      if (allowStale || !_classPrivateFieldGet(this, _isStale).call(this, i)) {\n        yield i;\n      }\n      if (i === _classPrivateFieldGet(this, _tail)) {\n        break;\n      } else {\n        i = _classPrivateFieldGet(this, _next)[i];\n      }\n    }\n  }\n}\nfunction _isValidIndex2(index) {\n  return index !== undefined && _classPrivateFieldGet(this, _keyMap).get(_classPrivateFieldGet(this, _keyList)[index]) === index;\n}\nfunction _evict2(free) {\n  var _this$size3, _this$size4;\n  const head = _classPrivateFieldGet(this, _head);\n  const k = _classPrivateFieldGet(this, _keyList)[head];\n  const v = _classPrivateFieldGet(this, _valList)[head];\n  if (_classPrivateFieldGet(this, _hasFetchMethod) && _classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n    v.__abortController.abort(new Error('evicted'));\n  } else if (_classPrivateFieldGet(this, _hasDispose) || _classPrivateFieldGet(this, _hasDisposeAfter)) {\n    if (_classPrivateFieldGet(this, _hasDispose)) {\n      _classPrivateFieldGet(this, _dispose)?.call(this, v, k, 'evict');\n    }\n    if (_classPrivateFieldGet(this, _hasDisposeAfter)) {\n      _classPrivateFieldGet(this, _disposed)?.push([v, k, 'evict']);\n    }\n  }\n  _classPrivateFieldGet(this, _removeItemSize).call(this, head);\n  // if we aren't about to use the index, then null these out\n  if (free) {\n    _classPrivateFieldGet(this, _keyList)[head] = undefined;\n    _classPrivateFieldGet(this, _valList)[head] = undefined;\n    _classPrivateFieldGet(this, _free).push(head);\n  }\n  if (_classPrivateFieldGet(this, _size) === 1) {\n    _classPrivateFieldSet(this, _head, _classPrivateFieldSet(this, _tail, 0));\n    _classPrivateFieldGet(this, _free).length = 0;\n  } else {\n    _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[head]);\n  }\n  _classPrivateFieldGet(this, _keyMap).delete(k);\n  _classPrivateFieldSet(this, _size, (_this$size3 = _classPrivateFieldGet(this, _size), _this$size4 = _this$size3--, _this$size3)), _this$size4;\n  return head;\n}\nfunction _backgroundFetch2(k, index, options, context) {\n  const v = index === undefined ? undefined : _classPrivateFieldGet(this, _valList)[index];\n  if (_classPrivateMethodGet(this, _isBackgroundFetch, _isBackgroundFetch2).call(this, v)) {\n    return v;\n  }\n  const ac = new AC();\n  const {\n    signal\n  } = options;\n  // when/if our AC signals, then stop listening to theirs.\n  signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n    signal: ac.signal\n  });\n  const fetchOpts = {\n    signal: ac.signal,\n    options,\n    context\n  };\n  const cb = (v, updateCache = false) => {\n    const {\n      aborted\n    } = ac.signal;\n    const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n    if (options.status) {\n      if (aborted && !updateCache) {\n        options.status.fetchAborted = true;\n        options.status.fetchError = ac.signal.reason;\n        if (ignoreAbort) options.status.fetchAbortIgnored = true;\n      } else {\n        options.status.fetchResolved = true;\n      }\n    }\n    if (aborted && !ignoreAbort && !updateCache) {\n      return fetchFail(ac.signal.reason);\n    }\n    // either we didn't abort, and are still here, or we did, and ignored\n    const bf = p;\n    if (_classPrivateFieldGet(this, _valList)[index] === p) {\n      if (v === undefined) {\n        if (bf.__staleWhileFetching) {\n          _classPrivateFieldGet(this, _valList)[index] = bf.__staleWhileFetching;\n        } else {\n          this.delete(k);\n        }\n      } else {\n        if (options.status) options.status.fetchUpdated = true;\n        this.set(k, v, fetchOpts.options);\n      }\n    }\n    return v;\n  };\n  const eb = er => {\n    if (options.status) {\n      options.status.fetchRejected = true;\n      options.status.fetchError = er;\n    }\n    return fetchFail(er);\n  };\n  const fetchFail = er => {\n    const {\n      aborted\n    } = ac.signal;\n    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n    const noDelete = allowStale || options.noDeleteOnFetchRejection;\n    const bf = p;\n    if (_classPrivateFieldGet(this, _valList)[index] === p) {\n      // if we allow stale on fetch rejections, then we need to ensure that\n      // the stale value is not removed from the cache when the fetch fails.\n      const del = !noDelete || bf.__staleWhileFetching === undefined;\n      if (del) {\n        this.delete(k);\n      } else if (!allowStaleAborted) {\n        // still replace the *promise* with the stale value,\n        // since we are done with the promise at this point.\n        // leave it untouched if we're still waiting for an\n        // aborted background fetch that hasn't yet returned.\n        _classPrivateFieldGet(this, _valList)[index] = bf.__staleWhileFetching;\n      }\n    }\n    if (allowStale) {\n      if (options.status && bf.__staleWhileFetching !== undefined) {\n        options.status.returnedStale = true;\n      }\n      return bf.__staleWhileFetching;\n    } else if (bf.__returned === bf) {\n      throw er;\n    }\n  };\n  const pcall = (res, rej) => {\n    const fmp = _classPrivateFieldGet(this, _fetchMethod)?.call(this, k, v, fetchOpts);\n    if (fmp && fmp instanceof Promise) {\n      fmp.then(v => res(v === undefined ? undefined : v), rej);\n    }\n    // ignored, we go until we finish, regardless.\n    // defer check until we are actually aborting,\n    // so fetchMethod can override.\n    ac.signal.addEventListener('abort', () => {\n      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n        res(undefined);\n        // when it eventually resolves, update the cache.\n        if (options.allowStaleOnFetchAbort) {\n          res = v => cb(v, true);\n        }\n      }\n    });\n  };\n  if (options.status) options.status.fetchDispatched = true;\n  const p = new Promise(pcall).then(cb, eb);\n  const bf = Object.assign(p, {\n    __abortController: ac,\n    __staleWhileFetching: v,\n    __returned: undefined\n  });\n  if (index === undefined) {\n    // internal, don't expose status.\n    this.set(k, bf, {\n      ...fetchOpts.options,\n      status: undefined\n    });\n    index = _classPrivateFieldGet(this, _keyMap).get(k);\n  } else {\n    _classPrivateFieldGet(this, _valList)[index] = bf;\n  }\n  return bf;\n}\nfunction _isBackgroundFetch2(p) {\n  if (!_classPrivateFieldGet(this, _hasFetchMethod)) return false;\n  const b = p;\n  return !!b && b instanceof Promise && b.hasOwnProperty('__staleWhileFetching') && b.__abortController instanceof AC;\n}\nfunction _connect2(p, n) {\n  _classPrivateFieldGet(this, _prev)[n] = p;\n  _classPrivateFieldGet(this, _next)[p] = n;\n}\nfunction _moveToTail2(index) {\n  // if tail already, nothing to do\n  // if head, move head to next[index]\n  // else\n  //   move next[prev[index]] to next[index] (head has no prev)\n  //   move prev[next[index]] to prev[index]\n  // prev[index] = tail\n  // next[tail] = index\n  // tail = index\n  if (index !== _classPrivateFieldGet(this, _tail)) {\n    if (index === _classPrivateFieldGet(this, _head)) {\n      _classPrivateFieldSet(this, _head, _classPrivateFieldGet(this, _next)[index]);\n    } else {\n      _classPrivateMethodGet(this, _connect, _connect2).call(this, _classPrivateFieldGet(this, _prev)[index], _classPrivateFieldGet(this, _next)[index]);\n    }\n    _classPrivateMethodGet(this, _connect, _connect2).call(this, _classPrivateFieldGet(this, _tail), index);\n    _classPrivateFieldSet(this, _tail, index);\n  }\n}\nexports.LRUCache = LRUCache;","map":{"version":3,"names":["_asyncToGenerator","require","default","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","_classPrivateMethodGet","_classPrivateFieldGet","_classStaticPrivateFieldSpecGet","_classStaticPrivateFieldSpecSet","_defineProperty","_Symbol$iterator","Object","defineProperty","exports","value","LRUCache","perf","performance","now","Date","warned","Set","PROCESS","process","emitWarning","msg","type","code","fn","console","error","AC","globalThis","AbortController","AS","AbortSignal","constructor","addEventListener","_","_onabort","push","warnACPolyfill","abort","reason","signal","aborted","onabort","printACPolyfillWarning","env","LRU_CACHE_IGNORE_AC_WARNING","shouldWarn","has","TYPE","Symbol","isPosInt","n","Math","floor","isFinite","getUintArray","max","pow","Uint8Array","Uint16Array","Uint32Array","Number","MAX_SAFE_INTEGER","ZeroArray","Array","size","fill","Stack","create","HeapCls","_constructing","s","TypeError","heap","length","pop","writable","_max","WeakMap","_maxSize","_dispose","_disposeAfter","_fetchMethod","_size","_calculatedSize","_keyMap","_keyList","_valList","_next","_prev","_head","_tail","_free","_disposed","_sizes","_starts","_ttls","_hasDispose","_hasFetchMethod","_hasDisposeAfter","_initializeTTLTracking","WeakSet","_updateItemAge","_statusTTL","_setItemTTL","_isStale","_initializeSizeTracking","_removeItemSize","_addItemSize","_requireSize","_indexes","_rindexes","_isValidIndex","_evict","_backgroundFetch","_isBackgroundFetch","_connect","_moveToTail","iterator","unsafeExposeInternals","c","starts","ttls","sizes","keyMap","keyList","valList","next","prev","head","tail","free","isBackgroundFetch","p","_isBackgroundFetch2","call","backgroundFetch","k","index","options","context","_backgroundFetch2","moveToTail","_moveToTail2","indexes","_indexes2","rindexes","_rindexes2","isStale","maxSize","calculatedSize","fetchMethod","dispose","disposeAfter","_i","_s","_st","_k","_v","sizeCalculation","ttl","ttlResolution","ttlAutopurge","updateAgeOnGet","updateAgeOnHas","allowStale","noDisposeOnSet","noUpdateTTL","maxEntrySize","noDeleteOnFetchRejection","noDeleteOnStaleGet","allowStaleOnFetchRejection","allowStaleOnFetchAbort","ignoreFetchAbort","UintArray","Error","undefined","Map","_initializeSizeTracking2","_initializeTTLTracking2","add","getRemainingTTL","key","Infinity","entries","i","rentries","keys","rkeys","values","v","rvalues","find","getOptions","__staleWhileFetching","get","forEach","thisp","rforEach","purgeStale","deleted","delete","dump","arr","entry","age","start","unshift","load","clear","set","setOptions","status","maxEntrySizeExceeded","_this$size","_this$size2","_evict2","oldVal","__abortController","oldValue","dt","task","shift","val","hasOptions","peek","peekOptions","fetch","fetchOptions","_this","forceRefresh","__returned","stale","returnedStale","hasStale","staleVal","fetching","_this$size5","_this$size6","t","setTimeout","unref","cachedNow","getNow","remainingTTL","entrySize","totalCalculatedSize","_isValidIndex2","_this$size3","_this$size4","ac","fetchOpts","cb","updateCache","ignoreAbort","fetchAborted","fetchError","fetchAbortIgnored","fetchResolved","fetchFail","bf","fetchUpdated","eb","er","fetchRejected","allowStaleAborted","noDelete","del","pcall","res","rej","fmp","Promise","then","fetchDispatched","assign","b","hasOwnProperty","_connect2"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/path-scurry/node_modules/lru-cache/dist/cjs/index.js"],"sourcesContent":["\"use strict\";\n/**\n * @module LRUCache\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */\nclass LRUCache {\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the remaining TTL time for a given entry key\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (ttl === 0 || start === 0) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            return (ttls[index] !== 0 &&\n                starts[index] !== 0 &&\n                (cachedNow || getNow()) - starts[index] > ttls[index]);\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to Array.find().  fn is called as fn(value, key, cache).\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from\n     * most recently used to least recently used.  fn is called as\n     * fn(value, key, cache).  Does not update age or recenty of use.\n     * Does not iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to cache.load()\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     * Note that the shape of the resulting cache may be different if the\n     * same options are not used in both caches.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined &&\n            (allowStale || !this.#isStale(index))) {\n            const v = this.#valList[index];\n            // either stale and allowed, or forcing a refresh of non-stale value\n            return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        }\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.delete(k);\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, 'delete');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, 'delete']);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        this.#next[this.#prev[index]] = this.#next[index];\n                        this.#prev[this.#next[index]] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, 'delete');\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, 'delete']);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}