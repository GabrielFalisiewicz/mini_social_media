{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst events = require('events');\nconst contentPath = require('./path');\nconst fs = require('fs/promises');\nconst {\n  moveFile\n} = require('@npmcli/fs');\nconst {\n  Minipass\n} = require('minipass');\nconst Pipeline = require('minipass-pipeline');\nconst Flush = require('minipass-flush');\nconst path = require('path');\nconst ssri = require('ssri');\nconst uniqueFilename = require('unique-filename');\nconst fsm = require('fs-minipass');\nmodule.exports = write;\n\n// Cache of move operations in process so we don't duplicate\nconst moveOperations = new Map();\nfunction write(_x, _x2) {\n  return _write.apply(this, arguments);\n}\nfunction _write() {\n  _write = _asyncToGenerator(function* (cache, data, opts = {}) {\n    const {\n      algorithms,\n      size,\n      integrity\n    } = opts;\n    if (typeof size === 'number' && data.length !== size) {\n      throw sizeError(size, data.length);\n    }\n    const sri = ssri.fromData(data, algorithms ? {\n      algorithms\n    } : {});\n    if (integrity && !ssri.checkData(data, integrity, opts)) {\n      throw checksumError(integrity, sri);\n    }\n    for (const algo in sri) {\n      const tmp = yield makeTmp(cache, opts);\n      const hash = sri[algo].toString();\n      try {\n        yield fs.writeFile(tmp.target, data, {\n          flag: 'wx'\n        });\n        yield moveToDestination(tmp, cache, hash, opts);\n      } finally {\n        if (!tmp.moved) {\n          yield fs.rm(tmp.target, {\n            recursive: true,\n            force: true\n          });\n        }\n      }\n    }\n    return {\n      integrity: sri,\n      size: data.length\n    };\n  });\n  return _write.apply(this, arguments);\n}\nmodule.exports.stream = writeStream;\n\n// writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\nclass CacacheWriteStream extends Flush {\n  constructor(cache, opts) {\n    super();\n    this.opts = opts;\n    this.cache = cache;\n    this.inputStream = new Minipass();\n    this.inputStream.on('error', er => this.emit('error', er));\n    this.inputStream.on('drain', () => this.emit('drain'));\n    this.handleContentP = null;\n  }\n  write(chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);\n    }\n    return this.inputStream.write(chunk, encoding, cb);\n  }\n  flush(cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty');\n        e.code = 'ENODATA';\n        // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n        return Promise.reject(e).catch(cb);\n      }\n      // eslint-disable-next-line promise/catch-or-return\n      this.handleContentP.then(res => {\n        res.integrity && this.emit('integrity', res.integrity);\n        // eslint-disable-next-line promise/always-return\n        res.size !== null && this.emit('size', res.size);\n        cb();\n      }, er => cb(er));\n    });\n  }\n}\nfunction writeStream(cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts);\n}\nfunction handleContent(_x3, _x4, _x5) {\n  return _handleContent.apply(this, arguments);\n}\nfunction _handleContent() {\n  _handleContent = _asyncToGenerator(function* (inputStream, cache, opts) {\n    const tmp = yield makeTmp(cache, opts);\n    try {\n      const res = yield pipeToTmp(inputStream, cache, tmp.target, opts);\n      yield moveToDestination(tmp, cache, res.integrity, opts);\n      return res;\n    } finally {\n      if (!tmp.moved) {\n        yield fs.rm(tmp.target, {\n          recursive: true,\n          force: true\n        });\n      }\n    }\n  });\n  return _handleContent.apply(this, arguments);\n}\nfunction pipeToTmp(_x6, _x7, _x8, _x9) {\n  return _pipeToTmp.apply(this, arguments);\n}\nfunction _pipeToTmp() {\n  _pipeToTmp = _asyncToGenerator(function* (inputStream, cache, tmpTarget, opts) {\n    const outStream = new fsm.WriteStream(tmpTarget, {\n      flags: 'wx'\n    });\n    if (opts.integrityEmitter) {\n      // we need to create these all simultaneously since they can fire in any order\n      const [integrity, size] = yield Promise.all([events.once(opts.integrityEmitter, 'integrity').then(res => res[0]), events.once(opts.integrityEmitter, 'size').then(res => res[0]), new Pipeline(inputStream, outStream).promise()]);\n      return {\n        integrity,\n        size\n      };\n    }\n    let integrity;\n    let size;\n    const hashStream = ssri.integrityStream({\n      integrity: opts.integrity,\n      algorithms: opts.algorithms,\n      size: opts.size\n    });\n    hashStream.on('integrity', i => {\n      integrity = i;\n    });\n    hashStream.on('size', s => {\n      size = s;\n    });\n    const pipeline = new Pipeline(inputStream, hashStream, outStream);\n    yield pipeline.promise();\n    return {\n      integrity,\n      size\n    };\n  });\n  return _pipeToTmp.apply(this, arguments);\n}\nfunction makeTmp(_x10, _x11) {\n  return _makeTmp.apply(this, arguments);\n}\nfunction _makeTmp() {\n  _makeTmp = _asyncToGenerator(function* (cache, opts) {\n    const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n    yield fs.mkdir(path.dirname(tmpTarget), {\n      recursive: true\n    });\n    return {\n      target: tmpTarget,\n      moved: false\n    };\n  });\n  return _makeTmp.apply(this, arguments);\n}\nfunction moveToDestination(_x12, _x13, _x14, _x15) {\n  return _moveToDestination.apply(this, arguments);\n}\nfunction _moveToDestination() {\n  _moveToDestination = _asyncToGenerator(function* (tmp, cache, sri, opts) {\n    const destination = contentPath(cache, sri);\n    const destDir = path.dirname(destination);\n    if (moveOperations.has(destination)) {\n      return moveOperations.get(destination);\n    }\n    moveOperations.set(destination, fs.mkdir(destDir, {\n      recursive: true\n    }).then( /*#__PURE__*/_asyncToGenerator(function* () {\n      yield moveFile(tmp.target, destination, {\n        overwrite: false\n      });\n      tmp.moved = true;\n      return tmp.moved;\n    })).catch(err => {\n      if (!err.message.startsWith('The destination file exists')) {\n        throw Object.assign(err, {\n          code: 'EEXIST'\n        });\n      }\n    }).finally(() => {\n      moveOperations.delete(destination);\n    }));\n    return moveOperations.get(destination);\n  });\n  return _moveToDestination.apply(this, arguments);\n}\nfunction sizeError(expected, found) {\n  /* eslint-disable-next-line max-len */\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);\n  err.expected = expected;\n  err.found = found;\n  err.code = 'EBADSIZE';\n  return err;\n}\nfunction checksumError(expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`);\n  err.code = 'EINTEGRITY';\n  err.expected = expected;\n  err.found = found;\n  return err;\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","events","contentPath","fs","moveFile","Minipass","Pipeline","Flush","path","ssri","uniqueFilename","fsm","module","exports","write","moveOperations","Map","_x","_x2","_write","apply","arguments","cache","data","opts","algorithms","size","integrity","length","sizeError","sri","fromData","checkData","checksumError","algo","tmp","makeTmp","hash","toString","writeFile","target","flag","moveToDestination","moved","rm","recursive","force","stream","writeStream","CacacheWriteStream","constructor","inputStream","on","er","emit","handleContentP","chunk","encoding","cb","handleContent","flush","end","e","Error","code","Promise","reject","catch","then","res","_x3","_x4","_x5","_handleContent","pipeToTmp","_x6","_x7","_x8","_x9","_pipeToTmp","tmpTarget","outStream","WriteStream","flags","integrityEmitter","all","once","promise","hashStream","integrityStream","i","s","pipeline","_x10","_x11","_makeTmp","join","tmpPrefix","mkdir","dirname","_x12","_x13","_x14","_x15","_moveToDestination","destination","destDir","has","get","set","overwrite","err","message","startsWith","Object","assign","finally","delete","expected","found"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/cacache/lib/content/write.js"],"sourcesContent":["'use strict'\n\nconst events = require('events')\n\nconst contentPath = require('./path')\nconst fs = require('fs/promises')\nconst { moveFile } = require('@npmcli/fs')\nconst { Minipass } = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst Flush = require('minipass-flush')\nconst path = require('path')\nconst ssri = require('ssri')\nconst uniqueFilename = require('unique-filename')\nconst fsm = require('fs-minipass')\n\nmodule.exports = write\n\n// Cache of move operations in process so we don't duplicate\nconst moveOperations = new Map()\n\nasync function write (cache, data, opts = {}) {\n  const { algorithms, size, integrity } = opts\n\n  if (typeof size === 'number' && data.length !== size) {\n    throw sizeError(size, data.length)\n  }\n\n  const sri = ssri.fromData(data, algorithms ? { algorithms } : {})\n  if (integrity && !ssri.checkData(data, integrity, opts)) {\n    throw checksumError(integrity, sri)\n  }\n\n  for (const algo in sri) {\n    const tmp = await makeTmp(cache, opts)\n    const hash = sri[algo].toString()\n    try {\n      await fs.writeFile(tmp.target, data, { flag: 'wx' })\n      await moveToDestination(tmp, cache, hash, opts)\n    } finally {\n      if (!tmp.moved) {\n        await fs.rm(tmp.target, { recursive: true, force: true })\n      }\n    }\n  }\n  return { integrity: sri, size: data.length }\n}\n\nmodule.exports.stream = writeStream\n\n// writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\nclass CacacheWriteStream extends Flush {\n  constructor (cache, opts) {\n    super()\n    this.opts = opts\n    this.cache = cache\n    this.inputStream = new Minipass()\n    this.inputStream.on('error', er => this.emit('error', er))\n    this.inputStream.on('drain', () => this.emit('drain'))\n    this.handleContentP = null\n  }\n\n  write (chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(\n        this.inputStream,\n        this.cache,\n        this.opts\n      )\n    }\n    return this.inputStream.write(chunk, encoding, cb)\n  }\n\n  flush (cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty')\n        e.code = 'ENODATA'\n        // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n        return Promise.reject(e).catch(cb)\n      }\n      // eslint-disable-next-line promise/catch-or-return\n      this.handleContentP.then(\n        (res) => {\n          res.integrity && this.emit('integrity', res.integrity)\n          // eslint-disable-next-line promise/always-return\n          res.size !== null && this.emit('size', res.size)\n          cb()\n        },\n        (er) => cb(er)\n      )\n    })\n  }\n}\n\nfunction writeStream (cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts)\n}\n\nasync function handleContent (inputStream, cache, opts) {\n  const tmp = await makeTmp(cache, opts)\n  try {\n    const res = await pipeToTmp(inputStream, cache, tmp.target, opts)\n    await moveToDestination(\n      tmp,\n      cache,\n      res.integrity,\n      opts\n    )\n    return res\n  } finally {\n    if (!tmp.moved) {\n      await fs.rm(tmp.target, { recursive: true, force: true })\n    }\n  }\n}\n\nasync function pipeToTmp (inputStream, cache, tmpTarget, opts) {\n  const outStream = new fsm.WriteStream(tmpTarget, {\n    flags: 'wx',\n  })\n\n  if (opts.integrityEmitter) {\n    // we need to create these all simultaneously since they can fire in any order\n    const [integrity, size] = await Promise.all([\n      events.once(opts.integrityEmitter, 'integrity').then(res => res[0]),\n      events.once(opts.integrityEmitter, 'size').then(res => res[0]),\n      new Pipeline(inputStream, outStream).promise(),\n    ])\n    return { integrity, size }\n  }\n\n  let integrity\n  let size\n  const hashStream = ssri.integrityStream({\n    integrity: opts.integrity,\n    algorithms: opts.algorithms,\n    size: opts.size,\n  })\n  hashStream.on('integrity', i => {\n    integrity = i\n  })\n  hashStream.on('size', s => {\n    size = s\n  })\n\n  const pipeline = new Pipeline(inputStream, hashStream, outStream)\n  await pipeline.promise()\n  return { integrity, size }\n}\n\nasync function makeTmp (cache, opts) {\n  const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix)\n  await fs.mkdir(path.dirname(tmpTarget), { recursive: true })\n  return {\n    target: tmpTarget,\n    moved: false,\n  }\n}\n\nasync function moveToDestination (tmp, cache, sri, opts) {\n  const destination = contentPath(cache, sri)\n  const destDir = path.dirname(destination)\n  if (moveOperations.has(destination)) {\n    return moveOperations.get(destination)\n  }\n  moveOperations.set(\n    destination,\n    fs.mkdir(destDir, { recursive: true })\n      .then(async () => {\n        await moveFile(tmp.target, destination, { overwrite: false })\n        tmp.moved = true\n        return tmp.moved\n      })\n      .catch(err => {\n        if (!err.message.startsWith('The destination file exists')) {\n          throw Object.assign(err, { code: 'EEXIST' })\n        }\n      }).finally(() => {\n        moveOperations.delete(destination)\n      })\n\n  )\n  return moveOperations.get(destination)\n}\n\nfunction sizeError (expected, found) {\n  /* eslint-disable-next-line max-len */\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`)\n  err.expected = expected\n  err.found = found\n  err.code = 'EBADSIZE'\n  return err\n}\n\nfunction checksumError (expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`)\n  err.code = 'EINTEGRITY'\n  err.expected = expected\n  err.found = found\n  return err\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}