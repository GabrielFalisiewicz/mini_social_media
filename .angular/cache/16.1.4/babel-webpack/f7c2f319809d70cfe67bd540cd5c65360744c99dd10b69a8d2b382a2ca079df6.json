{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toProposedIntotoEntry = exports.toProposedHashedRekordEntry = exports.toProposedDSSEEntry = void 0;\nconst sigstore_1 = require(\"../types/sigstore\");\nconst util_1 = require(\"../util\");\nconst DEFAULT_DSSE_API_VERSION = '0.0.1';\nconst DEFAULT_HASHEDREKORD_API_VERSION = '0.0.1';\nconst DEFAULT_INTOTO_API_VERSION = '0.0.2';\n// Returns a properly formatted Rekor \"dsse\" entry for the given DSSE\n// envelope and signature\nfunction toProposedDSSEEntry(envelope, signature, apiVersion = DEFAULT_DSSE_API_VERSION) {\n  switch (apiVersion) {\n    case '0.0.1':\n      return toProposedDSSEV001Entry(envelope, signature);\n    default:\n      throw new Error(`Unsupported dsse kind API version: ${apiVersion}`);\n  }\n}\nexports.toProposedDSSEEntry = toProposedDSSEEntry;\n// Returns a properly formatted Rekor \"hashedrekord\" entry for the given digest\n// and signature\nfunction toProposedHashedRekordEntry(digest, signature) {\n  const hexDigest = digest.toString('hex');\n  const b64Signature = signature.signature.toString('base64');\n  const b64Key = util_1.encoding.base64Encode(toPublicKey(signature));\n  return {\n    apiVersion: DEFAULT_HASHEDREKORD_API_VERSION,\n    kind: 'hashedrekord',\n    spec: {\n      data: {\n        hash: {\n          algorithm: 'sha256',\n          value: hexDigest\n        }\n      },\n      signature: {\n        content: b64Signature,\n        publicKey: {\n          content: b64Key\n        }\n      }\n    }\n  };\n}\nexports.toProposedHashedRekordEntry = toProposedHashedRekordEntry;\n// Returns a properly formatted Rekor \"intoto\" entry for the given DSSE\n// envelope and signature\nfunction toProposedIntotoEntry(envelope, signature, apiVersion = DEFAULT_INTOTO_API_VERSION) {\n  switch (apiVersion) {\n    case '0.0.2':\n      return toProposedIntotoV002Entry(envelope, signature);\n    default:\n      throw new Error(`Unsupported intoto kind API version: ${apiVersion}`);\n  }\n}\nexports.toProposedIntotoEntry = toProposedIntotoEntry;\nfunction toProposedDSSEV001Entry(envelope, signature) {\n  return {\n    apiVersion: '0.0.1',\n    kind: 'dsse',\n    spec: {\n      proposedContent: {\n        envelope: JSON.stringify(sigstore_1.Envelope.toJSON(envelope)),\n        verifiers: [util_1.encoding.base64Encode(toPublicKey(signature))]\n      }\n    }\n  };\n}\nfunction toProposedIntotoV002Entry(envelope, signature) {\n  // Calculate the value for the payloadHash field in the Rekor entry\n  const payloadHash = util_1.crypto.hash(envelope.payload).toString('hex');\n  // Calculate the value for the hash field in the Rekor entry\n  const envelopeHash = calculateDSSEHash(envelope, signature);\n  // Collect values for re-creating the DSSE envelope.\n  // Double-encode payload and signature cause that's what Rekor expects\n  const payload = util_1.encoding.base64Encode(envelope.payload.toString('base64'));\n  const sig = util_1.encoding.base64Encode(envelope.signatures[0].sig.toString('base64'));\n  const keyid = envelope.signatures[0].keyid;\n  const publicKey = util_1.encoding.base64Encode(toPublicKey(signature));\n  // Create the envelope portion of the entry. Note the inclusion of the\n  // publicKey in the signature struct is not a standard part of a DSSE\n  // envelope, but is required by Rekor.\n  const dsseEnv = {\n    payloadType: envelope.payloadType,\n    payload: payload,\n    signatures: [{\n      sig,\n      publicKey\n    }]\n  };\n  // If the keyid is an empty string, Rekor seems to remove it altogether. We\n  // need to do the same here so that we can properly recreate the entry for\n  // verification.\n  if (keyid.length > 0) {\n    dsseEnv.signatures[0].keyid = keyid;\n  }\n  return {\n    apiVersion: '0.0.2',\n    kind: 'intoto',\n    spec: {\n      content: {\n        envelope: dsseEnv,\n        hash: {\n          algorithm: 'sha256',\n          value: envelopeHash\n        },\n        payloadHash: {\n          algorithm: 'sha256',\n          value: payloadHash\n        }\n      }\n    }\n  };\n}\n// Calculates the hash of a DSSE envelope for inclusion in a Rekor entry.\n// There is no standard way to do this, so the scheme we're using as as\n// follows:\n//  * payload is base64 encoded\n//  * signature is base64 encoded (only the first signature is used)\n//  * keyid is included ONLY if it is NOT an empty string\n//  * The resulting JSON is canonicalized and hashed to a hex string\nfunction calculateDSSEHash(envelope, signature) {\n  const dsseEnv = {\n    payloadType: envelope.payloadType,\n    payload: envelope.payload.toString('base64'),\n    signatures: [{\n      sig: envelope.signatures[0].sig.toString('base64'),\n      publicKey: toPublicKey(signature)\n    }]\n  };\n  // If the keyid is an empty string, Rekor seems to remove it altogether.\n  if (envelope.signatures[0].keyid.length > 0) {\n    dsseEnv.signatures[0].keyid = envelope.signatures[0].keyid;\n  }\n  return util_1.crypto.hash(util_1.json.canonicalize(dsseEnv)).toString('hex');\n}\nfunction toPublicKey(signature) {\n  return signature.certificates ? signature.certificates[0] : signature.key.value;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","toProposedIntotoEntry","toProposedHashedRekordEntry","toProposedDSSEEntry","sigstore_1","require","util_1","DEFAULT_DSSE_API_VERSION","DEFAULT_HASHEDREKORD_API_VERSION","DEFAULT_INTOTO_API_VERSION","envelope","signature","apiVersion","toProposedDSSEV001Entry","Error","digest","hexDigest","toString","b64Signature","b64Key","encoding","base64Encode","toPublicKey","kind","spec","data","hash","algorithm","content","publicKey","toProposedIntotoV002Entry","proposedContent","JSON","stringify","Envelope","toJSON","verifiers","payloadHash","crypto","payload","envelopeHash","calculateDSSEHash","sig","signatures","keyid","dsseEnv","payloadType","length","json","canonicalize","certificates","key"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/tlog/format.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toProposedIntotoEntry = exports.toProposedHashedRekordEntry = exports.toProposedDSSEEntry = void 0;\nconst sigstore_1 = require(\"../types/sigstore\");\nconst util_1 = require(\"../util\");\nconst DEFAULT_DSSE_API_VERSION = '0.0.1';\nconst DEFAULT_HASHEDREKORD_API_VERSION = '0.0.1';\nconst DEFAULT_INTOTO_API_VERSION = '0.0.2';\n// Returns a properly formatted Rekor \"dsse\" entry for the given DSSE\n// envelope and signature\nfunction toProposedDSSEEntry(envelope, signature, apiVersion = DEFAULT_DSSE_API_VERSION) {\n    switch (apiVersion) {\n        case '0.0.1':\n            return toProposedDSSEV001Entry(envelope, signature);\n        default:\n            throw new Error(`Unsupported dsse kind API version: ${apiVersion}`);\n    }\n}\nexports.toProposedDSSEEntry = toProposedDSSEEntry;\n// Returns a properly formatted Rekor \"hashedrekord\" entry for the given digest\n// and signature\nfunction toProposedHashedRekordEntry(digest, signature) {\n    const hexDigest = digest.toString('hex');\n    const b64Signature = signature.signature.toString('base64');\n    const b64Key = util_1.encoding.base64Encode(toPublicKey(signature));\n    return {\n        apiVersion: DEFAULT_HASHEDREKORD_API_VERSION,\n        kind: 'hashedrekord',\n        spec: {\n            data: {\n                hash: {\n                    algorithm: 'sha256',\n                    value: hexDigest,\n                },\n            },\n            signature: {\n                content: b64Signature,\n                publicKey: {\n                    content: b64Key,\n                },\n            },\n        },\n    };\n}\nexports.toProposedHashedRekordEntry = toProposedHashedRekordEntry;\n// Returns a properly formatted Rekor \"intoto\" entry for the given DSSE\n// envelope and signature\nfunction toProposedIntotoEntry(envelope, signature, apiVersion = DEFAULT_INTOTO_API_VERSION) {\n    switch (apiVersion) {\n        case '0.0.2':\n            return toProposedIntotoV002Entry(envelope, signature);\n        default:\n            throw new Error(`Unsupported intoto kind API version: ${apiVersion}`);\n    }\n}\nexports.toProposedIntotoEntry = toProposedIntotoEntry;\nfunction toProposedDSSEV001Entry(envelope, signature) {\n    return {\n        apiVersion: '0.0.1',\n        kind: 'dsse',\n        spec: {\n            proposedContent: {\n                envelope: JSON.stringify(sigstore_1.Envelope.toJSON(envelope)),\n                verifiers: [util_1.encoding.base64Encode(toPublicKey(signature))],\n            },\n        },\n    };\n}\nfunction toProposedIntotoV002Entry(envelope, signature) {\n    // Calculate the value for the payloadHash field in the Rekor entry\n    const payloadHash = util_1.crypto.hash(envelope.payload).toString('hex');\n    // Calculate the value for the hash field in the Rekor entry\n    const envelopeHash = calculateDSSEHash(envelope, signature);\n    // Collect values for re-creating the DSSE envelope.\n    // Double-encode payload and signature cause that's what Rekor expects\n    const payload = util_1.encoding.base64Encode(envelope.payload.toString('base64'));\n    const sig = util_1.encoding.base64Encode(envelope.signatures[0].sig.toString('base64'));\n    const keyid = envelope.signatures[0].keyid;\n    const publicKey = util_1.encoding.base64Encode(toPublicKey(signature));\n    // Create the envelope portion of the entry. Note the inclusion of the\n    // publicKey in the signature struct is not a standard part of a DSSE\n    // envelope, but is required by Rekor.\n    const dsseEnv = {\n        payloadType: envelope.payloadType,\n        payload: payload,\n        signatures: [{ sig, publicKey }],\n    };\n    // If the keyid is an empty string, Rekor seems to remove it altogether. We\n    // need to do the same here so that we can properly recreate the entry for\n    // verification.\n    if (keyid.length > 0) {\n        dsseEnv.signatures[0].keyid = keyid;\n    }\n    return {\n        apiVersion: '0.0.2',\n        kind: 'intoto',\n        spec: {\n            content: {\n                envelope: dsseEnv,\n                hash: { algorithm: 'sha256', value: envelopeHash },\n                payloadHash: { algorithm: 'sha256', value: payloadHash },\n            },\n        },\n    };\n}\n// Calculates the hash of a DSSE envelope for inclusion in a Rekor entry.\n// There is no standard way to do this, so the scheme we're using as as\n// follows:\n//  * payload is base64 encoded\n//  * signature is base64 encoded (only the first signature is used)\n//  * keyid is included ONLY if it is NOT an empty string\n//  * The resulting JSON is canonicalized and hashed to a hex string\nfunction calculateDSSEHash(envelope, signature) {\n    const dsseEnv = {\n        payloadType: envelope.payloadType,\n        payload: envelope.payload.toString('base64'),\n        signatures: [\n            {\n                sig: envelope.signatures[0].sig.toString('base64'),\n                publicKey: toPublicKey(signature),\n            },\n        ],\n    };\n    // If the keyid is an empty string, Rekor seems to remove it altogether.\n    if (envelope.signatures[0].keyid.length > 0) {\n        dsseEnv.signatures[0].keyid = envelope.signatures[0].keyid;\n    }\n    return util_1.crypto.hash(util_1.json.canonicalize(dsseEnv)).toString('hex');\n}\nfunction toPublicKey(signature) {\n    return signature.certificates\n        ? signature.certificates[0]\n        : signature.key.value;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}