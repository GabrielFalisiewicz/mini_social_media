{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SuccinctRoles = exports.DelegatedRole = exports.Role = exports.TOP_LEVEL_ROLE_NAMES = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst minimatch_1 = require(\"minimatch\");\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nexports.TOP_LEVEL_ROLE_NAMES = ['root', 'targets', 'snapshot', 'timestamp'];\n/**\n * Container that defines which keys are required to sign roles metadata.\n *\n * Role defines how many keys are required to successfully sign the roles\n * metadata, and which keys are accepted.\n */\nclass Role {\n  constructor(options) {\n    const {\n      keyIDs,\n      threshold,\n      unrecognizedFields\n    } = options;\n    if (hasDuplicates(keyIDs)) {\n      throw new error_1.ValueError('duplicate key IDs found');\n    }\n    if (threshold < 1) {\n      throw new error_1.ValueError('threshold must be at least 1');\n    }\n    this.keyIDs = keyIDs;\n    this.threshold = threshold;\n    this.unrecognizedFields = unrecognizedFields || {};\n  }\n  equals(other) {\n    if (!(other instanceof Role)) {\n      return false;\n    }\n    return this.threshold === other.threshold && util_1.default.isDeepStrictEqual(this.keyIDs, other.keyIDs) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);\n  }\n  toJSON() {\n    return {\n      keyids: this.keyIDs,\n      threshold: this.threshold,\n      ...this.unrecognizedFields\n    };\n  }\n  static fromJSON(data) {\n    const {\n      keyids,\n      threshold,\n      ...rest\n    } = data;\n    if (!utils_1.guard.isStringArray(keyids)) {\n      throw new TypeError('keyids must be an array');\n    }\n    if (typeof threshold !== 'number') {\n      throw new TypeError('threshold must be a number');\n    }\n    return new Role({\n      keyIDs: keyids,\n      threshold,\n      unrecognizedFields: rest\n    });\n  }\n}\nexports.Role = Role;\nfunction hasDuplicates(array) {\n  return new Set(array).size !== array.length;\n}\n/**\n * A container with information about a delegated role.\n *\n * A delegation can happen in two ways:\n *   - ``paths`` is set: delegates targets matching any path pattern in ``paths``\n *   - ``pathHashPrefixes`` is set: delegates targets whose target path hash\n *      starts with any of the prefixes in ``pathHashPrefixes``\n *\n *   ``paths`` and ``pathHashPrefixes`` are mutually exclusive: both cannot be\n *   set, at least one of them must be set.\n */\nclass DelegatedRole extends Role {\n  constructor(opts) {\n    super(opts);\n    const {\n      name,\n      terminating,\n      paths,\n      pathHashPrefixes\n    } = opts;\n    this.name = name;\n    this.terminating = terminating;\n    if (opts.paths && opts.pathHashPrefixes) {\n      throw new error_1.ValueError('paths and pathHashPrefixes are mutually exclusive');\n    }\n    this.paths = paths;\n    this.pathHashPrefixes = pathHashPrefixes;\n  }\n  equals(other) {\n    if (!(other instanceof DelegatedRole)) {\n      return false;\n    }\n    return super.equals(other) && this.name === other.name && this.terminating === other.terminating && util_1.default.isDeepStrictEqual(this.paths, other.paths) && util_1.default.isDeepStrictEqual(this.pathHashPrefixes, other.pathHashPrefixes);\n  }\n  isDelegatedPath(targetFilepath) {\n    if (this.paths) {\n      return this.paths.some(pathPattern => isTargetInPathPattern(targetFilepath, pathPattern));\n    }\n    if (this.pathHashPrefixes) {\n      const hasher = crypto_1.default.createHash('sha256');\n      const pathHash = hasher.update(targetFilepath).digest('hex');\n      return this.pathHashPrefixes.some(pathHashPrefix => pathHash.startsWith(pathHashPrefix));\n    }\n    return false;\n  }\n  toJSON() {\n    const json = {\n      ...super.toJSON(),\n      name: this.name,\n      terminating: this.terminating\n    };\n    if (this.paths) {\n      json.paths = this.paths;\n    }\n    if (this.pathHashPrefixes) {\n      json.path_hash_prefixes = this.pathHashPrefixes;\n    }\n    return json;\n  }\n  static fromJSON(data) {\n    const {\n      keyids,\n      threshold,\n      name,\n      terminating,\n      paths,\n      path_hash_prefixes,\n      ...rest\n    } = data;\n    if (!utils_1.guard.isStringArray(keyids)) {\n      throw new TypeError('keyids must be an array of strings');\n    }\n    if (typeof threshold !== 'number') {\n      throw new TypeError('threshold must be a number');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('name must be a string');\n    }\n    if (typeof terminating !== 'boolean') {\n      throw new TypeError('terminating must be a boolean');\n    }\n    if (utils_1.guard.isDefined(paths) && !utils_1.guard.isStringArray(paths)) {\n      throw new TypeError('paths must be an array of strings');\n    }\n    if (utils_1.guard.isDefined(path_hash_prefixes) && !utils_1.guard.isStringArray(path_hash_prefixes)) {\n      throw new TypeError('path_hash_prefixes must be an array of strings');\n    }\n    return new DelegatedRole({\n      keyIDs: keyids,\n      threshold,\n      name,\n      terminating,\n      paths,\n      pathHashPrefixes: path_hash_prefixes,\n      unrecognizedFields: rest\n    });\n  }\n}\nexports.DelegatedRole = DelegatedRole;\n// JS version of Ruby's Array#zip\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\nfunction isTargetInPathPattern(target, pattern) {\n  const targetParts = target.split('/');\n  const patternParts = pattern.split('/');\n  if (patternParts.length != targetParts.length) {\n    return false;\n  }\n  return zip(targetParts, patternParts).every(([targetPart, patternPart]) => (0, minimatch_1.minimatch)(targetPart, patternPart));\n}\n/**\n * Succinctly defines a hash bin delegation graph.\n *\n * A ``SuccinctRoles`` object describes a delegation graph that covers all\n * targets, distributing them uniformly over the delegated roles (i.e. bins)\n * in the graph.\n *\n * The total number of bins is 2 to the power of the passed ``bit_length``.\n *\n * Bin names are the concatenation of the passed ``name_prefix`` and a\n * zero-padded hex representation of the bin index separated by a hyphen.\n *\n * The passed ``keyids`` and ``threshold`` is used for each bin, and each bin\n * is 'terminating'.\n *\n * For details: https://github.com/theupdateframework/taps/blob/master/tap15.md\n */\nclass SuccinctRoles extends Role {\n  constructor(opts) {\n    super(opts);\n    const {\n      bitLength,\n      namePrefix\n    } = opts;\n    if (bitLength <= 0 || bitLength > 32) {\n      throw new error_1.ValueError('bitLength must be between 1 and 32');\n    }\n    this.bitLength = bitLength;\n    this.namePrefix = namePrefix;\n    // Calculate the suffix_len value based on the total number of bins in\n    // hex. If bit_length = 10 then number_of_bins = 1024 or bin names will\n    // have a suffix between \"000\" and \"3ff\" in hex and suffix_len will be 3\n    // meaning the third bin will have a suffix of \"003\".\n    this.numberOfBins = Math.pow(2, bitLength);\n    // suffix_len is calculated based on \"number_of_bins - 1\" as the name\n    // of the last bin contains the number \"number_of_bins -1\" as a suffix.\n    this.suffixLen = (this.numberOfBins - 1).toString(16).length;\n  }\n  equals(other) {\n    if (!(other instanceof SuccinctRoles)) {\n      return false;\n    }\n    return super.equals(other) && this.bitLength === other.bitLength && this.namePrefix === other.namePrefix;\n  }\n  /***\n   * Calculates the name of the delegated role responsible for 'target_filepath'.\n   *\n   * The target at path ''target_filepath' is assigned to a bin by casting\n   * the left-most 'bit_length' of bits of the file path hash digest to\n   * int, using it as bin index between 0 and '2**bit_length - 1'.\n   *\n   * Args:\n   *  target_filepath: URL path to a target file, relative to a base\n   *  targets URL.\n   */\n  getRoleForTarget(targetFilepath) {\n    const hasher = crypto_1.default.createHash('sha256');\n    const hasherBuffer = hasher.update(targetFilepath).digest();\n    // can't ever need more than 4 bytes (32 bits).\n    const hashBytes = hasherBuffer.subarray(0, 4);\n    // Right shift hash bytes, so that we only have the leftmost\n    // bit_length bits that we care about.\n    const shiftValue = 32 - this.bitLength;\n    const binNumber = hashBytes.readUInt32BE() >>> shiftValue;\n    // Add zero padding if necessary and cast to hex the suffix.\n    const suffix = binNumber.toString(16).padStart(this.suffixLen, '0');\n    return `${this.namePrefix}-${suffix}`;\n  }\n  *getRoles() {\n    for (let i = 0; i < this.numberOfBins; i++) {\n      const suffix = i.toString(16).padStart(this.suffixLen, '0');\n      yield `${this.namePrefix}-${suffix}`;\n    }\n  }\n  /***\n   * Determines whether the given ``role_name`` is in one of\n   * the delegated roles that ``SuccinctRoles`` represents.\n   *\n   * Args:\n   *  role_name: The name of the role to check against.\n   */\n  isDelegatedRole(roleName) {\n    const desiredPrefix = this.namePrefix + '-';\n    if (!roleName.startsWith(desiredPrefix)) {\n      return false;\n    }\n    const suffix = roleName.slice(desiredPrefix.length, roleName.length);\n    if (suffix.length != this.suffixLen) {\n      return false;\n    }\n    // make sure the suffix is a hex string\n    if (!suffix.match(/^[0-9a-fA-F]+$/)) {\n      return false;\n    }\n    const num = parseInt(suffix, 16);\n    return 0 <= num && num < this.numberOfBins;\n  }\n  toJSON() {\n    const json = {\n      ...super.toJSON(),\n      bit_length: this.bitLength,\n      name_prefix: this.namePrefix\n    };\n    return json;\n  }\n  static fromJSON(data) {\n    const {\n      keyids,\n      threshold,\n      bit_length,\n      name_prefix,\n      ...rest\n    } = data;\n    if (!utils_1.guard.isStringArray(keyids)) {\n      throw new TypeError('keyids must be an array of strings');\n    }\n    if (typeof threshold !== 'number') {\n      throw new TypeError('threshold must be a number');\n    }\n    if (typeof bit_length !== 'number') {\n      throw new TypeError('bit_length must be a number');\n    }\n    if (typeof name_prefix !== 'string') {\n      throw new TypeError('name_prefix must be a string');\n    }\n    return new SuccinctRoles({\n      keyIDs: keyids,\n      threshold,\n      bitLength: bit_length,\n      namePrefix: name_prefix,\n      unrecognizedFields: rest\n    });\n  }\n}\nexports.SuccinctRoles = SuccinctRoles;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","SuccinctRoles","DelegatedRole","Role","TOP_LEVEL_ROLE_NAMES","crypto_1","require","minimatch_1","util_1","error_1","utils_1","constructor","options","keyIDs","threshold","unrecognizedFields","hasDuplicates","ValueError","equals","other","default","isDeepStrictEqual","toJSON","keyids","fromJSON","data","rest","guard","isStringArray","TypeError","array","Set","size","length","opts","name","terminating","paths","pathHashPrefixes","isDelegatedPath","targetFilepath","some","pathPattern","isTargetInPathPattern","hasher","createHash","pathHash","update","digest","pathHashPrefix","startsWith","json","path_hash_prefixes","isDefined","zip","a","b","map","k","i","target","pattern","targetParts","split","patternParts","every","targetPart","patternPart","minimatch","bitLength","namePrefix","numberOfBins","Math","pow","suffixLen","toString","getRoleForTarget","hasherBuffer","hashBytes","subarray","shiftValue","binNumber","readUInt32BE","suffix","padStart","getRoles","isDelegatedRole","roleName","desiredPrefix","slice","match","num","parseInt","bit_length","name_prefix"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@tufjs/models/dist/role.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SuccinctRoles = exports.DelegatedRole = exports.Role = exports.TOP_LEVEL_ROLE_NAMES = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst minimatch_1 = require(\"minimatch\");\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nexports.TOP_LEVEL_ROLE_NAMES = [\n    'root',\n    'targets',\n    'snapshot',\n    'timestamp',\n];\n/**\n * Container that defines which keys are required to sign roles metadata.\n *\n * Role defines how many keys are required to successfully sign the roles\n * metadata, and which keys are accepted.\n */\nclass Role {\n    constructor(options) {\n        const { keyIDs, threshold, unrecognizedFields } = options;\n        if (hasDuplicates(keyIDs)) {\n            throw new error_1.ValueError('duplicate key IDs found');\n        }\n        if (threshold < 1) {\n            throw new error_1.ValueError('threshold must be at least 1');\n        }\n        this.keyIDs = keyIDs;\n        this.threshold = threshold;\n        this.unrecognizedFields = unrecognizedFields || {};\n    }\n    equals(other) {\n        if (!(other instanceof Role)) {\n            return false;\n        }\n        return (this.threshold === other.threshold &&\n            util_1.default.isDeepStrictEqual(this.keyIDs, other.keyIDs) &&\n            util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields));\n    }\n    toJSON() {\n        return {\n            keyids: this.keyIDs,\n            threshold: this.threshold,\n            ...this.unrecognizedFields,\n        };\n    }\n    static fromJSON(data) {\n        const { keyids, threshold, ...rest } = data;\n        if (!utils_1.guard.isStringArray(keyids)) {\n            throw new TypeError('keyids must be an array');\n        }\n        if (typeof threshold !== 'number') {\n            throw new TypeError('threshold must be a number');\n        }\n        return new Role({\n            keyIDs: keyids,\n            threshold,\n            unrecognizedFields: rest,\n        });\n    }\n}\nexports.Role = Role;\nfunction hasDuplicates(array) {\n    return new Set(array).size !== array.length;\n}\n/**\n * A container with information about a delegated role.\n *\n * A delegation can happen in two ways:\n *   - ``paths`` is set: delegates targets matching any path pattern in ``paths``\n *   - ``pathHashPrefixes`` is set: delegates targets whose target path hash\n *      starts with any of the prefixes in ``pathHashPrefixes``\n *\n *   ``paths`` and ``pathHashPrefixes`` are mutually exclusive: both cannot be\n *   set, at least one of them must be set.\n */\nclass DelegatedRole extends Role {\n    constructor(opts) {\n        super(opts);\n        const { name, terminating, paths, pathHashPrefixes } = opts;\n        this.name = name;\n        this.terminating = terminating;\n        if (opts.paths && opts.pathHashPrefixes) {\n            throw new error_1.ValueError('paths and pathHashPrefixes are mutually exclusive');\n        }\n        this.paths = paths;\n        this.pathHashPrefixes = pathHashPrefixes;\n    }\n    equals(other) {\n        if (!(other instanceof DelegatedRole)) {\n            return false;\n        }\n        return (super.equals(other) &&\n            this.name === other.name &&\n            this.terminating === other.terminating &&\n            util_1.default.isDeepStrictEqual(this.paths, other.paths) &&\n            util_1.default.isDeepStrictEqual(this.pathHashPrefixes, other.pathHashPrefixes));\n    }\n    isDelegatedPath(targetFilepath) {\n        if (this.paths) {\n            return this.paths.some((pathPattern) => isTargetInPathPattern(targetFilepath, pathPattern));\n        }\n        if (this.pathHashPrefixes) {\n            const hasher = crypto_1.default.createHash('sha256');\n            const pathHash = hasher.update(targetFilepath).digest('hex');\n            return this.pathHashPrefixes.some((pathHashPrefix) => pathHash.startsWith(pathHashPrefix));\n        }\n        return false;\n    }\n    toJSON() {\n        const json = {\n            ...super.toJSON(),\n            name: this.name,\n            terminating: this.terminating,\n        };\n        if (this.paths) {\n            json.paths = this.paths;\n        }\n        if (this.pathHashPrefixes) {\n            json.path_hash_prefixes = this.pathHashPrefixes;\n        }\n        return json;\n    }\n    static fromJSON(data) {\n        const { keyids, threshold, name, terminating, paths, path_hash_prefixes, ...rest } = data;\n        if (!utils_1.guard.isStringArray(keyids)) {\n            throw new TypeError('keyids must be an array of strings');\n        }\n        if (typeof threshold !== 'number') {\n            throw new TypeError('threshold must be a number');\n        }\n        if (typeof name !== 'string') {\n            throw new TypeError('name must be a string');\n        }\n        if (typeof terminating !== 'boolean') {\n            throw new TypeError('terminating must be a boolean');\n        }\n        if (utils_1.guard.isDefined(paths) && !utils_1.guard.isStringArray(paths)) {\n            throw new TypeError('paths must be an array of strings');\n        }\n        if (utils_1.guard.isDefined(path_hash_prefixes) &&\n            !utils_1.guard.isStringArray(path_hash_prefixes)) {\n            throw new TypeError('path_hash_prefixes must be an array of strings');\n        }\n        return new DelegatedRole({\n            keyIDs: keyids,\n            threshold,\n            name,\n            terminating,\n            paths,\n            pathHashPrefixes: path_hash_prefixes,\n            unrecognizedFields: rest,\n        });\n    }\n}\nexports.DelegatedRole = DelegatedRole;\n// JS version of Ruby's Array#zip\nconst zip = (a, b) => a.map((k, i) => [k, b[i]]);\nfunction isTargetInPathPattern(target, pattern) {\n    const targetParts = target.split('/');\n    const patternParts = pattern.split('/');\n    if (patternParts.length != targetParts.length) {\n        return false;\n    }\n    return zip(targetParts, patternParts).every(([targetPart, patternPart]) => (0, minimatch_1.minimatch)(targetPart, patternPart));\n}\n/**\n * Succinctly defines a hash bin delegation graph.\n *\n * A ``SuccinctRoles`` object describes a delegation graph that covers all\n * targets, distributing them uniformly over the delegated roles (i.e. bins)\n * in the graph.\n *\n * The total number of bins is 2 to the power of the passed ``bit_length``.\n *\n * Bin names are the concatenation of the passed ``name_prefix`` and a\n * zero-padded hex representation of the bin index separated by a hyphen.\n *\n * The passed ``keyids`` and ``threshold`` is used for each bin, and each bin\n * is 'terminating'.\n *\n * For details: https://github.com/theupdateframework/taps/blob/master/tap15.md\n */\nclass SuccinctRoles extends Role {\n    constructor(opts) {\n        super(opts);\n        const { bitLength, namePrefix } = opts;\n        if (bitLength <= 0 || bitLength > 32) {\n            throw new error_1.ValueError('bitLength must be between 1 and 32');\n        }\n        this.bitLength = bitLength;\n        this.namePrefix = namePrefix;\n        // Calculate the suffix_len value based on the total number of bins in\n        // hex. If bit_length = 10 then number_of_bins = 1024 or bin names will\n        // have a suffix between \"000\" and \"3ff\" in hex and suffix_len will be 3\n        // meaning the third bin will have a suffix of \"003\".\n        this.numberOfBins = Math.pow(2, bitLength);\n        // suffix_len is calculated based on \"number_of_bins - 1\" as the name\n        // of the last bin contains the number \"number_of_bins -1\" as a suffix.\n        this.suffixLen = (this.numberOfBins - 1).toString(16).length;\n    }\n    equals(other) {\n        if (!(other instanceof SuccinctRoles)) {\n            return false;\n        }\n        return (super.equals(other) &&\n            this.bitLength === other.bitLength &&\n            this.namePrefix === other.namePrefix);\n    }\n    /***\n     * Calculates the name of the delegated role responsible for 'target_filepath'.\n     *\n     * The target at path ''target_filepath' is assigned to a bin by casting\n     * the left-most 'bit_length' of bits of the file path hash digest to\n     * int, using it as bin index between 0 and '2**bit_length - 1'.\n     *\n     * Args:\n     *  target_filepath: URL path to a target file, relative to a base\n     *  targets URL.\n     */\n    getRoleForTarget(targetFilepath) {\n        const hasher = crypto_1.default.createHash('sha256');\n        const hasherBuffer = hasher.update(targetFilepath).digest();\n        // can't ever need more than 4 bytes (32 bits).\n        const hashBytes = hasherBuffer.subarray(0, 4);\n        // Right shift hash bytes, so that we only have the leftmost\n        // bit_length bits that we care about.\n        const shiftValue = 32 - this.bitLength;\n        const binNumber = hashBytes.readUInt32BE() >>> shiftValue;\n        // Add zero padding if necessary and cast to hex the suffix.\n        const suffix = binNumber.toString(16).padStart(this.suffixLen, '0');\n        return `${this.namePrefix}-${suffix}`;\n    }\n    *getRoles() {\n        for (let i = 0; i < this.numberOfBins; i++) {\n            const suffix = i.toString(16).padStart(this.suffixLen, '0');\n            yield `${this.namePrefix}-${suffix}`;\n        }\n    }\n    /***\n     * Determines whether the given ``role_name`` is in one of\n     * the delegated roles that ``SuccinctRoles`` represents.\n     *\n     * Args:\n     *  role_name: The name of the role to check against.\n     */\n    isDelegatedRole(roleName) {\n        const desiredPrefix = this.namePrefix + '-';\n        if (!roleName.startsWith(desiredPrefix)) {\n            return false;\n        }\n        const suffix = roleName.slice(desiredPrefix.length, roleName.length);\n        if (suffix.length != this.suffixLen) {\n            return false;\n        }\n        // make sure the suffix is a hex string\n        if (!suffix.match(/^[0-9a-fA-F]+$/)) {\n            return false;\n        }\n        const num = parseInt(suffix, 16);\n        return 0 <= num && num < this.numberOfBins;\n    }\n    toJSON() {\n        const json = {\n            ...super.toJSON(),\n            bit_length: this.bitLength,\n            name_prefix: this.namePrefix,\n        };\n        return json;\n    }\n    static fromJSON(data) {\n        const { keyids, threshold, bit_length, name_prefix, ...rest } = data;\n        if (!utils_1.guard.isStringArray(keyids)) {\n            throw new TypeError('keyids must be an array of strings');\n        }\n        if (typeof threshold !== 'number') {\n            throw new TypeError('threshold must be a number');\n        }\n        if (typeof bit_length !== 'number') {\n            throw new TypeError('bit_length must be a number');\n        }\n        if (typeof name_prefix !== 'string') {\n            throw new TypeError('name_prefix must be a string');\n        }\n        return new SuccinctRoles({\n            keyIDs: keyids,\n            threshold,\n            bitLength: bit_length,\n            namePrefix: name_prefix,\n            unrecognizedFields: rest,\n        });\n    }\n}\nexports.SuccinctRoles = SuccinctRoles;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}