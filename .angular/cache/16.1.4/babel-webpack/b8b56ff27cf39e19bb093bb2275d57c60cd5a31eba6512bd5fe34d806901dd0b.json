{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  HttpErrorAuthOTP\n} = require('./errors.js');\nconst checkResponse = require('./check-response.js');\nconst getAuth = require('./auth.js');\nconst fetch = require('make-fetch-happen');\nconst JSONStream = require('minipass-json-stream');\nconst npa = require('npm-package-arg');\nconst qs = require('querystring');\nconst url = require('url');\nconst zlib = require('minizlib');\nconst {\n  Minipass\n} = require('minipass');\nconst defaultOpts = require('./default-opts.js');\n\n// WhatWG URL throws if it's not fully resolved\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u);\n  } catch (_) {\n    return false;\n  }\n};\nmodule.exports = regFetch;\nfunction regFetch(uri, /* istanbul ignore next */opts_ = {}) {\n  const opts = {\n    ...defaultOpts,\n    ...opts_\n  };\n\n  // if we did not get a fully qualified URI, then we look at the registry\n  // config or relevant scope to resolve it.\n  const uriValid = urlIsValid(uri);\n  let registry = opts.registry || defaultOpts.registry;\n  if (!uriValid) {\n    registry = opts.registry = opts.spec && pickRegistry(opts.spec, opts) || opts.registry || registry;\n    uri = `${registry.trim().replace(/\\/?$/g, '')}/${uri.trim().replace(/^\\//, '')}`;\n    // asserts that this is now valid\n    new url.URL(uri);\n  }\n  const method = opts.method || 'GET';\n\n  // through that takes into account the scope, the prefix of `uri`, etc\n  const startTime = Date.now();\n  const auth = getAuth(uri, opts);\n  const headers = getHeaders(uri, auth, opts);\n  let body = opts.body;\n  const bodyIsStream = Minipass.isStream(body);\n  const bodyIsPromise = body && typeof body === 'object' && typeof body.then === 'function';\n  if (body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)) {\n    headers['content-type'] = headers['content-type'] || 'application/json';\n    body = JSON.stringify(body);\n  } else if (body && !headers['content-type']) {\n    headers['content-type'] = 'application/octet-stream';\n  }\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip';\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip();\n      body.on('error', /* istanbul ignore next: unlikely and hard to test */\n      err => gz.emit('error', err));\n      body = body.pipe(gz);\n    } else if (!bodyIsPromise) {\n      body = new zlib.Gzip().end(body).concat();\n    }\n  }\n  const parsed = new url.URL(uri);\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query) : opts.query;\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined) {\n        parsed.searchParams.set(key, q[key]);\n      }\n    });\n    uri = url.format(parsed);\n  }\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false;\n    opts.preferOffline = false;\n    opts.preferOnline = true;\n  }\n  const doFetch = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (fetchBody) {\n      const p = fetch(uri, {\n        agent: opts.agent,\n        algorithms: opts.algorithms,\n        body: fetchBody,\n        cache: getCacheMode(opts),\n        cachePath: opts.cache,\n        ca: opts.ca,\n        cert: auth.cert || opts.cert,\n        headers,\n        integrity: opts.integrity,\n        key: auth.key || opts.key,\n        localAddress: opts.localAddress,\n        maxSockets: opts.maxSockets,\n        memoize: opts.memoize,\n        method: method,\n        noProxy: opts.noProxy,\n        proxy: opts.httpsProxy || opts.proxy,\n        retry: opts.retry ? opts.retry : {\n          retries: opts.fetchRetries,\n          factor: opts.fetchRetryFactor,\n          minTimeout: opts.fetchRetryMintimeout,\n          maxTimeout: opts.fetchRetryMaxtimeout\n        },\n        strictSSL: opts.strictSSL,\n        timeout: opts.timeout || 30 * 1000\n      }).then(res => checkResponse({\n        method,\n        uri,\n        res,\n        registry,\n        startTime,\n        auth,\n        opts\n      }));\n      if (typeof opts.otpPrompt === 'function') {\n        return p.catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (er) {\n            if (er instanceof HttpErrorAuthOTP) {\n              let otp;\n              // if otp fails to complete, we fail with that failure\n              try {\n                otp = yield opts.otpPrompt();\n              } catch (_) {\n                // ignore this error\n              }\n              // if no otp provided, or otpPrompt errored, throw the original HTTP error\n              if (!otp) {\n                throw er;\n              }\n              return regFetch(uri, {\n                ...opts,\n                otp\n              });\n            }\n            throw er;\n          });\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      } else {\n        return p;\n      }\n    });\n    return function doFetch(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  return Promise.resolve(body).then(doFetch);\n}\nmodule.exports.json = fetchJSON;\nfunction fetchJSON(uri, opts) {\n  return regFetch(uri, opts).then(res => res.json());\n}\nmodule.exports.json.stream = fetchJSONStream;\nfunction fetchJSONStream(uri, jsonPath, /* istanbul ignore next */opts_ = {}) {\n  const opts = {\n    ...defaultOpts,\n    ...opts_\n  };\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON);\n  regFetch(uri, opts).then(res => res.body.on('error', /* istanbul ignore next: unlikely and difficult to test */\n  er => parser.emit('error', er)).pipe(parser)).catch(er => parser.emit('error', er));\n  return parser;\n}\nmodule.exports.pickRegistry = pickRegistry;\nfunction pickRegistry(spec, opts = {}) {\n  spec = npa(spec);\n  let registry = spec.scope && opts[spec.scope.replace(/^@?/, '@') + ':registry'];\n  if (!registry && opts.scope) {\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry'];\n  }\n  if (!registry) {\n    registry = opts.registry || defaultOpts.registry;\n  }\n  return registry;\n}\nfunction getCacheMode(opts) {\n  return opts.offline ? 'only-if-cached' : opts.preferOffline ? 'force-cache' : opts.preferOnline ? 'no-cache' : 'default';\n}\nfunction getHeaders(uri, auth, opts) {\n  const headers = Object.assign({\n    'user-agent': opts.userAgent\n  }, opts.headers || {});\n  if (opts.authType) {\n    headers['npm-auth-type'] = opts.authType;\n  }\n  if (opts.scope) {\n    headers['npm-scope'] = opts.scope;\n  }\n  if (opts.npmSession) {\n    headers['npm-session'] = opts.npmSession;\n  }\n  if (opts.npmCommand) {\n    headers['npm-command'] = opts.npmCommand;\n  }\n\n  // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n  if (auth.token) {\n    headers.authorization = `Bearer ${auth.token}`;\n  } else if (auth.auth) {\n    headers.authorization = `Basic ${auth.auth}`;\n  }\n  if (opts.otp) {\n    headers['npm-otp'] = opts.otp;\n  }\n  return headers;\n}\nmodule.exports.cleanUrl = require('./clean-url.js');","map":{"version":3,"names":["_asyncToGenerator","require","default","HttpErrorAuthOTP","checkResponse","getAuth","fetch","JSONStream","npa","qs","url","zlib","Minipass","defaultOpts","urlIsValid","u","URL","_","module","exports","regFetch","uri","opts_","opts","uriValid","registry","spec","pickRegistry","trim","replace","method","startTime","Date","now","auth","headers","getHeaders","body","bodyIsStream","isStream","bodyIsPromise","then","Buffer","isBuffer","JSON","stringify","gzip","gz","Gzip","on","err","emit","pipe","end","concat","parsed","query","q","parse","Object","keys","forEach","key","undefined","searchParams","set","format","get","offline","preferOffline","preferOnline","doFetch","_ref","fetchBody","p","agent","algorithms","cache","getCacheMode","cachePath","ca","cert","integrity","localAddress","maxSockets","memoize","noProxy","proxy","httpsProxy","retry","retries","fetchRetries","factor","fetchRetryFactor","minTimeout","fetchRetryMintimeout","maxTimeout","fetchRetryMaxtimeout","strictSSL","timeout","res","otpPrompt","catch","_ref2","er","otp","_x2","apply","arguments","_x","Promise","resolve","json","fetchJSON","stream","fetchJSONStream","jsonPath","parser","mapJSON","scope","assign","userAgent","authType","npmSession","npmCommand","token","authorization","cleanUrl"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/npm-registry-fetch/lib/index.js"],"sourcesContent":["'use strict'\n\nconst { HttpErrorAuthOTP } = require('./errors.js')\nconst checkResponse = require('./check-response.js')\nconst getAuth = require('./auth.js')\nconst fetch = require('make-fetch-happen')\nconst JSONStream = require('minipass-json-stream')\nconst npa = require('npm-package-arg')\nconst qs = require('querystring')\nconst url = require('url')\nconst zlib = require('minizlib')\nconst { Minipass } = require('minipass')\n\nconst defaultOpts = require('./default-opts.js')\n\n// WhatWG URL throws if it's not fully resolved\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u)\n  } catch (_) {\n    return false\n  }\n}\n\nmodule.exports = regFetch\nfunction regFetch (uri, /* istanbul ignore next */ opts_ = {}) {\n  const opts = {\n    ...defaultOpts,\n    ...opts_,\n  }\n\n  // if we did not get a fully qualified URI, then we look at the registry\n  // config or relevant scope to resolve it.\n  const uriValid = urlIsValid(uri)\n  let registry = opts.registry || defaultOpts.registry\n  if (!uriValid) {\n    registry = opts.registry = (\n      (opts.spec && pickRegistry(opts.spec, opts)) ||\n      opts.registry ||\n      registry\n    )\n    uri = `${\n      registry.trim().replace(/\\/?$/g, '')\n    }/${\n      uri.trim().replace(/^\\//, '')\n    }`\n    // asserts that this is now valid\n    new url.URL(uri)\n  }\n\n  const method = opts.method || 'GET'\n\n  // through that takes into account the scope, the prefix of `uri`, etc\n  const startTime = Date.now()\n  const auth = getAuth(uri, opts)\n  const headers = getHeaders(uri, auth, opts)\n  let body = opts.body\n  const bodyIsStream = Minipass.isStream(body)\n  const bodyIsPromise = body &&\n    typeof body === 'object' &&\n    typeof body.then === 'function'\n\n  if (\n    body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)\n  ) {\n    headers['content-type'] = headers['content-type'] || 'application/json'\n    body = JSON.stringify(body)\n  } else if (body && !headers['content-type']) {\n    headers['content-type'] = 'application/octet-stream'\n  }\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip'\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip()\n      body.on('error', /* istanbul ignore next: unlikely and hard to test */\n        err => gz.emit('error', err))\n      body = body.pipe(gz)\n    } else if (!bodyIsPromise) {\n      body = new zlib.Gzip().end(body).concat()\n    }\n  }\n\n  const parsed = new url.URL(uri)\n\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query)\n      : opts.query\n\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined) {\n        parsed.searchParams.set(key, q[key])\n      }\n    })\n    uri = url.format(parsed)\n  }\n\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false\n    opts.preferOffline = false\n    opts.preferOnline = true\n  }\n\n  const doFetch = async fetchBody => {\n    const p = fetch(uri, {\n      agent: opts.agent,\n      algorithms: opts.algorithms,\n      body: fetchBody,\n      cache: getCacheMode(opts),\n      cachePath: opts.cache,\n      ca: opts.ca,\n      cert: auth.cert || opts.cert,\n      headers,\n      integrity: opts.integrity,\n      key: auth.key || opts.key,\n      localAddress: opts.localAddress,\n      maxSockets: opts.maxSockets,\n      memoize: opts.memoize,\n      method: method,\n      noProxy: opts.noProxy,\n      proxy: opts.httpsProxy || opts.proxy,\n      retry: opts.retry ? opts.retry : {\n        retries: opts.fetchRetries,\n        factor: opts.fetchRetryFactor,\n        minTimeout: opts.fetchRetryMintimeout,\n        maxTimeout: opts.fetchRetryMaxtimeout,\n      },\n      strictSSL: opts.strictSSL,\n      timeout: opts.timeout || 30 * 1000,\n    }).then(res => checkResponse({\n      method,\n      uri,\n      res,\n      registry,\n      startTime,\n      auth,\n      opts,\n    }))\n\n    if (typeof opts.otpPrompt === 'function') {\n      return p.catch(async er => {\n        if (er instanceof HttpErrorAuthOTP) {\n          let otp\n          // if otp fails to complete, we fail with that failure\n          try {\n            otp = await opts.otpPrompt()\n          } catch (_) {\n            // ignore this error\n          }\n          // if no otp provided, or otpPrompt errored, throw the original HTTP error\n          if (!otp) {\n            throw er\n          }\n          return regFetch(uri, { ...opts, otp })\n        }\n        throw er\n      })\n    } else {\n      return p\n    }\n  }\n\n  return Promise.resolve(body).then(doFetch)\n}\n\nmodule.exports.json = fetchJSON\nfunction fetchJSON (uri, opts) {\n  return regFetch(uri, opts).then(res => res.json())\n}\n\nmodule.exports.json.stream = fetchJSONStream\nfunction fetchJSONStream (uri, jsonPath,\n  /* istanbul ignore next */ opts_ = {}) {\n  const opts = { ...defaultOpts, ...opts_ }\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON)\n  regFetch(uri, opts).then(res =>\n    res.body.on('error',\n      /* istanbul ignore next: unlikely and difficult to test */\n      er => parser.emit('error', er)).pipe(parser)\n  ).catch(er => parser.emit('error', er))\n  return parser\n}\n\nmodule.exports.pickRegistry = pickRegistry\nfunction pickRegistry (spec, opts = {}) {\n  spec = npa(spec)\n  let registry = spec.scope &&\n    opts[spec.scope.replace(/^@?/, '@') + ':registry']\n\n  if (!registry && opts.scope) {\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry']\n  }\n\n  if (!registry) {\n    registry = opts.registry || defaultOpts.registry\n  }\n\n  return registry\n}\n\nfunction getCacheMode (opts) {\n  return opts.offline ? 'only-if-cached'\n    : opts.preferOffline ? 'force-cache'\n    : opts.preferOnline ? 'no-cache'\n    : 'default'\n}\n\nfunction getHeaders (uri, auth, opts) {\n  const headers = Object.assign({\n    'user-agent': opts.userAgent,\n  }, opts.headers || {})\n\n  if (opts.authType) {\n    headers['npm-auth-type'] = opts.authType\n  }\n\n  if (opts.scope) {\n    headers['npm-scope'] = opts.scope\n  }\n\n  if (opts.npmSession) {\n    headers['npm-session'] = opts.npmSession\n  }\n\n  if (opts.npmCommand) {\n    headers['npm-command'] = opts.npmCommand\n  }\n\n  // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n  if (auth.token) {\n    headers.authorization = `Bearer ${auth.token}`\n  } else if (auth.auth) {\n    headers.authorization = `Basic ${auth.auth}`\n  }\n\n  if (opts.otp) {\n    headers['npm-otp'] = opts.otp\n  }\n\n  return headers\n}\n\nmodule.exports.cleanUrl = require('./clean-url.js')\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}