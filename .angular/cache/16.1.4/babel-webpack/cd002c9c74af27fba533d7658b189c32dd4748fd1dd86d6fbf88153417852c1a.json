{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TargetFile = exports.MetaFile = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\n// A container with information about a particular metadata file.\n//\n// This class is used for Timestamp and Snapshot metadata.\nclass MetaFile {\n  constructor(opts) {\n    if (opts.version <= 0) {\n      throw new error_1.ValueError('Metafile version must be at least 1');\n    }\n    if (opts.length !== undefined) {\n      validateLength(opts.length);\n    }\n    this.version = opts.version;\n    this.length = opts.length;\n    this.hashes = opts.hashes;\n    this.unrecognizedFields = opts.unrecognizedFields || {};\n  }\n  equals(other) {\n    if (!(other instanceof MetaFile)) {\n      return false;\n    }\n    return this.version === other.version && this.length === other.length && util_1.default.isDeepStrictEqual(this.hashes, other.hashes) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);\n  }\n  verify(data) {\n    // Verifies that the given data matches the expected length.\n    if (this.length !== undefined) {\n      if (data.length !== this.length) {\n        throw new error_1.LengthOrHashMismatchError(`Expected length ${this.length} but got ${data.length}`);\n      }\n    }\n    // Verifies that the given data matches the supplied hashes.\n    if (this.hashes) {\n      Object.entries(this.hashes).forEach(([key, value]) => {\n        let hash;\n        try {\n          hash = crypto_1.default.createHash(key);\n        } catch (e) {\n          throw new error_1.LengthOrHashMismatchError(`Hash algorithm ${key} not supported`);\n        }\n        const observedHash = hash.update(data).digest('hex');\n        if (observedHash !== value) {\n          throw new error_1.LengthOrHashMismatchError(`Expected hash ${value} but got ${observedHash}`);\n        }\n      });\n    }\n  }\n  toJSON() {\n    const json = {\n      version: this.version,\n      ...this.unrecognizedFields\n    };\n    if (this.length !== undefined) {\n      json.length = this.length;\n    }\n    if (this.hashes) {\n      json.hashes = this.hashes;\n    }\n    return json;\n  }\n  static fromJSON(data) {\n    const {\n      version,\n      length,\n      hashes,\n      ...rest\n    } = data;\n    if (typeof version !== 'number') {\n      throw new TypeError('version must be a number');\n    }\n    if (utils_1.guard.isDefined(length) && typeof length !== 'number') {\n      throw new TypeError('length must be a number');\n    }\n    if (utils_1.guard.isDefined(hashes) && !utils_1.guard.isStringRecord(hashes)) {\n      throw new TypeError('hashes must be string keys and values');\n    }\n    return new MetaFile({\n      version,\n      length,\n      hashes,\n      unrecognizedFields: rest\n    });\n  }\n}\nexports.MetaFile = MetaFile;\n// Container for info about a particular target file.\n//\n// This class is used for Target metadata.\nclass TargetFile {\n  constructor(opts) {\n    validateLength(opts.length);\n    this.length = opts.length;\n    this.path = opts.path;\n    this.hashes = opts.hashes;\n    this.unrecognizedFields = opts.unrecognizedFields || {};\n  }\n  get custom() {\n    const custom = this.unrecognizedFields['custom'];\n    if (!custom || Array.isArray(custom) || !(typeof custom === 'object')) {\n      return {};\n    }\n    return custom;\n  }\n  equals(other) {\n    if (!(other instanceof TargetFile)) {\n      return false;\n    }\n    return this.length === other.length && this.path === other.path && util_1.default.isDeepStrictEqual(this.hashes, other.hashes) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);\n  }\n  verify(stream) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let observedLength = 0;\n      // Create a digest for each hash algorithm\n      const digests = Object.keys(_this.hashes).reduce((acc, key) => {\n        try {\n          acc[key] = crypto_1.default.createHash(key);\n        } catch (e) {\n          throw new error_1.LengthOrHashMismatchError(`Hash algorithm ${key} not supported`);\n        }\n        return acc;\n      }, {});\n      // Read stream chunk by chunk\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const chunk = _step.value;\n          {\n            // Keep running tally of stream length\n            observedLength += chunk.length;\n            // Append chunk to each digest\n            Object.values(digests).forEach(digest => {\n              digest.update(chunk);\n            });\n          }\n        }\n        // Verify length matches expected value\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      if (observedLength !== _this.length) {\n        throw new error_1.LengthOrHashMismatchError(`Expected length ${_this.length} but got ${observedLength}`);\n      }\n      // Verify each digest matches expected value\n      Object.entries(digests).forEach(([key, value]) => {\n        const expected = _this.hashes[key];\n        const actual = value.digest('hex');\n        if (actual !== expected) {\n          throw new error_1.LengthOrHashMismatchError(`Expected hash ${expected} but got ${actual}`);\n        }\n      });\n    })();\n  }\n  toJSON() {\n    return {\n      length: this.length,\n      hashes: this.hashes,\n      ...this.unrecognizedFields\n    };\n  }\n  static fromJSON(path, data) {\n    const {\n      length,\n      hashes,\n      ...rest\n    } = data;\n    if (typeof length !== 'number') {\n      throw new TypeError('length must be a number');\n    }\n    if (!utils_1.guard.isStringRecord(hashes)) {\n      throw new TypeError('hashes must have string keys and values');\n    }\n    return new TargetFile({\n      length,\n      path,\n      hashes,\n      unrecognizedFields: rest\n    });\n  }\n}\nexports.TargetFile = TargetFile;\n// Check that supplied length if valid\nfunction validateLength(length) {\n  if (length < 0) {\n    throw new error_1.ValueError('Length must be at least 0');\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","_asyncIterator","__importDefault","mod","__esModule","Object","defineProperty","exports","value","TargetFile","MetaFile","crypto_1","util_1","error_1","utils_1","constructor","opts","version","ValueError","length","undefined","validateLength","hashes","unrecognizedFields","equals","other","isDeepStrictEqual","verify","data","LengthOrHashMismatchError","entries","forEach","key","hash","createHash","e","observedHash","update","digest","toJSON","json","fromJSON","rest","TypeError","guard","isDefined","isStringRecord","path","custom","Array","isArray","stream","_this","observedLength","digests","keys","reduce","acc","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","chunk","values","err","return","expected","actual"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@tufjs/models/dist/file.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TargetFile = exports.MetaFile = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\n// A container with information about a particular metadata file.\n//\n// This class is used for Timestamp and Snapshot metadata.\nclass MetaFile {\n    constructor(opts) {\n        if (opts.version <= 0) {\n            throw new error_1.ValueError('Metafile version must be at least 1');\n        }\n        if (opts.length !== undefined) {\n            validateLength(opts.length);\n        }\n        this.version = opts.version;\n        this.length = opts.length;\n        this.hashes = opts.hashes;\n        this.unrecognizedFields = opts.unrecognizedFields || {};\n    }\n    equals(other) {\n        if (!(other instanceof MetaFile)) {\n            return false;\n        }\n        return (this.version === other.version &&\n            this.length === other.length &&\n            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&\n            util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields));\n    }\n    verify(data) {\n        // Verifies that the given data matches the expected length.\n        if (this.length !== undefined) {\n            if (data.length !== this.length) {\n                throw new error_1.LengthOrHashMismatchError(`Expected length ${this.length} but got ${data.length}`);\n            }\n        }\n        // Verifies that the given data matches the supplied hashes.\n        if (this.hashes) {\n            Object.entries(this.hashes).forEach(([key, value]) => {\n                let hash;\n                try {\n                    hash = crypto_1.default.createHash(key);\n                }\n                catch (e) {\n                    throw new error_1.LengthOrHashMismatchError(`Hash algorithm ${key} not supported`);\n                }\n                const observedHash = hash.update(data).digest('hex');\n                if (observedHash !== value) {\n                    throw new error_1.LengthOrHashMismatchError(`Expected hash ${value} but got ${observedHash}`);\n                }\n            });\n        }\n    }\n    toJSON() {\n        const json = {\n            version: this.version,\n            ...this.unrecognizedFields,\n        };\n        if (this.length !== undefined) {\n            json.length = this.length;\n        }\n        if (this.hashes) {\n            json.hashes = this.hashes;\n        }\n        return json;\n    }\n    static fromJSON(data) {\n        const { version, length, hashes, ...rest } = data;\n        if (typeof version !== 'number') {\n            throw new TypeError('version must be a number');\n        }\n        if (utils_1.guard.isDefined(length) && typeof length !== 'number') {\n            throw new TypeError('length must be a number');\n        }\n        if (utils_1.guard.isDefined(hashes) && !utils_1.guard.isStringRecord(hashes)) {\n            throw new TypeError('hashes must be string keys and values');\n        }\n        return new MetaFile({\n            version,\n            length,\n            hashes,\n            unrecognizedFields: rest,\n        });\n    }\n}\nexports.MetaFile = MetaFile;\n// Container for info about a particular target file.\n//\n// This class is used for Target metadata.\nclass TargetFile {\n    constructor(opts) {\n        validateLength(opts.length);\n        this.length = opts.length;\n        this.path = opts.path;\n        this.hashes = opts.hashes;\n        this.unrecognizedFields = opts.unrecognizedFields || {};\n    }\n    get custom() {\n        const custom = this.unrecognizedFields['custom'];\n        if (!custom || Array.isArray(custom) || !(typeof custom === 'object')) {\n            return {};\n        }\n        return custom;\n    }\n    equals(other) {\n        if (!(other instanceof TargetFile)) {\n            return false;\n        }\n        return (this.length === other.length &&\n            this.path === other.path &&\n            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&\n            util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields));\n    }\n    async verify(stream) {\n        let observedLength = 0;\n        // Create a digest for each hash algorithm\n        const digests = Object.keys(this.hashes).reduce((acc, key) => {\n            try {\n                acc[key] = crypto_1.default.createHash(key);\n            }\n            catch (e) {\n                throw new error_1.LengthOrHashMismatchError(`Hash algorithm ${key} not supported`);\n            }\n            return acc;\n        }, {});\n        // Read stream chunk by chunk\n        for await (const chunk of stream) {\n            // Keep running tally of stream length\n            observedLength += chunk.length;\n            // Append chunk to each digest\n            Object.values(digests).forEach((digest) => {\n                digest.update(chunk);\n            });\n        }\n        // Verify length matches expected value\n        if (observedLength !== this.length) {\n            throw new error_1.LengthOrHashMismatchError(`Expected length ${this.length} but got ${observedLength}`);\n        }\n        // Verify each digest matches expected value\n        Object.entries(digests).forEach(([key, value]) => {\n            const expected = this.hashes[key];\n            const actual = value.digest('hex');\n            if (actual !== expected) {\n                throw new error_1.LengthOrHashMismatchError(`Expected hash ${expected} but got ${actual}`);\n            }\n        });\n    }\n    toJSON() {\n        return {\n            length: this.length,\n            hashes: this.hashes,\n            ...this.unrecognizedFields,\n        };\n    }\n    static fromJSON(path, data) {\n        const { length, hashes, ...rest } = data;\n        if (typeof length !== 'number') {\n            throw new TypeError('length must be a number');\n        }\n        if (!utils_1.guard.isStringRecord(hashes)) {\n            throw new TypeError('hashes must have string keys and values');\n        }\n        return new TargetFile({\n            length,\n            path,\n            hashes,\n            unrecognizedFields: rest,\n        });\n    }\n}\nexports.TargetFile = TargetFile;\n// Check that supplied length if valid\nfunction validateLength(length) {\n    if (length < 0) {\n        throw new error_1.ValueError('Length must be at least 0');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}