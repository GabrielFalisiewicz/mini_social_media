{"ast":null,"code":"'use strict';\n\nvar _classPrivateMethodInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _classPrivateFieldSet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nconst crypto = require('crypto');\nconst {\n  Minipass\n} = require('minipass');\nconst SPEC_ALGORITHMS = ['sha512', 'sha384', 'sha256'];\nconst DEFAULT_ALGORITHMS = ['sha512'];\n\n// TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst getOptString = options => options?.length ? `?${options.join('?')}` : '';\nvar _emittedIntegrity = /*#__PURE__*/new WeakMap();\nvar _emittedSize = /*#__PURE__*/new WeakMap();\nvar _emittedVerified = /*#__PURE__*/new WeakMap();\nvar _getOptions = /*#__PURE__*/new WeakSet();\nvar _onEnd = /*#__PURE__*/new WeakSet();\nclass IntegrityStream extends Minipass {\n  constructor(opts) {\n    super();\n    _classPrivateMethodInitSpec(this, _onEnd);\n    _classPrivateMethodInitSpec(this, _getOptions);\n    _classPrivateFieldInitSpec(this, _emittedIntegrity, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _emittedSize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _emittedVerified, {\n      writable: true,\n      value: void 0\n    });\n    this.size = 0;\n    this.opts = opts;\n\n    // may be overridden later, but set now for class consistency\n    _classPrivateMethodGet(this, _getOptions, _getOptions2).call(this);\n\n    // options used for calculating stream.  can't be changed.\n    if (opts?.algorithms) {\n      this.algorithms = [...opts.algorithms];\n    } else {\n      this.algorithms = [...DEFAULT_ALGORITHMS];\n    }\n    if (this.algorithm !== null && !this.algorithms.includes(this.algorithm)) {\n      this.algorithms.push(this.algorithm);\n    }\n    this.hashes = this.algorithms.map(crypto.createHash);\n  }\n  on(ev, handler) {\n    if (ev === 'size' && _classPrivateFieldGet(this, _emittedSize)) {\n      return handler(_classPrivateFieldGet(this, _emittedSize));\n    }\n    if (ev === 'integrity' && _classPrivateFieldGet(this, _emittedIntegrity)) {\n      return handler(_classPrivateFieldGet(this, _emittedIntegrity));\n    }\n    if (ev === 'verified' && _classPrivateFieldGet(this, _emittedVerified)) {\n      return handler(_classPrivateFieldGet(this, _emittedVerified));\n    }\n    return super.on(ev, handler);\n  }\n  emit(ev, data) {\n    if (ev === 'end') {\n      _classPrivateMethodGet(this, _onEnd, _onEnd2).call(this);\n    }\n    return super.emit(ev, data);\n  }\n  write(data) {\n    this.size += data.length;\n    this.hashes.forEach(h => h.update(data));\n    return super.write(data);\n  }\n}\nfunction _getOptions2() {\n  // For verification\n  this.sri = this.opts?.integrity ? parse(this.opts?.integrity, this.opts) : null;\n  this.expectedSize = this.opts?.size;\n  if (!this.sri) {\n    this.algorithm = null;\n  } else if (this.sri.isHash) {\n    this.goodSri = true;\n    this.algorithm = this.sri.algorithm;\n  } else {\n    this.goodSri = !this.sri.isEmpty();\n    this.algorithm = this.sri.pickAlgorithm(this.opts);\n  }\n  this.digests = this.goodSri ? this.sri[this.algorithm] : null;\n  this.optString = getOptString(this.opts?.options);\n}\nfunction _onEnd2() {\n  if (!this.goodSri) {\n    _classPrivateMethodGet(this, _getOptions, _getOptions2).call(this);\n  }\n  const newSri = parse(this.hashes.map((h, i) => {\n    return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`;\n  }).join(' '), this.opts);\n  // Integrity verification mode\n  const match = this.goodSri && newSri.match(this.sri, this.opts);\n  if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`);\n    err.code = 'EBADSIZE';\n    err.found = this.size;\n    err.expected = this.expectedSize;\n    err.sri = this.sri;\n    this.emit('error', err);\n  } else if (this.sri && !match) {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = this.digests;\n    err.algorithm = this.algorithm;\n    err.sri = this.sri;\n    this.emit('error', err);\n  } else {\n    _classPrivateFieldSet(this, _emittedSize, this.size);\n    this.emit('size', this.size);\n    _classPrivateFieldSet(this, _emittedIntegrity, newSri);\n    this.emit('integrity', newSri);\n    if (match) {\n      _classPrivateFieldSet(this, _emittedVerified, match);\n      this.emit('verified', match);\n    }\n  }\n}\nclass Hash {\n  get isHash() {\n    return true;\n  }\n  constructor(hash, opts) {\n    const strict = opts?.strict;\n    this.source = hash.trim();\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = '';\n    this.algorithm = '';\n    this.options = [];\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n    if (!match) {\n      return;\n    }\n    if (strict && !SPEC_ALGORITHMS.includes(match[1])) {\n      return;\n    }\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?');\n    }\n  }\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n  toJSON() {\n    return this.toString();\n  }\n  match(integrity, opts) {\n    const other = parse(integrity, opts);\n    if (!other) {\n      return false;\n    }\n    if (other.isIntegrity) {\n      const algo = other.pickAlgorithm(opts, [this.algorithm]);\n      if (!algo) {\n        return false;\n      }\n      const foundHash = other[algo].find(hash => hash.digest === this.digest);\n      if (foundHash) {\n        return foundHash;\n      }\n      return false;\n    }\n    return other.digest === this.digest ? other : false;\n  }\n  toString(opts) {\n    if (opts?.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n      // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.includes(this.algorithm) &&\n      // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) &&\n      // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      this.options.every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n    return `${this.algorithm}-${this.digest}${getOptString(this.options)}`;\n  }\n}\nfunction integrityHashToString(toString, sep, opts, hashes) {\n  const toStringIsNotEmpty = toString !== '';\n  let shouldAddFirstSep = false;\n  let complement = '';\n  const lastIndex = hashes.length - 1;\n  for (let i = 0; i < lastIndex; i++) {\n    const hashString = Hash.prototype.toString.call(hashes[i], opts);\n    if (hashString) {\n      shouldAddFirstSep = true;\n      complement += hashString;\n      complement += sep;\n    }\n  }\n  const finalHashString = Hash.prototype.toString.call(hashes[lastIndex], opts);\n  if (finalHashString) {\n    shouldAddFirstSep = true;\n    complement += finalHashString;\n  }\n  if (toStringIsNotEmpty && shouldAddFirstSep) {\n    return toString + sep + complement;\n  }\n  return toString + complement;\n}\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  isEmpty() {\n    return Object.keys(this).length === 0;\n  }\n  toString(opts) {\n    let sep = opts?.sep || ' ';\n    let toString = '';\n    if (opts?.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n      for (const hash of SPEC_ALGORITHMS) {\n        if (this[hash]) {\n          toString = integrityHashToString(toString, sep, opts, this[hash]);\n        }\n      }\n    } else {\n      for (const hash of Object.keys(this)) {\n        toString = integrityHashToString(toString, sep, opts, this[hash]);\n      }\n    }\n    return toString;\n  }\n  concat(integrity, opts) {\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(`${this.toString(opts)} ${other}`, opts);\n  }\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge(integrity, opts) {\n    const other = parse(integrity, opts);\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity');\n        }\n      } else {\n        this[algo] = other[algo];\n      }\n    }\n  }\n  match(integrity, opts) {\n    const other = parse(integrity, opts);\n    if (!other) {\n      return false;\n    }\n    const algo = other.pickAlgorithm(opts, Object.keys(this));\n    return !!algo && this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n\n  // Pick the highest priority algorithm present, optionally also limited to a\n  // set of hashes found in another integrity.  When limiting it may return\n  // nothing.\n  pickAlgorithm(opts, hashes) {\n    const pickAlgorithm = opts?.pickAlgorithm || getPrioritizedHash;\n    const keys = Object.keys(this).filter(k => {\n      if (hashes?.length) {\n        return hashes.includes(k);\n      }\n      return true;\n    });\n    if (keys.length) {\n      return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc);\n    }\n    // no intersection between this and hashes,\n    return null;\n  }\n}\nmodule.exports.parse = parse;\nfunction parse(sri, opts) {\n  if (!sri) {\n    return null;\n  }\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts?.single) {\n    return new Hash(integrity, opts);\n  }\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n      acc[algo].push(hash);\n    }\n    return acc;\n  }, new Integrity());\n  return hashes.isEmpty() ? null : hashes;\n}\nmodule.exports.stringify = stringify;\nfunction stringify(obj, opts) {\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\nmodule.exports.fromHex = fromHex;\nfunction fromHex(hexDigest, algorithm, opts) {\n  const optString = getOptString(opts?.options);\n  return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n}\nmodule.exports.fromData = fromData;\nfunction fromData(data, opts) {\n  const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];\n  const optString = getOptString(opts?.options);\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const hashAlgo = hash.algorithm;\n      if (!acc[hashAlgo]) {\n        acc[hashAlgo] = [];\n      }\n      acc[hashAlgo].push(hash);\n    }\n    return acc;\n  }, new Integrity());\n}\nmodule.exports.fromStream = fromStream;\nfunction fromStream(stream, opts) {\n  const istream = integrityStream(opts);\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.resume();\n  });\n}\nmodule.exports.checkData = checkData;\nfunction checkData(data, sri, opts) {\n  sri = parse(sri, opts);\n  if (!sri || !Object.keys(sri).length) {\n    if (opts?.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n  opts = opts || {};\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\nmodule.exports.checkStream = checkStream;\nfunction checkStream(stream, sri, opts) {\n  opts = opts || Object.create(null);\n  opts.integrity = sri;\n  sri = parse(sri, opts);\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(new Error('No valid integrity hashes to check against'), {\n      code: 'EINTEGRITY'\n    }));\n  }\n  const checker = integrityStream(opts);\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let verified;\n    checker.on('verified', s => {\n      verified = s;\n    });\n    checker.on('end', () => resolve(verified));\n    checker.resume();\n  });\n}\nmodule.exports.integrityStream = integrityStream;\nfunction integrityStream(opts = Object.create(null)) {\n  return new IntegrityStream(opts);\n}\nmodule.exports.create = createIntegrity;\nfunction createIntegrity(opts) {\n  const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];\n  const optString = getOptString(opts?.options);\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const hashAlgo = hash.algorithm;\n          if (!acc[hashAlgo]) {\n            acc[hashAlgo] = [];\n          }\n          acc[hashAlgo].push(hash);\n        }\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\nconst NODE_HASHES = crypto.getHashes();\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n// TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.includes(algo));\nfunction getPrioritizedHash(algo1, algo2) {\n  /* eslint-disable-next-line max-len */\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"names":["_classPrivateMethodInitSpec","require","default","_classPrivateFieldInitSpec","_classPrivateFieldSet","_classPrivateFieldGet","_classPrivateMethodGet","crypto","Minipass","SPEC_ALGORITHMS","DEFAULT_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","getOptString","options","length","join","_emittedIntegrity","WeakMap","_emittedSize","_emittedVerified","_getOptions","WeakSet","_onEnd","IntegrityStream","constructor","opts","writable","value","size","_getOptions2","call","algorithms","algorithm","includes","push","hashes","map","createHash","on","ev","handler","emit","data","_onEnd2","write","forEach","h","update","sri","integrity","parse","expectedSize","isHash","goodSri","isEmpty","pickAlgorithm","digests","optString","newSri","i","digest","match","err","Error","code","found","expected","Hash","hash","strict","source","trim","rawOpts","slice","split","hexDigest","Buffer","from","toString","toJSON","other","isIntegrity","algo","foundHash","find","every","opt","integrityHashToString","sep","toStringIsNotEmpty","shouldAddFirstSep","complement","lastIndex","hashString","prototype","finalHashString","Integrity","Object","keys","replace","concat","stringify","single","merge","otherhash","getPrioritizedHash","filter","k","reduce","acc","module","exports","_parse","fullSri","string","obj","fromHex","fromData","hashAlgo","fromStream","stream","istream","integrityStream","Promise","resolve","reject","pipe","s","resume","checkData","error","assign","checkStream","create","checker","verified","createIntegrity","chunk","enc","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","algo1","algo2","indexOf","toLowerCase"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/ssri/lib/index.js"],"sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst { Minipass } = require('minipass')\n\nconst SPEC_ALGORITHMS = ['sha512', 'sha384', 'sha256']\nconst DEFAULT_ALGORITHMS = ['sha512']\n\n// TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst getOptString = options => options?.length ? `?${options.join('?')}` : ''\n\nclass IntegrityStream extends Minipass {\n  #emittedIntegrity\n  #emittedSize\n  #emittedVerified\n\n  constructor (opts) {\n    super()\n    this.size = 0\n    this.opts = opts\n\n    // may be overridden later, but set now for class consistency\n    this.#getOptions()\n\n    // options used for calculating stream.  can't be changed.\n    if (opts?.algorithms) {\n      this.algorithms = [...opts.algorithms]\n    } else {\n      this.algorithms = [...DEFAULT_ALGORITHMS]\n    }\n    if (this.algorithm !== null && !this.algorithms.includes(this.algorithm)) {\n      this.algorithms.push(this.algorithm)\n    }\n\n    this.hashes = this.algorithms.map(crypto.createHash)\n  }\n\n  #getOptions () {\n    // For verification\n    this.sri = this.opts?.integrity ? parse(this.opts?.integrity, this.opts) : null\n    this.expectedSize = this.opts?.size\n\n    if (!this.sri) {\n      this.algorithm = null\n    } else if (this.sri.isHash) {\n      this.goodSri = true\n      this.algorithm = this.sri.algorithm\n    } else {\n      this.goodSri = !this.sri.isEmpty()\n      this.algorithm = this.sri.pickAlgorithm(this.opts)\n    }\n\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null\n    this.optString = getOptString(this.opts?.options)\n  }\n\n  on (ev, handler) {\n    if (ev === 'size' && this.#emittedSize) {\n      return handler(this.#emittedSize)\n    }\n\n    if (ev === 'integrity' && this.#emittedIntegrity) {\n      return handler(this.#emittedIntegrity)\n    }\n\n    if (ev === 'verified' && this.#emittedVerified) {\n      return handler(this.#emittedVerified)\n    }\n\n    return super.on(ev, handler)\n  }\n\n  emit (ev, data) {\n    if (ev === 'end') {\n      this.#onEnd()\n    }\n    return super.emit(ev, data)\n  }\n\n  write (data) {\n    this.size += data.length\n    this.hashes.forEach(h => h.update(data))\n    return super.write(data)\n  }\n\n  #onEnd () {\n    if (!this.goodSri) {\n      this.#getOptions()\n    }\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`\n    }).join(' '), this.opts)\n    // Integrity verification mode\n    const match = this.goodSri && newSri.match(this.sri, this.opts)\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      /* eslint-disable-next-line max-len */\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`)\n      err.code = 'EBADSIZE'\n      err.found = this.size\n      err.expected = this.expectedSize\n      err.sri = this.sri\n      this.emit('error', err)\n    } else if (this.sri && !match) {\n      /* eslint-disable-next-line max-len */\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = this.digests\n      err.algorithm = this.algorithm\n      err.sri = this.sri\n      this.emit('error', err)\n    } else {\n      this.#emittedSize = this.size\n      this.emit('size', this.size)\n      this.#emittedIntegrity = newSri\n      this.emit('integrity', newSri)\n      if (match) {\n        this.#emittedVerified = match\n        this.emit('verified', match)\n      }\n    }\n  }\n}\n\nclass Hash {\n  get isHash () {\n    return true\n  }\n\n  constructor (hash, opts) {\n    const strict = opts?.strict\n    this.source = hash.trim()\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = ''\n    this.algorithm = ''\n    this.options = []\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n        ? STRICT_SRI_REGEX\n        : SRI_REGEX\n    )\n    if (!match) {\n      return\n    }\n    if (strict && !SPEC_ALGORITHMS.includes(match[1])) {\n      return\n    }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?')\n    }\n  }\n\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  match (integrity, opts) {\n    const other = parse(integrity, opts)\n    if (!other) {\n      return false\n    }\n    if (other.isIntegrity) {\n      const algo = other.pickAlgorithm(opts, [this.algorithm])\n\n      if (!algo) {\n        return false\n      }\n\n      const foundHash = other[algo].find(hash => hash.digest === this.digest)\n\n      if (foundHash) {\n        return foundHash\n      }\n\n      return false\n    }\n    return other.digest === this.digest ? other : false\n  }\n\n  toString (opts) {\n    if (opts?.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.includes(this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        this.options.every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    return `${this.algorithm}-${this.digest}${getOptString(this.options)}`\n  }\n}\n\nfunction integrityHashToString (toString, sep, opts, hashes) {\n  const toStringIsNotEmpty = toString !== ''\n\n  let shouldAddFirstSep = false\n  let complement = ''\n\n  const lastIndex = hashes.length - 1\n\n  for (let i = 0; i < lastIndex; i++) {\n    const hashString = Hash.prototype.toString.call(hashes[i], opts)\n\n    if (hashString) {\n      shouldAddFirstSep = true\n\n      complement += hashString\n      complement += sep\n    }\n  }\n\n  const finalHashString = Hash.prototype.toString.call(hashes[lastIndex], opts)\n\n  if (finalHashString) {\n    shouldAddFirstSep = true\n    complement += finalHashString\n  }\n\n  if (toStringIsNotEmpty && shouldAddFirstSep) {\n    return toString + sep + complement\n  }\n\n  return toString + complement\n}\n\nclass Integrity {\n  get isIntegrity () {\n    return true\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  isEmpty () {\n    return Object.keys(this).length === 0\n  }\n\n  toString (opts) {\n    let sep = opts?.sep || ' '\n    let toString = ''\n\n    if (opts?.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n\n      for (const hash of SPEC_ALGORITHMS) {\n        if (this[hash]) {\n          toString = integrityHashToString(toString, sep, opts, this[hash])\n        }\n      }\n    } else {\n      for (const hash of Object.keys(this)) {\n        toString = integrityHashToString(toString, sep, opts, this[hash])\n      }\n    }\n\n    return toString\n  }\n\n  concat (integrity, opts) {\n    const other = typeof integrity === 'string'\n      ? integrity\n      : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n\n  hexDigest () {\n    return parse(this, { single: true }).hexDigest()\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge (integrity, opts) {\n    const other = parse(integrity, opts)\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash =>\n          other[algo].find(otherhash =>\n            hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity')\n        }\n      } else {\n        this[algo] = other[algo]\n      }\n    }\n  }\n\n  match (integrity, opts) {\n    const other = parse(integrity, opts)\n    if (!other) {\n      return false\n    }\n    const algo = other.pickAlgorithm(opts, Object.keys(this))\n    return (\n      !!algo &&\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n\n  // Pick the highest priority algorithm present, optionally also limited to a\n  // set of hashes found in another integrity.  When limiting it may return\n  // nothing.\n  pickAlgorithm (opts, hashes) {\n    const pickAlgorithm = opts?.pickAlgorithm || getPrioritizedHash\n    const keys = Object.keys(this).filter(k => {\n      if (hashes?.length) {\n        return hashes.includes(k)\n      }\n      return true\n    })\n    if (keys.length) {\n      return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc)\n    }\n    // no intersection between this and hashes,\n    return null\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  if (!sri) {\n    return null\n  }\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts?.single) {\n    return new Hash(integrity, opts)\n  }\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) {\n        acc[algo] = []\n      }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n  return hashes.isEmpty() ? null : hashes\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  const optString = getOptString(opts?.options)\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS]\n  const optString = getOptString(opts?.options)\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n      opts\n    )\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const hashAlgo = hash.algorithm\n      if (!acc[hashAlgo]) {\n        acc[hashAlgo] = []\n      }\n      acc[hashAlgo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  const istream = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => {\n      sri = s\n    })\n    istream.on('end', () => resolve(sri))\n    istream.resume()\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    if (opts?.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY',\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({ algorithm, digest })\n  const match = newSri.match(sri, opts)\n  opts = opts || {}\n  if (match || !(opts.error)) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    /* eslint-disable-next-line max-len */\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = opts || Object.create(null)\n  opts.integrity = sri\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(\n      new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY',\n      }\n    ))\n  }\n  const checker = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let verified\n    checker.on('verified', s => {\n      verified = s\n    })\n    checker.on('end', () => resolve(verified))\n    checker.resume()\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts = Object.create(null)) {\n  return new IntegrityStream(opts)\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS]\n  const optString = getOptString(opts?.options)\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const hashAlgo = hash.algorithm\n          if (!acc[hashAlgo]) {\n            acc[hashAlgo] = []\n          }\n          acc[hashAlgo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    },\n  }\n}\n\nconst NODE_HASHES = crypto.getHashes()\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512',\n].filter(algo => NODE_HASHES.includes(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  /* eslint-disable-next-line max-len */\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n    ? algo1\n    : algo2\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}