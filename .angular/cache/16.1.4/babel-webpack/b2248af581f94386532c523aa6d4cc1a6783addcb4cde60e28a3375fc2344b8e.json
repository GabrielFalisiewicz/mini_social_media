{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyCertificateChain = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst error_1 = require(\"../error\");\nfunction verifyCertificateChain(opts) {\n  const verifier = new CertificateChainVerifier(opts);\n  return verifier.verify();\n}\nexports.verifyCertificateChain = verifyCertificateChain;\nclass CertificateChainVerifier {\n  constructor(opts) {\n    this.untrustedCert = opts.untrustedCert;\n    this.trustedCerts = opts.trustedCerts;\n    this.localCerts = dedupeCertificates([...opts.trustedCerts, opts.untrustedCert]);\n    this.validAt = opts.validAt || new Date();\n  }\n  verify() {\n    // Construct certificate path from leaf to root\n    const certificatePath = this.sort();\n    // Perform validation checks on each certificate in the path\n    this.checkPath(certificatePath);\n    // Return verified certificate path\n    return certificatePath;\n  }\n  sort() {\n    const leafCert = this.untrustedCert;\n    // Construct all possible paths from the leaf\n    let paths = this.buildPaths(leafCert);\n    // Filter for paths which contain a trusted certificate\n    paths = paths.filter(path => path.some(cert => this.trustedCerts.includes(cert)));\n    if (paths.length === 0) {\n      throw new error_1.VerificationError('No trusted certificate path found');\n    }\n    // Find the shortest of possible paths\n    const path = paths.reduce((prev, curr) => prev.length < curr.length ? prev : curr);\n    // Construct chain from shortest path\n    // Removes the last certificate in the path, which will be a second copy\n    // of the root certificate given that the root is self-signed.\n    return [leafCert, ...path].slice(0, -1);\n  }\n  // Recursively build all possible paths from the leaf to the root\n  buildPaths(certificate) {\n    const paths = [];\n    const issuers = this.findIssuer(certificate);\n    if (issuers.length === 0) {\n      throw new error_1.VerificationError('No valid certificate path found');\n    }\n    for (let i = 0; i < issuers.length; i++) {\n      const issuer = issuers[i];\n      // Base case - issuer is self\n      if (issuer.equals(certificate)) {\n        paths.push([certificate]);\n        continue;\n      }\n      // Recursively build path for the issuer\n      const subPaths = this.buildPaths(issuer);\n      // Construct paths by appending the issuer to each subpath\n      for (let j = 0; j < subPaths.length; j++) {\n        paths.push([issuer, ...subPaths[j]]);\n      }\n    }\n    return paths;\n  }\n  // Return all possible issuers for the given certificate\n  findIssuer(certificate) {\n    let issuers = [];\n    let keyIdentifier;\n    // Exit early if the certificate is self-signed\n    if (certificate.subject.equals(certificate.issuer)) {\n      if (certificate.verify()) {\n        return [certificate];\n      }\n    }\n    // If the certificate has an authority key identifier, use that\n    // to find the issuer\n    if (certificate.extAuthorityKeyID) {\n      keyIdentifier = certificate.extAuthorityKeyID.keyIdentifier;\n      // TODO: Add support for authorityCertIssuer/authorityCertSerialNumber\n      // though Fulcio doesn't appear to use these\n    }\n    // Find possible issuers by comparing the authorityKeyID/subjectKeyID\n    // or issuer/subject. Potential issuers are added to the result array.\n    this.localCerts.forEach(possibleIssuer => {\n      if (keyIdentifier) {\n        if (possibleIssuer.extSubjectKeyID) {\n          if (possibleIssuer.extSubjectKeyID.keyIdentifier.equals(keyIdentifier)) {\n            issuers.push(possibleIssuer);\n          }\n          return;\n        }\n      }\n      // Fallback to comparing certificate issuer and subject if\n      // subjectKey/authorityKey extensions are not present\n      if (possibleIssuer.subject.equals(certificate.issuer)) {\n        issuers.push(possibleIssuer);\n      }\n    });\n    // Remove any issuers which fail to verify the certificate\n    issuers = issuers.filter(issuer => {\n      try {\n        return certificate.verify(issuer);\n      } catch (ex) {\n        return false;\n      }\n    });\n    return issuers;\n  }\n  checkPath(path) {\n    if (path.length < 1) {\n      throw new error_1.VerificationError('Certificate chain must contain at least one certificate');\n    }\n    // Check that all certificates are valid at the check date\n    const validForDate = path.every(cert => cert.validForDate(this.validAt));\n    if (!validForDate) {\n      throw new error_1.VerificationError('Certificate is not valid or expired at the specified date');\n    }\n    // Ensure that all certificates beyond the leaf are CAs\n    const validCAs = path.slice(1).every(cert => cert.isCA);\n    if (!validCAs) {\n      throw new error_1.VerificationError('Intermediate certificate is not a CA');\n    }\n    // Certificate's issuer must match the subject of the next certificate\n    // in the chain\n    for (let i = path.length - 2; i >= 0; i--) {\n      if (!path[i].issuer.equals(path[i + 1].subject)) {\n        throw new error_1.VerificationError('Incorrect certificate name chaining');\n      }\n    }\n    // Check pathlength constraints\n    for (let i = 0; i < path.length; i++) {\n      const cert = path[i];\n      // If the certificate is a CA, check the path length\n      if (cert.extBasicConstraints?.isCA) {\n        const pathLength = cert.extBasicConstraints.pathLenConstraint;\n        // The path length, if set, indicates how many intermediate\n        // certificates (NOT including the leaf) are allowed to follow. The\n        // pathLength constraint of any intermediate CA certificate MUST be\n        // greater than or equal to it's own depth in the chain (with an\n        // adjustment for the leaf certificate)\n        if (pathLength !== undefined && pathLength < i - 1) {\n          throw new error_1.VerificationError('Path length constraint exceeded');\n        }\n      }\n    }\n  }\n}\n// Remove duplicate certificates from the array\nfunction dedupeCertificates(certs) {\n  for (let i = 0; i < certs.length; i++) {\n    for (let j = i + 1; j < certs.length; j++) {\n      if (certs[i].equals(certs[j])) {\n        certs.splice(j, 1);\n        j--;\n      }\n    }\n  }\n  return certs;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","verifyCertificateChain","error_1","require","opts","verifier","CertificateChainVerifier","verify","constructor","untrustedCert","trustedCerts","localCerts","dedupeCertificates","validAt","Date","certificatePath","sort","checkPath","leafCert","paths","buildPaths","filter","path","some","cert","includes","length","VerificationError","reduce","prev","curr","slice","certificate","issuers","findIssuer","i","issuer","equals","push","subPaths","j","keyIdentifier","subject","extAuthorityKeyID","forEach","possibleIssuer","extSubjectKeyID","ex","validForDate","every","validCAs","isCA","extBasicConstraints","pathLength","pathLenConstraint","undefined","certs","splice"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/x509/verify.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyCertificateChain = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst error_1 = require(\"../error\");\nfunction verifyCertificateChain(opts) {\n    const verifier = new CertificateChainVerifier(opts);\n    return verifier.verify();\n}\nexports.verifyCertificateChain = verifyCertificateChain;\nclass CertificateChainVerifier {\n    constructor(opts) {\n        this.untrustedCert = opts.untrustedCert;\n        this.trustedCerts = opts.trustedCerts;\n        this.localCerts = dedupeCertificates([\n            ...opts.trustedCerts,\n            opts.untrustedCert,\n        ]);\n        this.validAt = opts.validAt || new Date();\n    }\n    verify() {\n        // Construct certificate path from leaf to root\n        const certificatePath = this.sort();\n        // Perform validation checks on each certificate in the path\n        this.checkPath(certificatePath);\n        // Return verified certificate path\n        return certificatePath;\n    }\n    sort() {\n        const leafCert = this.untrustedCert;\n        // Construct all possible paths from the leaf\n        let paths = this.buildPaths(leafCert);\n        // Filter for paths which contain a trusted certificate\n        paths = paths.filter((path) => path.some((cert) => this.trustedCerts.includes(cert)));\n        if (paths.length === 0) {\n            throw new error_1.VerificationError('No trusted certificate path found');\n        }\n        // Find the shortest of possible paths\n        const path = paths.reduce((prev, curr) => prev.length < curr.length ? prev : curr);\n        // Construct chain from shortest path\n        // Removes the last certificate in the path, which will be a second copy\n        // of the root certificate given that the root is self-signed.\n        return [leafCert, ...path].slice(0, -1);\n    }\n    // Recursively build all possible paths from the leaf to the root\n    buildPaths(certificate) {\n        const paths = [];\n        const issuers = this.findIssuer(certificate);\n        if (issuers.length === 0) {\n            throw new error_1.VerificationError('No valid certificate path found');\n        }\n        for (let i = 0; i < issuers.length; i++) {\n            const issuer = issuers[i];\n            // Base case - issuer is self\n            if (issuer.equals(certificate)) {\n                paths.push([certificate]);\n                continue;\n            }\n            // Recursively build path for the issuer\n            const subPaths = this.buildPaths(issuer);\n            // Construct paths by appending the issuer to each subpath\n            for (let j = 0; j < subPaths.length; j++) {\n                paths.push([issuer, ...subPaths[j]]);\n            }\n        }\n        return paths;\n    }\n    // Return all possible issuers for the given certificate\n    findIssuer(certificate) {\n        let issuers = [];\n        let keyIdentifier;\n        // Exit early if the certificate is self-signed\n        if (certificate.subject.equals(certificate.issuer)) {\n            if (certificate.verify()) {\n                return [certificate];\n            }\n        }\n        // If the certificate has an authority key identifier, use that\n        // to find the issuer\n        if (certificate.extAuthorityKeyID) {\n            keyIdentifier = certificate.extAuthorityKeyID.keyIdentifier;\n            // TODO: Add support for authorityCertIssuer/authorityCertSerialNumber\n            // though Fulcio doesn't appear to use these\n        }\n        // Find possible issuers by comparing the authorityKeyID/subjectKeyID\n        // or issuer/subject. Potential issuers are added to the result array.\n        this.localCerts.forEach((possibleIssuer) => {\n            if (keyIdentifier) {\n                if (possibleIssuer.extSubjectKeyID) {\n                    if (possibleIssuer.extSubjectKeyID.keyIdentifier.equals(keyIdentifier)) {\n                        issuers.push(possibleIssuer);\n                    }\n                    return;\n                }\n            }\n            // Fallback to comparing certificate issuer and subject if\n            // subjectKey/authorityKey extensions are not present\n            if (possibleIssuer.subject.equals(certificate.issuer)) {\n                issuers.push(possibleIssuer);\n            }\n        });\n        // Remove any issuers which fail to verify the certificate\n        issuers = issuers.filter((issuer) => {\n            try {\n                return certificate.verify(issuer);\n            }\n            catch (ex) {\n                return false;\n            }\n        });\n        return issuers;\n    }\n    checkPath(path) {\n        if (path.length < 1) {\n            throw new error_1.VerificationError('Certificate chain must contain at least one certificate');\n        }\n        // Check that all certificates are valid at the check date\n        const validForDate = path.every((cert) => cert.validForDate(this.validAt));\n        if (!validForDate) {\n            throw new error_1.VerificationError('Certificate is not valid or expired at the specified date');\n        }\n        // Ensure that all certificates beyond the leaf are CAs\n        const validCAs = path.slice(1).every((cert) => cert.isCA);\n        if (!validCAs) {\n            throw new error_1.VerificationError('Intermediate certificate is not a CA');\n        }\n        // Certificate's issuer must match the subject of the next certificate\n        // in the chain\n        for (let i = path.length - 2; i >= 0; i--) {\n            if (!path[i].issuer.equals(path[i + 1].subject)) {\n                throw new error_1.VerificationError('Incorrect certificate name chaining');\n            }\n        }\n        // Check pathlength constraints\n        for (let i = 0; i < path.length; i++) {\n            const cert = path[i];\n            // If the certificate is a CA, check the path length\n            if (cert.extBasicConstraints?.isCA) {\n                const pathLength = cert.extBasicConstraints.pathLenConstraint;\n                // The path length, if set, indicates how many intermediate\n                // certificates (NOT including the leaf) are allowed to follow. The\n                // pathLength constraint of any intermediate CA certificate MUST be\n                // greater than or equal to it's own depth in the chain (with an\n                // adjustment for the leaf certificate)\n                if (pathLength !== undefined && pathLength < i - 1) {\n                    throw new error_1.VerificationError('Path length constraint exceeded');\n                }\n            }\n        }\n    }\n}\n// Remove duplicate certificates from the array\nfunction dedupeCertificates(certs) {\n    for (let i = 0; i < certs.length; i++) {\n        for (let j = i + 1; j < certs.length; j++) {\n            if (certs[i].equals(certs[j])) {\n                certs.splice(j, 1);\n                j--;\n            }\n        }\n    }\n    return certs;\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,sBAAsB,GAAG,KAAK,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,SAASF,sBAAsBA,CAACG,IAAI,EAAE;EAClC,MAAMC,QAAQ,GAAG,IAAIC,wBAAwB,CAACF,IAAI,CAAC;EACnD,OAAOC,QAAQ,CAACE,MAAM,CAAC,CAAC;AAC5B;AACAR,OAAO,CAACE,sBAAsB,GAAGA,sBAAsB;AACvD,MAAMK,wBAAwB,CAAC;EAC3BE,WAAWA,CAACJ,IAAI,EAAE;IACd,IAAI,CAACK,aAAa,GAAGL,IAAI,CAACK,aAAa;IACvC,IAAI,CAACC,YAAY,GAAGN,IAAI,CAACM,YAAY;IACrC,IAAI,CAACC,UAAU,GAAGC,kBAAkB,CAAC,CACjC,GAAGR,IAAI,CAACM,YAAY,EACpBN,IAAI,CAACK,aAAa,CACrB,CAAC;IACF,IAAI,CAACI,OAAO,GAAGT,IAAI,CAACS,OAAO,IAAI,IAAIC,IAAI,CAAC,CAAC;EAC7C;EACAP,MAAMA,CAAA,EAAG;IACL;IACA,MAAMQ,eAAe,GAAG,IAAI,CAACC,IAAI,CAAC,CAAC;IACnC;IACA,IAAI,CAACC,SAAS,CAACF,eAAe,CAAC;IAC/B;IACA,OAAOA,eAAe;EAC1B;EACAC,IAAIA,CAAA,EAAG;IACH,MAAME,QAAQ,GAAG,IAAI,CAACT,aAAa;IACnC;IACA,IAAIU,KAAK,GAAG,IAAI,CAACC,UAAU,CAACF,QAAQ,CAAC;IACrC;IACAC,KAAK,GAAGA,KAAK,CAACE,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACC,IAAI,CAAEC,IAAI,IAAK,IAAI,CAACd,YAAY,CAACe,QAAQ,CAACD,IAAI,CAAC,CAAC,CAAC;IACrF,IAAIL,KAAK,CAACO,MAAM,KAAK,CAAC,EAAE;MACpB,MAAM,IAAIxB,OAAO,CAACyB,iBAAiB,CAAC,mCAAmC,CAAC;IAC5E;IACA;IACA,MAAML,IAAI,GAAGH,KAAK,CAACS,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAKD,IAAI,CAACH,MAAM,GAAGI,IAAI,CAACJ,MAAM,GAAGG,IAAI,GAAGC,IAAI,CAAC;IAClF;IACA;IACA;IACA,OAAO,CAACZ,QAAQ,EAAE,GAAGI,IAAI,CAAC,CAACS,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC3C;EACA;EACAX,UAAUA,CAACY,WAAW,EAAE;IACpB,MAAMb,KAAK,GAAG,EAAE;IAChB,MAAMc,OAAO,GAAG,IAAI,CAACC,UAAU,CAACF,WAAW,CAAC;IAC5C,IAAIC,OAAO,CAACP,MAAM,KAAK,CAAC,EAAE;MACtB,MAAM,IAAIxB,OAAO,CAACyB,iBAAiB,CAAC,iCAAiC,CAAC;IAC1E;IACA,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,CAACP,MAAM,EAAES,CAAC,EAAE,EAAE;MACrC,MAAMC,MAAM,GAAGH,OAAO,CAACE,CAAC,CAAC;MACzB;MACA,IAAIC,MAAM,CAACC,MAAM,CAACL,WAAW,CAAC,EAAE;QAC5Bb,KAAK,CAACmB,IAAI,CAAC,CAACN,WAAW,CAAC,CAAC;QACzB;MACJ;MACA;MACA,MAAMO,QAAQ,GAAG,IAAI,CAACnB,UAAU,CAACgB,MAAM,CAAC;MACxC;MACA,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,QAAQ,CAACb,MAAM,EAAEc,CAAC,EAAE,EAAE;QACtCrB,KAAK,CAACmB,IAAI,CAAC,CAACF,MAAM,EAAE,GAAGG,QAAQ,CAACC,CAAC,CAAC,CAAC,CAAC;MACxC;IACJ;IACA,OAAOrB,KAAK;EAChB;EACA;EACAe,UAAUA,CAACF,WAAW,EAAE;IACpB,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAIQ,aAAa;IACjB;IACA,IAAIT,WAAW,CAACU,OAAO,CAACL,MAAM,CAACL,WAAW,CAACI,MAAM,CAAC,EAAE;MAChD,IAAIJ,WAAW,CAACzB,MAAM,CAAC,CAAC,EAAE;QACtB,OAAO,CAACyB,WAAW,CAAC;MACxB;IACJ;IACA;IACA;IACA,IAAIA,WAAW,CAACW,iBAAiB,EAAE;MAC/BF,aAAa,GAAGT,WAAW,CAACW,iBAAiB,CAACF,aAAa;MAC3D;MACA;IACJ;IACA;IACA;IACA,IAAI,CAAC9B,UAAU,CAACiC,OAAO,CAAEC,cAAc,IAAK;MACxC,IAAIJ,aAAa,EAAE;QACf,IAAII,cAAc,CAACC,eAAe,EAAE;UAChC,IAAID,cAAc,CAACC,eAAe,CAACL,aAAa,CAACJ,MAAM,CAACI,aAAa,CAAC,EAAE;YACpER,OAAO,CAACK,IAAI,CAACO,cAAc,CAAC;UAChC;UACA;QACJ;MACJ;MACA;MACA;MACA,IAAIA,cAAc,CAACH,OAAO,CAACL,MAAM,CAACL,WAAW,CAACI,MAAM,CAAC,EAAE;QACnDH,OAAO,CAACK,IAAI,CAACO,cAAc,CAAC;MAChC;IACJ,CAAC,CAAC;IACF;IACAZ,OAAO,GAAGA,OAAO,CAACZ,MAAM,CAAEe,MAAM,IAAK;MACjC,IAAI;QACA,OAAOJ,WAAW,CAACzB,MAAM,CAAC6B,MAAM,CAAC;MACrC,CAAC,CACD,OAAOW,EAAE,EAAE;QACP,OAAO,KAAK;MAChB;IACJ,CAAC,CAAC;IACF,OAAOd,OAAO;EAClB;EACAhB,SAASA,CAACK,IAAI,EAAE;IACZ,IAAIA,IAAI,CAACI,MAAM,GAAG,CAAC,EAAE;MACjB,MAAM,IAAIxB,OAAO,CAACyB,iBAAiB,CAAC,yDAAyD,CAAC;IAClG;IACA;IACA,MAAMqB,YAAY,GAAG1B,IAAI,CAAC2B,KAAK,CAAEzB,IAAI,IAAKA,IAAI,CAACwB,YAAY,CAAC,IAAI,CAACnC,OAAO,CAAC,CAAC;IAC1E,IAAI,CAACmC,YAAY,EAAE;MACf,MAAM,IAAI9C,OAAO,CAACyB,iBAAiB,CAAC,2DAA2D,CAAC;IACpG;IACA;IACA,MAAMuB,QAAQ,GAAG5B,IAAI,CAACS,KAAK,CAAC,CAAC,CAAC,CAACkB,KAAK,CAAEzB,IAAI,IAAKA,IAAI,CAAC2B,IAAI,CAAC;IACzD,IAAI,CAACD,QAAQ,EAAE;MACX,MAAM,IAAIhD,OAAO,CAACyB,iBAAiB,CAAC,sCAAsC,CAAC;IAC/E;IACA;IACA;IACA,KAAK,IAAIQ,CAAC,GAAGb,IAAI,CAACI,MAAM,GAAG,CAAC,EAAES,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACvC,IAAI,CAACb,IAAI,CAACa,CAAC,CAAC,CAACC,MAAM,CAACC,MAAM,CAACf,IAAI,CAACa,CAAC,GAAG,CAAC,CAAC,CAACO,OAAO,CAAC,EAAE;QAC7C,MAAM,IAAIxC,OAAO,CAACyB,iBAAiB,CAAC,qCAAqC,CAAC;MAC9E;IACJ;IACA;IACA,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,IAAI,CAACI,MAAM,EAAES,CAAC,EAAE,EAAE;MAClC,MAAMX,IAAI,GAAGF,IAAI,CAACa,CAAC,CAAC;MACpB;MACA,IAAIX,IAAI,CAAC4B,mBAAmB,EAAED,IAAI,EAAE;QAChC,MAAME,UAAU,GAAG7B,IAAI,CAAC4B,mBAAmB,CAACE,iBAAiB;QAC7D;QACA;QACA;QACA;QACA;QACA,IAAID,UAAU,KAAKE,SAAS,IAAIF,UAAU,GAAGlB,CAAC,GAAG,CAAC,EAAE;UAChD,MAAM,IAAIjC,OAAO,CAACyB,iBAAiB,CAAC,iCAAiC,CAAC;QAC1E;MACJ;IACJ;EACJ;AACJ;AACA;AACA,SAASf,kBAAkBA,CAAC4C,KAAK,EAAE;EAC/B,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,KAAK,CAAC9B,MAAM,EAAES,CAAC,EAAE,EAAE;IACnC,KAAK,IAAIK,CAAC,GAAGL,CAAC,GAAG,CAAC,EAAEK,CAAC,GAAGgB,KAAK,CAAC9B,MAAM,EAAEc,CAAC,EAAE,EAAE;MACvC,IAAIgB,KAAK,CAACrB,CAAC,CAAC,CAACE,MAAM,CAACmB,KAAK,CAAChB,CAAC,CAAC,CAAC,EAAE;QAC3BgB,KAAK,CAACC,MAAM,CAACjB,CAAC,EAAE,CAAC,CAAC;QAClBA,CAAC,EAAE;MACP;IACJ;EACJ;EACA,OAAOgB,KAAK;AAChB"},"metadata":{},"sourceType":"script","externalDependencies":[]}