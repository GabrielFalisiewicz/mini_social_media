{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\nconst virtual_fs_1 = require(\"../virtual-fs\");\nconst reader_1 = require(\"./json/reader\");\nconst writer_1 = require(\"./json/writer\");\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\nvar WorkspaceFormat;\n(function (WorkspaceFormat) {\n  WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat || (exports.WorkspaceFormat = WorkspaceFormat = {}));\n/**\n * @private\n */\nfunction _test_addWorkspaceFile(name, format) {\n  workspaceFiles[name] = format;\n}\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\nfunction _test_removeWorkspaceFile(name) {\n  delete workspaceFiles[name];\n}\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile;\n// NOTE: future additions could also perform content analysis to determine format/version\nconst workspaceFiles = {\n  'angular.json': WorkspaceFormat.JSON,\n  '.angular.json': WorkspaceFormat.JSON\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\nfunction readWorkspace(_x, _x2, _x3) {\n  return _readWorkspace.apply(this, arguments);\n}\nfunction _readWorkspace() {\n  _readWorkspace = _asyncToGenerator(function* (path, host, format) {\n    if (yield host.isDirectory(path)) {\n      // TODO: Warn if multiple found (requires diagnostics support)\n      const directory = (0, virtual_fs_1.normalize)(path);\n      let found = false;\n      for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n        if (format !== undefined && format !== nameFormat) {\n          continue;\n        }\n        const potential = (0, virtual_fs_1.getSystemPath)((0, virtual_fs_1.join)(directory, name));\n        if (yield host.isFile(potential)) {\n          path = potential;\n          format = nameFormat;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        throw new Error('Unable to locate a workspace file for workspace path. Are you missing an `angular.json`' + ' or `.angular.json` file?');\n      }\n    } else if (format === undefined) {\n      const filename = (0, virtual_fs_1.basename)((0, virtual_fs_1.normalize)(path));\n      if (filename in workspaceFiles) {\n        format = workspaceFiles[filename];\n      }\n    }\n    if (format === undefined) {\n      throw new Error('Unable to determine format for workspace path.');\n    }\n    let workspace;\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        workspace = yield (0, reader_1.readJsonWorkspace)(path, host);\n        break;\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return {\n      workspace\n    };\n  });\n  return _readWorkspace.apply(this, arguments);\n}\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\nfunction writeWorkspace(_x4, _x5, _x6, _x7) {\n  return _writeWorkspace.apply(this, arguments);\n}\nfunction _writeWorkspace() {\n  _writeWorkspace = _asyncToGenerator(function* (workspace, host, path, format) {\n    if (format === undefined) {\n      format = formatLookup.get(workspace);\n      if (format === undefined) {\n        throw new Error('A format is required for custom workspace objects.');\n      }\n    }\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        return (0, writer_1.writeJsonWorkspace)(workspace, host, path);\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n  });\n  return _writeWorkspace.apply(this, arguments);\n}\nexports.writeWorkspace = writeWorkspace;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","writeWorkspace","readWorkspace","_test_removeWorkspaceFile","_test_addWorkspaceFile","WorkspaceFormat","virtual_fs_1","reader_1","writer_1","formatLookup","WeakMap","name","format","workspaceFiles","JSON","_x","_x2","_x3","_readWorkspace","apply","arguments","path","host","isDirectory","directory","normalize","found","nameFormat","entries","undefined","potential","getSystemPath","join","isFile","Error","filename","basename","workspace","readJsonWorkspace","set","_x4","_x5","_x6","_x7","_writeWorkspace","get","writeJsonWorkspace"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular-devkit/core/src/workspace/core.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\nconst virtual_fs_1 = require(\"../virtual-fs\");\nconst reader_1 = require(\"./json/reader\");\nconst writer_1 = require(\"./json/writer\");\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\nvar WorkspaceFormat;\n(function (WorkspaceFormat) {\n    WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat || (exports.WorkspaceFormat = WorkspaceFormat = {}));\n/**\n * @private\n */\nfunction _test_addWorkspaceFile(name, format) {\n    workspaceFiles[name] = format;\n}\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\nfunction _test_removeWorkspaceFile(name) {\n    delete workspaceFiles[name];\n}\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile;\n// NOTE: future additions could also perform content analysis to determine format/version\nconst workspaceFiles = {\n    'angular.json': WorkspaceFormat.JSON,\n    '.angular.json': WorkspaceFormat.JSON,\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\nasync function readWorkspace(path, host, format) {\n    if (await host.isDirectory(path)) {\n        // TODO: Warn if multiple found (requires diagnostics support)\n        const directory = (0, virtual_fs_1.normalize)(path);\n        let found = false;\n        for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n            if (format !== undefined && format !== nameFormat) {\n                continue;\n            }\n            const potential = (0, virtual_fs_1.getSystemPath)((0, virtual_fs_1.join)(directory, name));\n            if (await host.isFile(potential)) {\n                path = potential;\n                format = nameFormat;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error('Unable to locate a workspace file for workspace path. Are you missing an `angular.json`' +\n                ' or `.angular.json` file?');\n        }\n    }\n    else if (format === undefined) {\n        const filename = (0, virtual_fs_1.basename)((0, virtual_fs_1.normalize)(path));\n        if (filename in workspaceFiles) {\n            format = workspaceFiles[filename];\n        }\n    }\n    if (format === undefined) {\n        throw new Error('Unable to determine format for workspace path.');\n    }\n    let workspace;\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            workspace = await (0, reader_1.readJsonWorkspace)(path, host);\n            break;\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return { workspace };\n}\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\nasync function writeWorkspace(workspace, host, path, format) {\n    if (format === undefined) {\n        format = formatLookup.get(workspace);\n        if (format === undefined) {\n            throw new Error('A format is required for custom workspace objects.');\n        }\n    }\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            return (0, writer_1.writeJsonWorkspace)(workspace, host, path);\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n}\nexports.writeWorkspace = writeWorkspace;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}