{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readTarget = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst fs_1 = __importDefault(require(\"fs\"));\nconst error_1 = require(\"./error\");\n// Downloads and returns the specified target from the provided TUF Updater.\nfunction readTarget(_x, _x2) {\n  return _readTarget.apply(this, arguments);\n}\nfunction _readTarget() {\n  _readTarget = _asyncToGenerator(function* (tuf, targetPath) {\n    const path = yield getTargetPath(tuf, targetPath);\n    return new Promise((resolve, reject) => {\n      fs_1.default.readFile(path, 'utf-8', (err, data) => {\n        if (err) {\n          reject(new error_1.TUFError({\n            code: 'TUF_READ_TARGET_ERROR',\n            message: `error reading target ${path}`,\n            cause: err\n          }));\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  });\n  return _readTarget.apply(this, arguments);\n}\nexports.readTarget = readTarget;\n// Returns the local path to the specified target. If the target is not yet\n// cached locally, the provided TUF Updater will be used to download and\n// cache the target.\nfunction getTargetPath(_x3, _x4) {\n  return _getTargetPath.apply(this, arguments);\n}\nfunction _getTargetPath() {\n  _getTargetPath = _asyncToGenerator(function* (tuf, target) {\n    let targetInfo;\n    try {\n      targetInfo = yield tuf.getTargetInfo(target);\n    } catch (err) {\n      throw new error_1.TUFError({\n        code: 'TUF_REFRESH_METADATA_ERROR',\n        message: 'error refreshing TUF metadata',\n        cause: err\n      });\n    }\n    if (!targetInfo) {\n      throw new error_1.TUFError({\n        code: 'TUF_FIND_TARGET_ERROR',\n        message: `target ${target} not found`\n      });\n    }\n    let path = yield tuf.findCachedTarget(targetInfo);\n    // An empty path here means the target has not been cached locally, or is\n    // out of date. In either case, we need to download it.\n    if (!path) {\n      try {\n        path = yield tuf.downloadTarget(targetInfo);\n      } catch (err) {\n        throw new error_1.TUFError({\n          code: 'TUF_DOWNLOAD_TARGET_ERROR',\n          message: `error downloading target ${path}`,\n          cause: err\n        });\n      }\n    }\n    return path;\n  });\n  return _getTargetPath.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","__importDefault","mod","__esModule","Object","defineProperty","exports","value","readTarget","fs_1","error_1","_x","_x2","_readTarget","apply","arguments","tuf","targetPath","path","getTargetPath","Promise","resolve","reject","readFile","err","data","TUFError","code","message","cause","_x3","_x4","_getTargetPath","target","targetInfo","getTargetInfo","findCachedTarget","downloadTarget"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@sigstore/tuf/dist/target.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readTarget = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst fs_1 = __importDefault(require(\"fs\"));\nconst error_1 = require(\"./error\");\n// Downloads and returns the specified target from the provided TUF Updater.\nasync function readTarget(tuf, targetPath) {\n    const path = await getTargetPath(tuf, targetPath);\n    return new Promise((resolve, reject) => {\n        fs_1.default.readFile(path, 'utf-8', (err, data) => {\n            if (err) {\n                reject(new error_1.TUFError({\n                    code: 'TUF_READ_TARGET_ERROR',\n                    message: `error reading target ${path}`,\n                    cause: err,\n                }));\n            }\n            else {\n                resolve(data);\n            }\n        });\n    });\n}\nexports.readTarget = readTarget;\n// Returns the local path to the specified target. If the target is not yet\n// cached locally, the provided TUF Updater will be used to download and\n// cache the target.\nasync function getTargetPath(tuf, target) {\n    let targetInfo;\n    try {\n        targetInfo = await tuf.getTargetInfo(target);\n    }\n    catch (err) {\n        throw new error_1.TUFError({\n            code: 'TUF_REFRESH_METADATA_ERROR',\n            message: 'error refreshing TUF metadata',\n            cause: err,\n        });\n    }\n    if (!targetInfo) {\n        throw new error_1.TUFError({\n            code: 'TUF_FIND_TARGET_ERROR',\n            message: `target ${target} not found`,\n        });\n    }\n    let path = await tuf.findCachedTarget(targetInfo);\n    // An empty path here means the target has not been cached locally, or is\n    // out of date. In either case, we need to download it.\n    if (!path) {\n        try {\n            path = await tuf.downloadTarget(targetInfo);\n        }\n        catch (err) {\n            throw new error_1.TUFError({\n                code: 'TUF_DOWNLOAD_TARGET_ERROR',\n                message: `error downloading target ${path}`,\n                cause: err,\n            });\n        }\n    }\n    return path;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}