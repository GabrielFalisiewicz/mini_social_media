{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBitString = exports.parseBoolean = exports.parseOID = exports.parseTime = exports.parseStringASCII = exports.parseInteger = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst RE_TIME_SHORT_YEAR = /^(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z$/;\nconst RE_TIME_LONG_YEAR = /^(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z$/;\n// Parse a BigInt from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-integer\nfunction parseInteger(buf) {\n  let pos = 0;\n  const end = buf.length;\n  let val = buf[pos];\n  const neg = val > 0x7f;\n  // Consume any padding bytes\n  const pad = neg ? 0xff : 0x00;\n  while (val == pad && ++pos < end) {\n    val = buf[pos];\n  }\n  // Calculate remaining bytes to read\n  const len = end - pos;\n  if (len === 0) return BigInt(neg ? -1 : 0);\n  // Handle two's complement for negative numbers\n  val = neg ? val - 256 : val;\n  // Parse remaining bytes\n  let n = BigInt(val);\n  for (let i = pos + 1; i < end; ++i) {\n    n = n * BigInt(256) + BigInt(buf[i]);\n  }\n  return n;\n}\nexports.parseInteger = parseInteger;\n// Parse an ASCII string from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-basic-types#boolean\nfunction parseStringASCII(buf) {\n  return buf.toString('ascii');\n}\nexports.parseStringASCII = parseStringASCII;\n// Parse a Date from the DER-encoded buffer\n// https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.5.1\nfunction parseTime(buf, shortYear) {\n  const timeStr = parseStringASCII(buf);\n  // Parse the time string into matches - captured groups start at index 1\n  const m = shortYear ? RE_TIME_SHORT_YEAR.exec(timeStr) : RE_TIME_LONG_YEAR.exec(timeStr);\n  if (!m) {\n    throw new Error('invalid time');\n  }\n  // Translate dates with a 2-digit year to 4 digits per the spec\n  if (shortYear) {\n    let year = Number(m[1]);\n    year += year >= 50 ? 1900 : 2000;\n    m[1] = year.toString();\n  }\n  // Translate to ISO8601 format and parse\n  return new Date(`${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}Z`);\n}\nexports.parseTime = parseTime;\n// Parse an OID from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-object-identifier\nfunction parseOID(buf) {\n  let pos = 0;\n  const end = buf.length;\n  // Consume first byte which encodes the first two OID components\n  let n = buf[pos++];\n  const first = Math.floor(n / 40);\n  const second = n % 40;\n  let oid = `${first}.${second}`;\n  // Consume remaining bytes\n  let val = 0;\n  for (; pos < end; ++pos) {\n    n = buf[pos];\n    val = (val << 7) + (n & 0x7f);\n    // If the left-most bit is NOT set, then this is the last byte in the\n    // sequence and we can add the value to the OID and reset the accumulator\n    if ((n & 0x80) === 0) {\n      oid += `.${val}`;\n      val = 0;\n    }\n  }\n  return oid;\n}\nexports.parseOID = parseOID;\n// Parse a boolean from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-basic-types#boolean\nfunction parseBoolean(buf) {\n  return buf[0] !== 0;\n}\nexports.parseBoolean = parseBoolean;\n// Parse a bit string from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-bit-string\nfunction parseBitString(buf) {\n  // First byte tell us how many unused bits are in the last byte\n  const unused = buf[0];\n  const start = 1;\n  const end = buf.length;\n  const bits = [];\n  for (let i = start; i < end; ++i) {\n    const byte = buf[i];\n    // The skip value is only used for the last byte\n    const skip = i === end - 1 ? unused : 0;\n    // Iterate over each bit in the byte (most significant first)\n    for (let j = 7; j >= skip; --j) {\n      // Read the bit and add it to the bit string\n      bits.push(byte >> j & 0x01);\n    }\n  }\n  return bits;\n}\nexports.parseBitString = parseBitString;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseBitString","parseBoolean","parseOID","parseTime","parseStringASCII","parseInteger","RE_TIME_SHORT_YEAR","RE_TIME_LONG_YEAR","buf","pos","end","length","val","neg","pad","len","BigInt","n","i","toString","shortYear","timeStr","m","exec","Error","year","Number","Date","first","Math","floor","second","oid","unused","start","bits","byte","skip","j","push"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/util/asn1/parse.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseBitString = exports.parseBoolean = exports.parseOID = exports.parseTime = exports.parseStringASCII = exports.parseInteger = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst RE_TIME_SHORT_YEAR = /^(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z$/;\nconst RE_TIME_LONG_YEAR = /^(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z$/;\n// Parse a BigInt from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-integer\nfunction parseInteger(buf) {\n    let pos = 0;\n    const end = buf.length;\n    let val = buf[pos];\n    const neg = val > 0x7f;\n    // Consume any padding bytes\n    const pad = neg ? 0xff : 0x00;\n    while (val == pad && ++pos < end) {\n        val = buf[pos];\n    }\n    // Calculate remaining bytes to read\n    const len = end - pos;\n    if (len === 0)\n        return BigInt(neg ? -1 : 0);\n    // Handle two's complement for negative numbers\n    val = neg ? val - 256 : val;\n    // Parse remaining bytes\n    let n = BigInt(val);\n    for (let i = pos + 1; i < end; ++i) {\n        n = n * BigInt(256) + BigInt(buf[i]);\n    }\n    return n;\n}\nexports.parseInteger = parseInteger;\n// Parse an ASCII string from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-basic-types#boolean\nfunction parseStringASCII(buf) {\n    return buf.toString('ascii');\n}\nexports.parseStringASCII = parseStringASCII;\n// Parse a Date from the DER-encoded buffer\n// https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.5.1\nfunction parseTime(buf, shortYear) {\n    const timeStr = parseStringASCII(buf);\n    // Parse the time string into matches - captured groups start at index 1\n    const m = shortYear\n        ? RE_TIME_SHORT_YEAR.exec(timeStr)\n        : RE_TIME_LONG_YEAR.exec(timeStr);\n    if (!m) {\n        throw new Error('invalid time');\n    }\n    // Translate dates with a 2-digit year to 4 digits per the spec\n    if (shortYear) {\n        let year = Number(m[1]);\n        year += year >= 50 ? 1900 : 2000;\n        m[1] = year.toString();\n    }\n    // Translate to ISO8601 format and parse\n    return new Date(`${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}Z`);\n}\nexports.parseTime = parseTime;\n// Parse an OID from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-object-identifier\nfunction parseOID(buf) {\n    let pos = 0;\n    const end = buf.length;\n    // Consume first byte which encodes the first two OID components\n    let n = buf[pos++];\n    const first = Math.floor(n / 40);\n    const second = n % 40;\n    let oid = `${first}.${second}`;\n    // Consume remaining bytes\n    let val = 0;\n    for (; pos < end; ++pos) {\n        n = buf[pos];\n        val = (val << 7) + (n & 0x7f);\n        // If the left-most bit is NOT set, then this is the last byte in the\n        // sequence and we can add the value to the OID and reset the accumulator\n        if ((n & 0x80) === 0) {\n            oid += `.${val}`;\n            val = 0;\n        }\n    }\n    return oid;\n}\nexports.parseOID = parseOID;\n// Parse a boolean from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-basic-types#boolean\nfunction parseBoolean(buf) {\n    return buf[0] !== 0;\n}\nexports.parseBoolean = parseBoolean;\n// Parse a bit string from the DER-encoded buffer\n// https://learn.microsoft.com/en-us/windows/win32/seccertenroll/about-bit-string\nfunction parseBitString(buf) {\n    // First byte tell us how many unused bits are in the last byte\n    const unused = buf[0];\n    const start = 1;\n    const end = buf.length;\n    const bits = [];\n    for (let i = start; i < end; ++i) {\n        const byte = buf[i];\n        // The skip value is only used for the last byte\n        const skip = i === end - 1 ? unused : 0;\n        // Iterate over each bit in the byte (most significant first)\n        for (let j = 7; j >= skip; --j) {\n            // Read the bit and add it to the bit string\n            bits.push((byte >> j) & 0x01);\n        }\n    }\n    return bits;\n}\nexports.parseBitString = parseBitString;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,cAAc,GAAGF,OAAO,CAACG,YAAY,GAAGH,OAAO,CAACI,QAAQ,GAAGJ,OAAO,CAACK,SAAS,GAAGL,OAAO,CAACM,gBAAgB,GAAGN,OAAO,CAACO,YAAY,GAAG,KAAK,CAAC;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,kBAAkB,GAAG,+CAA+C;AAC1E,MAAMC,iBAAiB,GAAG,+CAA+C;AACzE;AACA;AACA,SAASF,YAAYA,CAACG,GAAG,EAAE;EACvB,IAAIC,GAAG,GAAG,CAAC;EACX,MAAMC,GAAG,GAAGF,GAAG,CAACG,MAAM;EACtB,IAAIC,GAAG,GAAGJ,GAAG,CAACC,GAAG,CAAC;EAClB,MAAMI,GAAG,GAAGD,GAAG,GAAG,IAAI;EACtB;EACA,MAAME,GAAG,GAAGD,GAAG,GAAG,IAAI,GAAG,IAAI;EAC7B,OAAOD,GAAG,IAAIE,GAAG,IAAI,EAAEL,GAAG,GAAGC,GAAG,EAAE;IAC9BE,GAAG,GAAGJ,GAAG,CAACC,GAAG,CAAC;EAClB;EACA;EACA,MAAMM,GAAG,GAAGL,GAAG,GAAGD,GAAG;EACrB,IAAIM,GAAG,KAAK,CAAC,EACT,OAAOC,MAAM,CAACH,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;EAC/B;EACAD,GAAG,GAAGC,GAAG,GAAGD,GAAG,GAAG,GAAG,GAAGA,GAAG;EAC3B;EACA,IAAIK,CAAC,GAAGD,MAAM,CAACJ,GAAG,CAAC;EACnB,KAAK,IAAIM,CAAC,GAAGT,GAAG,GAAG,CAAC,EAAES,CAAC,GAAGR,GAAG,EAAE,EAAEQ,CAAC,EAAE;IAChCD,CAAC,GAAGA,CAAC,GAAGD,MAAM,CAAC,GAAG,CAAC,GAAGA,MAAM,CAACR,GAAG,CAACU,CAAC,CAAC,CAAC;EACxC;EACA,OAAOD,CAAC;AACZ;AACAnB,OAAO,CAACO,YAAY,GAAGA,YAAY;AACnC;AACA;AACA,SAASD,gBAAgBA,CAACI,GAAG,EAAE;EAC3B,OAAOA,GAAG,CAACW,QAAQ,CAAC,OAAO,CAAC;AAChC;AACArB,OAAO,CAACM,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA,SAASD,SAASA,CAACK,GAAG,EAAEY,SAAS,EAAE;EAC/B,MAAMC,OAAO,GAAGjB,gBAAgB,CAACI,GAAG,CAAC;EACrC;EACA,MAAMc,CAAC,GAAGF,SAAS,GACbd,kBAAkB,CAACiB,IAAI,CAACF,OAAO,CAAC,GAChCd,iBAAiB,CAACgB,IAAI,CAACF,OAAO,CAAC;EACrC,IAAI,CAACC,CAAC,EAAE;IACJ,MAAM,IAAIE,KAAK,CAAC,cAAc,CAAC;EACnC;EACA;EACA,IAAIJ,SAAS,EAAE;IACX,IAAIK,IAAI,GAAGC,MAAM,CAACJ,CAAC,CAAC,CAAC,CAAC,CAAC;IACvBG,IAAI,IAAIA,IAAI,IAAI,EAAE,GAAG,IAAI,GAAG,IAAI;IAChCH,CAAC,CAAC,CAAC,CAAC,GAAGG,IAAI,CAACN,QAAQ,CAAC,CAAC;EAC1B;EACA;EACA,OAAO,IAAIQ,IAAI,CAAE,GAAEL,CAAC,CAAC,CAAC,CAAE,IAAGA,CAAC,CAAC,CAAC,CAAE,IAAGA,CAAC,CAAC,CAAC,CAAE,IAAGA,CAAC,CAAC,CAAC,CAAE,IAAGA,CAAC,CAAC,CAAC,CAAE,IAAGA,CAAC,CAAC,CAAC,CAAE,GAAE,CAAC;AACvE;AACAxB,OAAO,CAACK,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA,SAASD,QAAQA,CAACM,GAAG,EAAE;EACnB,IAAIC,GAAG,GAAG,CAAC;EACX,MAAMC,GAAG,GAAGF,GAAG,CAACG,MAAM;EACtB;EACA,IAAIM,CAAC,GAAGT,GAAG,CAACC,GAAG,EAAE,CAAC;EAClB,MAAMmB,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACb,CAAC,GAAG,EAAE,CAAC;EAChC,MAAMc,MAAM,GAAGd,CAAC,GAAG,EAAE;EACrB,IAAIe,GAAG,GAAI,GAAEJ,KAAM,IAAGG,MAAO,EAAC;EAC9B;EACA,IAAInB,GAAG,GAAG,CAAC;EACX,OAAOH,GAAG,GAAGC,GAAG,EAAE,EAAED,GAAG,EAAE;IACrBQ,CAAC,GAAGT,GAAG,CAACC,GAAG,CAAC;IACZG,GAAG,GAAG,CAACA,GAAG,IAAI,CAAC,KAAKK,CAAC,GAAG,IAAI,CAAC;IAC7B;IACA;IACA,IAAI,CAACA,CAAC,GAAG,IAAI,MAAM,CAAC,EAAE;MAClBe,GAAG,IAAK,IAAGpB,GAAI,EAAC;MAChBA,GAAG,GAAG,CAAC;IACX;EACJ;EACA,OAAOoB,GAAG;AACd;AACAlC,OAAO,CAACI,QAAQ,GAAGA,QAAQ;AAC3B;AACA;AACA,SAASD,YAAYA,CAACO,GAAG,EAAE;EACvB,OAAOA,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC;AACvB;AACAV,OAAO,CAACG,YAAY,GAAGA,YAAY;AACnC;AACA;AACA,SAASD,cAAcA,CAACQ,GAAG,EAAE;EACzB;EACA,MAAMyB,MAAM,GAAGzB,GAAG,CAAC,CAAC,CAAC;EACrB,MAAM0B,KAAK,GAAG,CAAC;EACf,MAAMxB,GAAG,GAAGF,GAAG,CAACG,MAAM;EACtB,MAAMwB,IAAI,GAAG,EAAE;EACf,KAAK,IAAIjB,CAAC,GAAGgB,KAAK,EAAEhB,CAAC,GAAGR,GAAG,EAAE,EAAEQ,CAAC,EAAE;IAC9B,MAAMkB,IAAI,GAAG5B,GAAG,CAACU,CAAC,CAAC;IACnB;IACA,MAAMmB,IAAI,GAAGnB,CAAC,KAAKR,GAAG,GAAG,CAAC,GAAGuB,MAAM,GAAG,CAAC;IACvC;IACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAID,IAAI,EAAE,EAAEC,CAAC,EAAE;MAC5B;MACAH,IAAI,CAACI,IAAI,CAAEH,IAAI,IAAIE,CAAC,GAAI,IAAI,CAAC;IACjC;EACJ;EACA,OAAOH,IAAI;AACf;AACArC,OAAO,CAACE,cAAc,GAAGA,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}