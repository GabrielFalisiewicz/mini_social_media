{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Fetcher = require('./fetcher.js');\nconst RemoteFetcher = require('./remote.js');\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\nconst pacoteVersion = require('../package.json').version;\nconst removeTrailingSlashes = require('./util/trailing-slashes.js');\nconst rpj = require('read-package-json-fast');\nconst pickManifest = require('npm-pick-manifest');\nconst ssri = require('ssri');\nconst crypto = require('crypto');\nconst npa = require('npm-package-arg');\nconst {\n  sigstore\n} = require('sigstore');\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\nconst fullDoc = 'application/json';\nconst fetch = require('npm-registry-fetch');\nconst _headers = Symbol('_headers');\nclass RegistryFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null;\n    this.registry = fetch.pickRegistry(spec, opts);\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' + this.spec.escapedName;\n    const parsed = new URL(this.registry);\n    const regKey = `//${parsed.host}${parsed.pathname}`;\n    // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`];\n    }\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  resolve() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // fetching the manifest sets resolved and (if present) integrity\n      yield _this.manifest();\n      if (!_this.resolved) {\n        throw Object.assign(new Error('Invalid package manifest: no `dist.tarball` field'), {\n          package: _this.spec.toString()\n        });\n      }\n      return _this.resolved;\n    })();\n  }\n  [_headers]() {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc\n    };\n  }\n  packument() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // note this might be either an in-flight promise for a request,\n      // or the actual packument, but we never want to make more than\n      // one request at a time for the same thing regardless.\n      if (_this2.packumentCache && _this2.packumentCache.has(_this2.packumentUrl)) {\n        return _this2.packumentCache.get(_this2.packumentUrl);\n      }\n\n      // npm-registry-fetch the packument\n      // set the appropriate header for corgis if fullMetadata isn't set\n      // return the res.json() promise\n      try {\n        const res = yield fetch(_this2.packumentUrl, {\n          ..._this2.opts,\n          headers: _this2[_headers](),\n          spec: _this2.spec,\n          // never check integrity for packuments themselves\n          integrity: null\n        });\n        const packument = yield res.json();\n        packument._contentLength = +res.headers.get('content-length');\n        if (_this2.packumentCache) {\n          _this2.packumentCache.set(_this2.packumentUrl, packument);\n        }\n        return packument;\n      } catch (err) {\n        if (_this2.packumentCache) {\n          _this2.packumentCache.delete(_this2.packumentUrl);\n        }\n        if (err.code !== 'E404' || _this2.fullMetadata) {\n          throw err;\n        }\n        // possible that corgis are not supported by this registry\n        _this2.fullMetadata = true;\n        return _this2.packument();\n      }\n    })();\n  }\n  manifest() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.package) {\n        return _this3.package;\n      }\n      const packument = yield _this3.packument();\n      let mani = yield pickManifest(packument, _this3.spec.fetchSpec, {\n        ..._this3.opts,\n        defaultTag: _this3.defaultTag,\n        before: _this3.before\n      });\n      mani = rpj.normalize(mani);\n      /* XXX add ETARGET and E403 revalidation of cached packuments here */\n\n      // add _resolved and _integrity from dist object\n      const {\n        dist\n      } = mani;\n      if (dist) {\n        _this3.resolved = mani._resolved = dist.tarball;\n        mani._from = _this3.from;\n        const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', {\n          ..._this3.opts\n        }) : null;\n        if (distIntegrity) {\n          if (_this3.integrity && !_this3.integrity.match(distIntegrity)) {\n            // only bork if they have algos in common.\n            // otherwise we end up breaking if we have saved a sha512\n            // previously for the tarball, but the manifest only\n            // provides a sha1, which is possible for older publishes.\n            // Otherwise, this is almost certainly a case of holding it\n            // wrong, and will result in weird or insecure behavior\n            // later on when building package tree.\n            for (const algo of Object.keys(_this3.integrity)) {\n              if (distIntegrity[algo]) {\n                throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: ` + `wanted ${_this3.integrity} but got ${distIntegrity}.`), {\n                  code: 'EINTEGRITY'\n                });\n              }\n            }\n          }\n          // made it this far, the integrity is worthwhile.  accept it.\n          // the setter here will take care of merging it into what we already\n          // had.\n          _this3.integrity = distIntegrity;\n        }\n      }\n      if (_this3.integrity) {\n        mani._integrity = String(_this3.integrity);\n        if (dist.signatures) {\n          if (_this3.opts.verifySignatures) {\n            // validate and throw on error, then set _signatures\n            const message = `${mani._id}:${mani._integrity}`;\n            for (const signature of dist.signatures) {\n              const publicKey = _this3.registryKeys && _this3.registryKeys.filter(key => key.keyid === signature.keyid)[0];\n              if (!publicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + 'but no corresponding public key can be found'), {\n                  code: 'EMISSINGSIGNATUREKEY'\n                });\n              }\n              const validPublicKey = !publicKey.expires || Date.parse(publicKey.expires) > Date.now();\n              if (!validPublicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + `but the corresponding public key has expired ${publicKey.expires}`), {\n                  code: 'EEXPIREDSIGNATUREKEY'\n                });\n              }\n              const verifier = crypto.createVerify('SHA256');\n              verifier.write(message);\n              verifier.end();\n              const valid = verifier.verify(publicKey.pemkey, signature.sig, 'base64');\n              if (!valid) {\n                throw Object.assign(new Error(`${mani._id} has an invalid registry signature with ` + `keyid: ${publicKey.keyid} and signature: ${signature.sig}`), {\n                  code: 'EINTEGRITYSIGNATURE',\n                  keyid: publicKey.keyid,\n                  signature: signature.sig,\n                  resolved: mani._resolved,\n                  integrity: mani._integrity\n                });\n              }\n            }\n            mani._signatures = dist.signatures;\n          } else {\n            mani._signatures = dist.signatures;\n          }\n        }\n        if (dist.attestations) {\n          if (_this3.opts.verifyAttestations) {\n            // Always fetch attestations from the current registry host\n            const attestationsPath = new URL(dist.attestations.url).pathname;\n            const attestationsUrl = removeTrailingSlashes(_this3.registry) + attestationsPath;\n            const res = yield fetch(attestationsUrl, {\n              ..._this3.opts,\n              // disable integrity check for attestations json payload, we check the\n              // integrity in the verification steps below\n              integrity: null\n            });\n            const {\n              attestations\n            } = yield res.json();\n            const bundles = attestations.map(({\n              predicateType,\n              bundle\n            }) => {\n              const statement = JSON.parse(Buffer.from(bundle.dsseEnvelope.payload, 'base64').toString('utf8'));\n              const keyid = bundle.dsseEnvelope.signatures[0].keyid;\n              const signature = bundle.dsseEnvelope.signatures[0].sig;\n              return {\n                predicateType,\n                bundle,\n                statement,\n                keyid,\n                signature\n              };\n            });\n            const attestationKeyIds = bundles.map(b => b.keyid).filter(k => !!k);\n            const attestationRegistryKeys = (_this3.registryKeys || []).filter(key => attestationKeyIds.includes(key.keyid));\n            if (!attestationRegistryKeys.length) {\n              throw Object.assign(new Error(`${mani._id} has attestations but no corresponding public key(s) can be found`), {\n                code: 'EMISSINGSIGNATUREKEY'\n              });\n            }\n            for (const {\n              predicateType,\n              bundle,\n              keyid,\n              signature,\n              statement\n            } of bundles) {\n              const publicKey = attestationRegistryKeys.find(key => key.keyid === keyid);\n              // Publish attestations have a keyid set and a valid public key must be found\n              if (keyid) {\n                if (!publicKey) {\n                  throw Object.assign(new Error(`${mani._id} has attestations with keyid: ${keyid} ` + 'but no corresponding public key can be found'), {\n                    code: 'EMISSINGSIGNATUREKEY'\n                  });\n                }\n                const validPublicKey = !publicKey.expires || Date.parse(publicKey.expires) > Date.now();\n                if (!validPublicKey) {\n                  throw Object.assign(new Error(`${mani._id} has attestations with keyid: ${keyid} ` + `but the corresponding public key has expired ${publicKey.expires}`), {\n                    code: 'EEXPIREDSIGNATUREKEY'\n                  });\n                }\n              }\n              const subject = {\n                name: statement.subject[0].name,\n                sha512: statement.subject[0].digest.sha512\n              };\n\n              // Only type 'version' can be turned into a PURL\n              const purl = _this3.spec.type === 'version' ? npa.toPurl(_this3.spec) : _this3.spec;\n              // Verify the statement subject matches the package, version\n              if (subject.name !== purl) {\n                throw Object.assign(new Error(`${mani._id} package name and version (PURL): ${purl} ` + `doesn't match what was signed: ${subject.name}`), {\n                  code: 'EATTESTATIONSUBJECT'\n                });\n              }\n\n              // Verify the statement subject matches the tarball integrity\n              const integrityHexDigest = ssri.parse(_this3.integrity).hexDigest();\n              if (subject.sha512 !== integrityHexDigest) {\n                throw Object.assign(new Error(`${mani._id} package integrity (hex digest): ` + `${integrityHexDigest} ` + `doesn't match what was signed: ${subject.sha512}`), {\n                  code: 'EATTESTATIONSUBJECT'\n                });\n              }\n              try {\n                // Provenance attestations are signed with a signing certificate\n                // (including the key) so we don't need to return a public key.\n                //\n                // Publish attestations are signed with a keyid so we need to\n                // specify a public key from the keys endpoint: `registry-host.tld/-/npm/v1/keys`\n                const options = {\n                  tufCachePath: _this3.tufCache,\n                  keySelector: publicKey ? () => publicKey.pemkey : undefined\n                };\n                yield sigstore.verify(bundle, null, options);\n              } catch (e) {\n                throw Object.assign(new Error(`${mani._id} failed to verify attestation: ${e.message}`), {\n                  code: 'EATTESTATIONVERIFY',\n                  predicateType,\n                  keyid,\n                  signature,\n                  resolved: mani._resolved,\n                  integrity: mani._integrity\n                });\n              }\n            }\n            mani._attestations = dist.attestations;\n          } else {\n            mani._attestations = dist.attestations;\n          }\n        }\n      }\n      _this3.package = mani;\n      return _this3.package;\n    })();\n  }\n  [_tarballFromResolved]() {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`\n    })[_tarballFromResolved]();\n  }\n  get types() {\n    return ['tag', 'version', 'range'];\n  }\n}\nmodule.exports = RegistryFetcher;","map":{"version":3,"names":["Fetcher","require","RemoteFetcher","_tarballFromResolved","Symbol","for","pacoteVersion","version","removeTrailingSlashes","rpj","pickManifest","ssri","crypto","npa","sigstore","corgiDoc","fullDoc","fetch","_headers","RegistryFetcher","constructor","spec","opts","packumentCache","registry","pickRegistry","packumentUrl","escapedName","parsed","URL","regKey","host","pathname","registryKeys","resolve","_this","_asyncToGenerator","manifest","resolved","Object","assign","Error","package","toString","userAgent","process","headers","name","accept","fullMetadata","packument","_this2","has","get","res","integrity","json","_contentLength","set","err","delete","code","_this3","mani","fetchSpec","defaultTag","before","normalize","dist","_resolved","tarball","_from","from","distIntegrity","parse","shasum","fromHex","match","algo","keys","_integrity","String","signatures","verifySignatures","message","_id","signature","publicKey","filter","key","keyid","validPublicKey","expires","Date","now","verifier","createVerify","write","end","valid","verify","pemkey","sig","_signatures","attestations","verifyAttestations","attestationsPath","url","attestationsUrl","bundles","map","predicateType","bundle","statement","JSON","Buffer","dsseEnvelope","payload","attestationKeyIds","b","k","attestationRegistryKeys","includes","length","find","subject","sha512","digest","purl","type","toPurl","integrityHexDigest","hexDigest","options","tufCachePath","tufCache","keySelector","undefined","e","_attestations","pkgid","types","module","exports"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/pacote/lib/registry.js"],"sourcesContent":["const Fetcher = require('./fetcher.js')\nconst RemoteFetcher = require('./remote.js')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\nconst pacoteVersion = require('../package.json').version\nconst removeTrailingSlashes = require('./util/trailing-slashes.js')\nconst rpj = require('read-package-json-fast')\nconst pickManifest = require('npm-pick-manifest')\nconst ssri = require('ssri')\nconst crypto = require('crypto')\nconst npa = require('npm-package-arg')\nconst { sigstore } = require('sigstore')\n\n// Corgis are cute. üêïüê∂\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*'\nconst fullDoc = 'application/json'\n\nconst fetch = require('npm-registry-fetch')\n\nconst _headers = Symbol('_headers')\nclass RegistryFetcher extends Fetcher {\n  constructor (spec, opts) {\n    super(spec, opts)\n\n    // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n    this.packumentCache = this.opts.packumentCache || null\n\n    this.registry = fetch.pickRegistry(spec, opts)\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' +\n      this.spec.escapedName\n\n    const parsed = new URL(this.registry)\n    const regKey = `//${parsed.host}${parsed.pathname}`\n    // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`]\n    }\n\n    // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n  }\n\n  async resolve () {\n    // fetching the manifest sets resolved and (if present) integrity\n    await this.manifest()\n    if (!this.resolved) {\n      throw Object.assign(\n        new Error('Invalid package manifest: no `dist.tarball` field'),\n        { package: this.spec.toString() }\n      )\n    }\n    return this.resolved\n  }\n\n  [_headers] () {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent ||\n        `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc,\n    }\n  }\n\n  async packument () {\n    // note this might be either an in-flight promise for a request,\n    // or the actual packument, but we never want to make more than\n    // one request at a time for the same thing regardless.\n    if (this.packumentCache && this.packumentCache.has(this.packumentUrl)) {\n      return this.packumentCache.get(this.packumentUrl)\n    }\n\n    // npm-registry-fetch the packument\n    // set the appropriate header for corgis if fullMetadata isn't set\n    // return the res.json() promise\n    try {\n      const res = await fetch(this.packumentUrl, {\n        ...this.opts,\n        headers: this[_headers](),\n        spec: this.spec,\n        // never check integrity for packuments themselves\n        integrity: null,\n      })\n      const packument = await res.json()\n      packument._contentLength = +res.headers.get('content-length')\n      if (this.packumentCache) {\n        this.packumentCache.set(this.packumentUrl, packument)\n      }\n      return packument\n    } catch (err) {\n      if (this.packumentCache) {\n        this.packumentCache.delete(this.packumentUrl)\n      }\n      if (err.code !== 'E404' || this.fullMetadata) {\n        throw err\n      }\n      // possible that corgis are not supported by this registry\n      this.fullMetadata = true\n      return this.packument()\n    }\n  }\n\n  async manifest () {\n    if (this.package) {\n      return this.package\n    }\n\n    const packument = await this.packument()\n    let mani = await pickManifest(packument, this.spec.fetchSpec, {\n      ...this.opts,\n      defaultTag: this.defaultTag,\n      before: this.before,\n    })\n    mani = rpj.normalize(mani)\n    /* XXX add ETARGET and E403 revalidation of cached packuments here */\n\n    // add _resolved and _integrity from dist object\n    const { dist } = mani\n    if (dist) {\n      this.resolved = mani._resolved = dist.tarball\n      mani._from = this.from\n      const distIntegrity = dist.integrity ? ssri.parse(dist.integrity)\n        : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ...this.opts })\n        : null\n      if (distIntegrity) {\n        if (this.integrity && !this.integrity.match(distIntegrity)) {\n          // only bork if they have algos in common.\n          // otherwise we end up breaking if we have saved a sha512\n          // previously for the tarball, but the manifest only\n          // provides a sha1, which is possible for older publishes.\n          // Otherwise, this is almost certainly a case of holding it\n          // wrong, and will result in weird or insecure behavior\n          // later on when building package tree.\n          for (const algo of Object.keys(this.integrity)) {\n            if (distIntegrity[algo]) {\n              throw Object.assign(new Error(\n                `Integrity checksum failed when using ${algo}: ` +\n                `wanted ${this.integrity} but got ${distIntegrity}.`\n              ), { code: 'EINTEGRITY' })\n            }\n          }\n        }\n        // made it this far, the integrity is worthwhile.  accept it.\n        // the setter here will take care of merging it into what we already\n        // had.\n        this.integrity = distIntegrity\n      }\n    }\n    if (this.integrity) {\n      mani._integrity = String(this.integrity)\n      if (dist.signatures) {\n        if (this.opts.verifySignatures) {\n          // validate and throw on error, then set _signatures\n          const message = `${mani._id}:${mani._integrity}`\n          for (const signature of dist.signatures) {\n            const publicKey = this.registryKeys &&\n              this.registryKeys.filter(key => (key.keyid === signature.keyid))[0]\n            if (!publicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  'but no corresponding public key can be found'\n              ), { code: 'EMISSINGSIGNATUREKEY' })\n            }\n            const validPublicKey =\n              !publicKey.expires || (Date.parse(publicKey.expires) > Date.now())\n            if (!validPublicKey) {\n              throw Object.assign(new Error(\n                  `${mani._id} has a registry signature with keyid: ${signature.keyid} ` +\n                  `but the corresponding public key has expired ${publicKey.expires}`\n              ), { code: 'EEXPIREDSIGNATUREKEY' })\n            }\n            const verifier = crypto.createVerify('SHA256')\n            verifier.write(message)\n            verifier.end()\n            const valid = verifier.verify(\n              publicKey.pemkey,\n              signature.sig,\n              'base64'\n            )\n            if (!valid) {\n              throw Object.assign(new Error(\n                  `${mani._id} has an invalid registry signature with ` +\n                  `keyid: ${publicKey.keyid} and signature: ${signature.sig}`\n              ), {\n                code: 'EINTEGRITYSIGNATURE',\n                keyid: publicKey.keyid,\n                signature: signature.sig,\n                resolved: mani._resolved,\n                integrity: mani._integrity,\n              })\n            }\n          }\n          mani._signatures = dist.signatures\n        } else {\n          mani._signatures = dist.signatures\n        }\n      }\n\n      if (dist.attestations) {\n        if (this.opts.verifyAttestations) {\n          // Always fetch attestations from the current registry host\n          const attestationsPath = new URL(dist.attestations.url).pathname\n          const attestationsUrl = removeTrailingSlashes(this.registry) + attestationsPath\n          const res = await fetch(attestationsUrl, {\n            ...this.opts,\n            // disable integrity check for attestations json payload, we check the\n            // integrity in the verification steps below\n            integrity: null,\n          })\n          const { attestations } = await res.json()\n          const bundles = attestations.map(({ predicateType, bundle }) => {\n            const statement = JSON.parse(\n              Buffer.from(bundle.dsseEnvelope.payload, 'base64').toString('utf8')\n            )\n            const keyid = bundle.dsseEnvelope.signatures[0].keyid\n            const signature = bundle.dsseEnvelope.signatures[0].sig\n\n            return {\n              predicateType,\n              bundle,\n              statement,\n              keyid,\n              signature,\n            }\n          })\n\n          const attestationKeyIds = bundles.map((b) => b.keyid).filter((k) => !!k)\n          const attestationRegistryKeys = (this.registryKeys || [])\n            .filter(key => attestationKeyIds.includes(key.keyid))\n          if (!attestationRegistryKeys.length) {\n            throw Object.assign(new Error(\n              `${mani._id} has attestations but no corresponding public key(s) can be found`\n            ), { code: 'EMISSINGSIGNATUREKEY' })\n          }\n\n          for (const { predicateType, bundle, keyid, signature, statement } of bundles) {\n            const publicKey = attestationRegistryKeys.find(key => key.keyid === keyid)\n            // Publish attestations have a keyid set and a valid public key must be found\n            if (keyid) {\n              if (!publicKey) {\n                throw Object.assign(new Error(\n                  `${mani._id} has attestations with keyid: ${keyid} ` +\n                  'but no corresponding public key can be found'\n                ), { code: 'EMISSINGSIGNATUREKEY' })\n              }\n\n              const validPublicKey =\n                !publicKey.expires || (Date.parse(publicKey.expires) > Date.now())\n              if (!validPublicKey) {\n                throw Object.assign(new Error(\n                  `${mani._id} has attestations with keyid: ${keyid} ` +\n                  `but the corresponding public key has expired ${publicKey.expires}`\n                ), { code: 'EEXPIREDSIGNATUREKEY' })\n              }\n            }\n\n            const subject = {\n              name: statement.subject[0].name,\n              sha512: statement.subject[0].digest.sha512,\n            }\n\n            // Only type 'version' can be turned into a PURL\n            const purl = this.spec.type === 'version' ? npa.toPurl(this.spec) : this.spec\n            // Verify the statement subject matches the package, version\n            if (subject.name !== purl) {\n              throw Object.assign(new Error(\n                `${mani._id} package name and version (PURL): ${purl} ` +\n                `doesn't match what was signed: ${subject.name}`\n              ), { code: 'EATTESTATIONSUBJECT' })\n            }\n\n            // Verify the statement subject matches the tarball integrity\n            const integrityHexDigest = ssri.parse(this.integrity).hexDigest()\n            if (subject.sha512 !== integrityHexDigest) {\n              throw Object.assign(new Error(\n                `${mani._id} package integrity (hex digest): ` +\n                `${integrityHexDigest} ` +\n                `doesn't match what was signed: ${subject.sha512}`\n              ), { code: 'EATTESTATIONSUBJECT' })\n            }\n\n            try {\n              // Provenance attestations are signed with a signing certificate\n              // (including the key) so we don't need to return a public key.\n              //\n              // Publish attestations are signed with a keyid so we need to\n              // specify a public key from the keys endpoint: `registry-host.tld/-/npm/v1/keys`\n              const options = {\n                tufCachePath: this.tufCache,\n                keySelector: publicKey ? () => publicKey.pemkey : undefined,\n              }\n              await sigstore.verify(bundle, null, options)\n            } catch (e) {\n              throw Object.assign(new Error(\n                `${mani._id} failed to verify attestation: ${e.message}`\n              ), {\n                code: 'EATTESTATIONVERIFY',\n                predicateType,\n                keyid,\n                signature,\n                resolved: mani._resolved,\n                integrity: mani._integrity,\n              })\n            }\n          }\n          mani._attestations = dist.attestations\n        } else {\n          mani._attestations = dist.attestations\n        }\n      }\n    }\n\n    this.package = mani\n    return this.package\n  }\n\n  [_tarballFromResolved] () {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, {\n      ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`,\n    })[_tarballFromResolved]()\n  }\n\n  get types () {\n    return [\n      'tag',\n      'version',\n      'range',\n    ]\n  }\n}\nmodule.exports = RegistryFetcher\n"],"mappings":";AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;AACvC,MAAMC,aAAa,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC5C,MAAME,oBAAoB,GAAGC,MAAM,CAACC,GAAG,CAAC,qCAAqC,CAAC;AAC9E,MAAMC,aAAa,GAAGL,OAAO,CAAC,iBAAiB,CAAC,CAACM,OAAO;AACxD,MAAMC,qBAAqB,GAAGP,OAAO,CAAC,4BAA4B,CAAC;AACnE,MAAMQ,GAAG,GAAGR,OAAO,CAAC,wBAAwB,CAAC;AAC7C,MAAMS,YAAY,GAAGT,OAAO,CAAC,mBAAmB,CAAC;AACjD,MAAMU,IAAI,GAAGV,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMW,MAAM,GAAGX,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMY,GAAG,GAAGZ,OAAO,CAAC,iBAAiB,CAAC;AACtC,MAAM;EAAEa;AAAS,CAAC,GAAGb,OAAO,CAAC,UAAU,CAAC;;AAExC;AACA,MAAMc,QAAQ,GAAG,0EAA0E;AAC3F,MAAMC,OAAO,GAAG,kBAAkB;AAElC,MAAMC,KAAK,GAAGhB,OAAO,CAAC,oBAAoB,CAAC;AAE3C,MAAMiB,QAAQ,GAAGd,MAAM,CAAC,UAAU,CAAC;AACnC,MAAMe,eAAe,SAASnB,OAAO,CAAC;EACpCoB,WAAWA,CAAEC,IAAI,EAAEC,IAAI,EAAE;IACvB,KAAK,CAACD,IAAI,EAAEC,IAAI,CAAC;;IAEjB;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACC,cAAc,GAAG,IAAI,CAACD,IAAI,CAACC,cAAc,IAAI,IAAI;IAEtD,IAAI,CAACC,QAAQ,GAAGP,KAAK,CAACQ,YAAY,CAACJ,IAAI,EAAEC,IAAI,CAAC;IAC9C,IAAI,CAACI,YAAY,GAAGlB,qBAAqB,CAAC,IAAI,CAACgB,QAAQ,CAAC,GAAG,GAAG,GAC5D,IAAI,CAACH,IAAI,CAACM,WAAW;IAEvB,MAAMC,MAAM,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACL,QAAQ,CAAC;IACrC,MAAMM,MAAM,GAAI,KAAIF,MAAM,CAACG,IAAK,GAAEH,MAAM,CAACI,QAAS,EAAC;IACnD;IACA;IACA,IAAI,IAAI,CAACV,IAAI,CAAE,GAAEQ,MAAO,QAAO,CAAC,EAAE;MAChC,IAAI,CAACG,YAAY,GAAG,IAAI,CAACX,IAAI,CAAE,GAAEQ,MAAO,QAAO,CAAC;IAClD;;IAEA;IACA;IACA;IACA;EACF;;EAEMI,OAAOA,CAAA,EAAI;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MACf;MACA,MAAMD,KAAI,CAACE,QAAQ,CAAC,CAAC;MACrB,IAAI,CAACF,KAAI,CAACG,QAAQ,EAAE;QAClB,MAAMC,MAAM,CAACC,MAAM,CACjB,IAAIC,KAAK,CAAC,mDAAmD,CAAC,EAC9D;UAAEC,OAAO,EAAEP,KAAI,CAACd,IAAI,CAACsB,QAAQ,CAAC;QAAE,CAClC,CAAC;MACH;MACA,OAAOR,KAAI,CAACG,QAAQ;IAAA;EACtB;EAEA,CAACpB,QAAQ,IAAK;IACZ,OAAO;MACL;MACA,YAAY,EAAE,IAAI,CAACI,IAAI,CAACsB,SAAS,IAC9B,UAAStC,aAAc,SAAQuC,OAAO,CAACtC,OAAQ,EAAC;MACnD,IAAI,IAAI,CAACe,IAAI,CAACwB,OAAO,IAAI,CAAC,CAAC,CAAC;MAC5B,gBAAgB,EAAExC,aAAa;MAC/B,iBAAiB,EAAE,WAAW;MAC9B,eAAe,EAAG,YAAW,IAAI,CAACe,IAAI,CAAC0B,IAAK,EAAC;MAC7CC,MAAM,EAAE,IAAI,CAACC,YAAY,GAAGjC,OAAO,GAAGD;IACxC,CAAC;EACH;EAEMmC,SAASA,CAAA,EAAI;IAAA,IAAAC,MAAA;IAAA,OAAAf,iBAAA;MACjB;MACA;MACA;MACA,IAAIe,MAAI,CAAC5B,cAAc,IAAI4B,MAAI,CAAC5B,cAAc,CAAC6B,GAAG,CAACD,MAAI,CAACzB,YAAY,CAAC,EAAE;QACrE,OAAOyB,MAAI,CAAC5B,cAAc,CAAC8B,GAAG,CAACF,MAAI,CAACzB,YAAY,CAAC;MACnD;;MAEA;MACA;MACA;MACA,IAAI;QACF,MAAM4B,GAAG,SAASrC,KAAK,CAACkC,MAAI,CAACzB,YAAY,EAAE;UACzC,GAAGyB,MAAI,CAAC7B,IAAI;UACZwB,OAAO,EAAEK,MAAI,CAACjC,QAAQ,CAAC,CAAC,CAAC;UACzBG,IAAI,EAAE8B,MAAI,CAAC9B,IAAI;UACf;UACAkC,SAAS,EAAE;QACb,CAAC,CAAC;QACF,MAAML,SAAS,SAASI,GAAG,CAACE,IAAI,CAAC,CAAC;QAClCN,SAAS,CAACO,cAAc,GAAG,CAACH,GAAG,CAACR,OAAO,CAACO,GAAG,CAAC,gBAAgB,CAAC;QAC7D,IAAIF,MAAI,CAAC5B,cAAc,EAAE;UACvB4B,MAAI,CAAC5B,cAAc,CAACmC,GAAG,CAACP,MAAI,CAACzB,YAAY,EAAEwB,SAAS,CAAC;QACvD;QACA,OAAOA,SAAS;MAClB,CAAC,CAAC,OAAOS,GAAG,EAAE;QACZ,IAAIR,MAAI,CAAC5B,cAAc,EAAE;UACvB4B,MAAI,CAAC5B,cAAc,CAACqC,MAAM,CAACT,MAAI,CAACzB,YAAY,CAAC;QAC/C;QACA,IAAIiC,GAAG,CAACE,IAAI,KAAK,MAAM,IAAIV,MAAI,CAACF,YAAY,EAAE;UAC5C,MAAMU,GAAG;QACX;QACA;QACAR,MAAI,CAACF,YAAY,GAAG,IAAI;QACxB,OAAOE,MAAI,CAACD,SAAS,CAAC,CAAC;MACzB;IAAC;EACH;EAEMb,QAAQA,CAAA,EAAI;IAAA,IAAAyB,MAAA;IAAA,OAAA1B,iBAAA;MAChB,IAAI0B,MAAI,CAACpB,OAAO,EAAE;QAChB,OAAOoB,MAAI,CAACpB,OAAO;MACrB;MAEA,MAAMQ,SAAS,SAASY,MAAI,CAACZ,SAAS,CAAC,CAAC;MACxC,IAAIa,IAAI,SAASrD,YAAY,CAACwC,SAAS,EAAEY,MAAI,CAACzC,IAAI,CAAC2C,SAAS,EAAE;QAC5D,GAAGF,MAAI,CAACxC,IAAI;QACZ2C,UAAU,EAAEH,MAAI,CAACG,UAAU;QAC3BC,MAAM,EAAEJ,MAAI,CAACI;MACf,CAAC,CAAC;MACFH,IAAI,GAAGtD,GAAG,CAAC0D,SAAS,CAACJ,IAAI,CAAC;MAC1B;;MAEA;MACA,MAAM;QAAEK;MAAK,CAAC,GAAGL,IAAI;MACrB,IAAIK,IAAI,EAAE;QACRN,MAAI,CAACxB,QAAQ,GAAGyB,IAAI,CAACM,SAAS,GAAGD,IAAI,CAACE,OAAO;QAC7CP,IAAI,CAACQ,KAAK,GAAGT,MAAI,CAACU,IAAI;QACtB,MAAMC,aAAa,GAAGL,IAAI,CAACb,SAAS,GAAG5C,IAAI,CAAC+D,KAAK,CAACN,IAAI,CAACb,SAAS,CAAC,GAC7Da,IAAI,CAACO,MAAM,GAAGhE,IAAI,CAACiE,OAAO,CAACR,IAAI,CAACO,MAAM,EAAE,MAAM,EAAE;UAAE,GAAGb,MAAI,CAACxC;QAAK,CAAC,CAAC,GACjE,IAAI;QACR,IAAImD,aAAa,EAAE;UACjB,IAAIX,MAAI,CAACP,SAAS,IAAI,CAACO,MAAI,CAACP,SAAS,CAACsB,KAAK,CAACJ,aAAa,CAAC,EAAE;YAC1D;YACA;YACA;YACA;YACA;YACA;YACA;YACA,KAAK,MAAMK,IAAI,IAAIvC,MAAM,CAACwC,IAAI,CAACjB,MAAI,CAACP,SAAS,CAAC,EAAE;cAC9C,IAAIkB,aAAa,CAACK,IAAI,CAAC,EAAE;gBACvB,MAAMvC,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,wCAAuCqC,IAAK,IAAG,GAC/C,UAAShB,MAAI,CAACP,SAAU,YAAWkB,aAAc,GACpD,CAAC,EAAE;kBAAEZ,IAAI,EAAE;gBAAa,CAAC,CAAC;cAC5B;YACF;UACF;UACA;UACA;UACA;UACAC,MAAI,CAACP,SAAS,GAAGkB,aAAa;QAChC;MACF;MACA,IAAIX,MAAI,CAACP,SAAS,EAAE;QAClBQ,IAAI,CAACiB,UAAU,GAAGC,MAAM,CAACnB,MAAI,CAACP,SAAS,CAAC;QACxC,IAAIa,IAAI,CAACc,UAAU,EAAE;UACnB,IAAIpB,MAAI,CAACxC,IAAI,CAAC6D,gBAAgB,EAAE;YAC9B;YACA,MAAMC,OAAO,GAAI,GAAErB,IAAI,CAACsB,GAAI,IAAGtB,IAAI,CAACiB,UAAW,EAAC;YAChD,KAAK,MAAMM,SAAS,IAAIlB,IAAI,CAACc,UAAU,EAAE;cACvC,MAAMK,SAAS,GAAGzB,MAAI,CAAC7B,YAAY,IACjC6B,MAAI,CAAC7B,YAAY,CAACuD,MAAM,CAACC,GAAG,IAAKA,GAAG,CAACC,KAAK,KAAKJ,SAAS,CAACI,KAAM,CAAC,CAAC,CAAC,CAAC;cACrE,IAAI,CAACH,SAAS,EAAE;gBACd,MAAMhD,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CACxB,GAAEsB,IAAI,CAACsB,GAAI,yCAAwCC,SAAS,CAACI,KAAM,GAAE,GACtE,8CACJ,CAAC,EAAE;kBAAE7B,IAAI,EAAE;gBAAuB,CAAC,CAAC;cACtC;cACA,MAAM8B,cAAc,GAClB,CAACJ,SAAS,CAACK,OAAO,IAAKC,IAAI,CAACnB,KAAK,CAACa,SAAS,CAACK,OAAO,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAE;cACpE,IAAI,CAACH,cAAc,EAAE;gBACnB,MAAMpD,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CACxB,GAAEsB,IAAI,CAACsB,GAAI,yCAAwCC,SAAS,CAACI,KAAM,GAAE,GACrE,gDAA+CH,SAAS,CAACK,OAAQ,EACtE,CAAC,EAAE;kBAAE/B,IAAI,EAAE;gBAAuB,CAAC,CAAC;cACtC;cACA,MAAMkC,QAAQ,GAAGnF,MAAM,CAACoF,YAAY,CAAC,QAAQ,CAAC;cAC9CD,QAAQ,CAACE,KAAK,CAACb,OAAO,CAAC;cACvBW,QAAQ,CAACG,GAAG,CAAC,CAAC;cACd,MAAMC,KAAK,GAAGJ,QAAQ,CAACK,MAAM,CAC3Bb,SAAS,CAACc,MAAM,EAChBf,SAAS,CAACgB,GAAG,EACb,QACF,CAAC;cACD,IAAI,CAACH,KAAK,EAAE;gBACV,MAAM5D,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CACxB,GAAEsB,IAAI,CAACsB,GAAI,0CAAyC,GACpD,UAASE,SAAS,CAACG,KAAM,mBAAkBJ,SAAS,CAACgB,GAAI,EAC9D,CAAC,EAAE;kBACDzC,IAAI,EAAE,qBAAqB;kBAC3B6B,KAAK,EAAEH,SAAS,CAACG,KAAK;kBACtBJ,SAAS,EAAEA,SAAS,CAACgB,GAAG;kBACxBhE,QAAQ,EAAEyB,IAAI,CAACM,SAAS;kBACxBd,SAAS,EAAEQ,IAAI,CAACiB;gBAClB,CAAC,CAAC;cACJ;YACF;YACAjB,IAAI,CAACwC,WAAW,GAAGnC,IAAI,CAACc,UAAU;UACpC,CAAC,MAAM;YACLnB,IAAI,CAACwC,WAAW,GAAGnC,IAAI,CAACc,UAAU;UACpC;QACF;QAEA,IAAId,IAAI,CAACoC,YAAY,EAAE;UACrB,IAAI1C,MAAI,CAACxC,IAAI,CAACmF,kBAAkB,EAAE;YAChC;YACA,MAAMC,gBAAgB,GAAG,IAAI7E,GAAG,CAACuC,IAAI,CAACoC,YAAY,CAACG,GAAG,CAAC,CAAC3E,QAAQ;YAChE,MAAM4E,eAAe,GAAGpG,qBAAqB,CAACsD,MAAI,CAACtC,QAAQ,CAAC,GAAGkF,gBAAgB;YAC/E,MAAMpD,GAAG,SAASrC,KAAK,CAAC2F,eAAe,EAAE;cACvC,GAAG9C,MAAI,CAACxC,IAAI;cACZ;cACA;cACAiC,SAAS,EAAE;YACb,CAAC,CAAC;YACF,MAAM;cAAEiD;YAAa,CAAC,SAASlD,GAAG,CAACE,IAAI,CAAC,CAAC;YACzC,MAAMqD,OAAO,GAAGL,YAAY,CAACM,GAAG,CAAC,CAAC;cAAEC,aAAa;cAAEC;YAAO,CAAC,KAAK;cAC9D,MAAMC,SAAS,GAAGC,IAAI,CAACxC,KAAK,CAC1ByC,MAAM,CAAC3C,IAAI,CAACwC,MAAM,CAACI,YAAY,CAACC,OAAO,EAAE,QAAQ,CAAC,CAAC1E,QAAQ,CAAC,MAAM,CACpE,CAAC;cACD,MAAM+C,KAAK,GAAGsB,MAAM,CAACI,YAAY,CAAClC,UAAU,CAAC,CAAC,CAAC,CAACQ,KAAK;cACrD,MAAMJ,SAAS,GAAG0B,MAAM,CAACI,YAAY,CAAClC,UAAU,CAAC,CAAC,CAAC,CAACoB,GAAG;cAEvD,OAAO;gBACLS,aAAa;gBACbC,MAAM;gBACNC,SAAS;gBACTvB,KAAK;gBACLJ;cACF,CAAC;YACH,CAAC,CAAC;YAEF,MAAMgC,iBAAiB,GAAGT,OAAO,CAACC,GAAG,CAAES,CAAC,IAAKA,CAAC,CAAC7B,KAAK,CAAC,CAACF,MAAM,CAAEgC,CAAC,IAAK,CAAC,CAACA,CAAC,CAAC;YACxE,MAAMC,uBAAuB,GAAG,CAAC3D,MAAI,CAAC7B,YAAY,IAAI,EAAE,EACrDuD,MAAM,CAACC,GAAG,IAAI6B,iBAAiB,CAACI,QAAQ,CAACjC,GAAG,CAACC,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC+B,uBAAuB,CAACE,MAAM,EAAE;cACnC,MAAMpF,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,GAAEsB,IAAI,CAACsB,GAAI,mEACd,CAAC,EAAE;gBAAExB,IAAI,EAAE;cAAuB,CAAC,CAAC;YACtC;YAEA,KAAK,MAAM;cAAEkD,aAAa;cAAEC,MAAM;cAAEtB,KAAK;cAAEJ,SAAS;cAAE2B;YAAU,CAAC,IAAIJ,OAAO,EAAE;cAC5E,MAAMtB,SAAS,GAAGkC,uBAAuB,CAACG,IAAI,CAACnC,GAAG,IAAIA,GAAG,CAACC,KAAK,KAAKA,KAAK,CAAC;cAC1E;cACA,IAAIA,KAAK,EAAE;gBACT,IAAI,CAACH,SAAS,EAAE;kBACd,MAAMhD,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,GAAEsB,IAAI,CAACsB,GAAI,iCAAgCK,KAAM,GAAE,GACpD,8CACF,CAAC,EAAE;oBAAE7B,IAAI,EAAE;kBAAuB,CAAC,CAAC;gBACtC;gBAEA,MAAM8B,cAAc,GAClB,CAACJ,SAAS,CAACK,OAAO,IAAKC,IAAI,CAACnB,KAAK,CAACa,SAAS,CAACK,OAAO,CAAC,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAE;gBACpE,IAAI,CAACH,cAAc,EAAE;kBACnB,MAAMpD,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,GAAEsB,IAAI,CAACsB,GAAI,iCAAgCK,KAAM,GAAE,GACnD,gDAA+CH,SAAS,CAACK,OAAQ,EACpE,CAAC,EAAE;oBAAE/B,IAAI,EAAE;kBAAuB,CAAC,CAAC;gBACtC;cACF;cAEA,MAAMgE,OAAO,GAAG;gBACd9E,IAAI,EAAEkE,SAAS,CAACY,OAAO,CAAC,CAAC,CAAC,CAAC9E,IAAI;gBAC/B+E,MAAM,EAAEb,SAAS,CAACY,OAAO,CAAC,CAAC,CAAC,CAACE,MAAM,CAACD;cACtC,CAAC;;cAED;cACA,MAAME,IAAI,GAAGlE,MAAI,CAACzC,IAAI,CAAC4G,IAAI,KAAK,SAAS,GAAGpH,GAAG,CAACqH,MAAM,CAACpE,MAAI,CAACzC,IAAI,CAAC,GAAGyC,MAAI,CAACzC,IAAI;cAC7E;cACA,IAAIwG,OAAO,CAAC9E,IAAI,KAAKiF,IAAI,EAAE;gBACzB,MAAMzF,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,GAAEsB,IAAI,CAACsB,GAAI,qCAAoC2C,IAAK,GAAE,GACtD,kCAAiCH,OAAO,CAAC9E,IAAK,EACjD,CAAC,EAAE;kBAAEc,IAAI,EAAE;gBAAsB,CAAC,CAAC;cACrC;;cAEA;cACA,MAAMsE,kBAAkB,GAAGxH,IAAI,CAAC+D,KAAK,CAACZ,MAAI,CAACP,SAAS,CAAC,CAAC6E,SAAS,CAAC,CAAC;cACjE,IAAIP,OAAO,CAACC,MAAM,KAAKK,kBAAkB,EAAE;gBACzC,MAAM5F,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,GAAEsB,IAAI,CAACsB,GAAI,mCAAkC,GAC7C,GAAE8C,kBAAmB,GAAE,GACvB,kCAAiCN,OAAO,CAACC,MAAO,EACnD,CAAC,EAAE;kBAAEjE,IAAI,EAAE;gBAAsB,CAAC,CAAC;cACrC;cAEA,IAAI;gBACF;gBACA;gBACA;gBACA;gBACA;gBACA,MAAMwE,OAAO,GAAG;kBACdC,YAAY,EAAExE,MAAI,CAACyE,QAAQ;kBAC3BC,WAAW,EAAEjD,SAAS,GAAG,MAAMA,SAAS,CAACc,MAAM,GAAGoC;gBACpD,CAAC;gBACD,MAAM3H,QAAQ,CAACsF,MAAM,CAACY,MAAM,EAAE,IAAI,EAAEqB,OAAO,CAAC;cAC9C,CAAC,CAAC,OAAOK,CAAC,EAAE;gBACV,MAAMnG,MAAM,CAACC,MAAM,CAAC,IAAIC,KAAK,CAC1B,GAAEsB,IAAI,CAACsB,GAAI,kCAAiCqD,CAAC,CAACtD,OAAQ,EACzD,CAAC,EAAE;kBACDvB,IAAI,EAAE,oBAAoB;kBAC1BkD,aAAa;kBACbrB,KAAK;kBACLJ,SAAS;kBACThD,QAAQ,EAAEyB,IAAI,CAACM,SAAS;kBACxBd,SAAS,EAAEQ,IAAI,CAACiB;gBAClB,CAAC,CAAC;cACJ;YACF;YACAjB,IAAI,CAAC4E,aAAa,GAAGvE,IAAI,CAACoC,YAAY;UACxC,CAAC,MAAM;YACLzC,IAAI,CAAC4E,aAAa,GAAGvE,IAAI,CAACoC,YAAY;UACxC;QACF;MACF;MAEA1C,MAAI,CAACpB,OAAO,GAAGqB,IAAI;MACnB,OAAOD,MAAI,CAACpB,OAAO;IAAA;EACrB;EAEA,CAACvC,oBAAoB,IAAK;IACxB;IACA,OAAO,IAAID,aAAa,CAAC,IAAI,CAACoC,QAAQ,EAAE;MACtC,GAAG,IAAI,CAAChB,IAAI;MACZgB,QAAQ,EAAE,IAAI,CAACA,QAAQ;MACvBsG,KAAK,EAAG,YAAW,IAAI,CAACvH,IAAI,CAAC0B,IAAK,IAAG,IAAI,CAACT,QAAS;IACrD,CAAC,CAAC,CAACnC,oBAAoB,CAAC,CAAC,CAAC;EAC5B;EAEA,IAAI0I,KAAKA,CAAA,EAAI;IACX,OAAO,CACL,KAAK,EACL,SAAS,EACT,OAAO,CACR;EACH;AACF;AACAC,MAAM,CAACC,OAAO,GAAG5H,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}