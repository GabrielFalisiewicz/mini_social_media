{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifySignerIdentity = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst error_1 = require(\"../../error\");\nconst sigstore = __importStar(require(\"../../types/sigstore\"));\n// https://github.com/sigstore/fulcio/blob/main/docs/oid-info.md#1361415726411--issuer\nconst OID_FULCIO_ISSUER = '1.3.6.1.4.1.57264.1.1';\n// https://github.com/sigstore/fulcio/blob/main/docs/oid-info.md#1361415726417--othername-san\nconst OID_FULCIO_USERNAME_SUBJECT = '1.3.6.1.4.1.57264.1.7';\n// Verifies the identity embedded in a Fulcio-issued signing certificate against\n// the list of trusted identities. Returns without error if at least one of the\n// identities matches the signing certificate; otherwise, throws a\n// VerificationError.\nfunction verifySignerIdentity(signingCert, identities) {\n  // Check that the signing certificate was issued to at least one of the\n  // specified identities\n  const signerVerified = identities.identities.some(identity => verifyIdentity(signingCert, identity));\n  if (!signerVerified) {\n    throw new error_1.PolicyError('Certificate issued to untrusted signer');\n  }\n}\nexports.verifySignerIdentity = verifySignerIdentity;\n// Checks that the specified certificate was issued to the specified identity.\n// The certificate must match the issuer, subject alternative name, and an\n// optional list of certificate extensions. Returns true if the certificate was\n// issued to the identity; otherwise, returns false.\nfunction verifyIdentity(cert, identity) {\n  return verifyIssuer(cert, identity.issuer) && verifySAN(cert, identity.san) && verifyOIDs(cert, identity.oids);\n}\n// Checks the Fulcio issuer extension against the expected issuer. Returns true\n// if the issuer matches; otherwise, returns false.\nfunction verifyIssuer(cert, issuer) {\n  const issuerExtension = cert.extension(OID_FULCIO_ISSUER);\n  return issuerExtension?.value.toString('ascii') === issuer;\n}\n// Checks the certificate against the expected subject alternative name. Returns\n// true if the SAN matches; otherwise, returns false.\nfunction verifySAN(cert, expectedSAN) {\n  // Fail if the SAN is not specified or is not a supported type\n  if (expectedSAN === undefined || expectedSAN.identity === undefined || expectedSAN.type === sigstore.SubjectAlternativeNameType.SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED) {\n    return false;\n  }\n  const sanExtension = cert.extSubjectAltName;\n  // Fail if the certificate does not have a SAN extension\n  if (!sanExtension) {\n    return false;\n  }\n  let sanValue;\n  switch (expectedSAN.type) {\n    case sigstore.SubjectAlternativeNameType.EMAIL:\n      sanValue = sanExtension.rfc822Name;\n      break;\n    case sigstore.SubjectAlternativeNameType.URI:\n      sanValue = sanExtension.uri;\n      break;\n    case sigstore.SubjectAlternativeNameType.OTHER_NAME:\n      sanValue = sanExtension.otherName(OID_FULCIO_USERNAME_SUBJECT);\n      break;\n  }\n  // Missing SAN value is an automatic failure\n  if (sanValue === undefined) {\n    return false;\n  }\n  let match;\n  switch (expectedSAN.identity.$case) {\n    case 'value':\n      match = expectedSAN.identity.value;\n      break;\n    case 'regexp':\n      // TODO support regex\n      break;\n  }\n  return sanValue === match;\n}\n// Checks that the certificate contains the specified extensions. Returns true\n// if all extensions are present and match the expected values; otherwise,\n// returns false.\nfunction verifyOIDs(cert, oids) {\n  return oids.every(expectedExtension => {\n    if (!expectedExtension.oid) {\n      return false;\n    }\n    const oid = expectedExtension.oid.id.join('.');\n    const extension = cert.extension(oid);\n    // If the extension is not present, or there is no value, return false\n    const valueObj = extension?.valueObj;\n    if (!valueObj) {\n      return false;\n    }\n    // Check to see if this is a newer style extension with an embedded\n    // UTF8String, or an older style extension with a raw string\n    if (valueObj.subs.length > 0) {\n      return valueObj.subs[0].value.equals(expectedExtension.value);\n    } else {\n      return valueObj.value.equals(expectedExtension.value);\n    }\n  });\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","verifySignerIdentity","error_1","require","sigstore","OID_FULCIO_ISSUER","OID_FULCIO_USERNAME_SUBJECT","signingCert","identities","signerVerified","some","identity","verifyIdentity","PolicyError","cert","verifyIssuer","issuer","verifySAN","san","verifyOIDs","oids","issuerExtension","extension","toString","expectedSAN","type","SubjectAlternativeNameType","SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED","sanExtension","extSubjectAltName","sanValue","EMAIL","rfc822Name","URI","uri","OTHER_NAME","otherName","match","$case","every","expectedExtension","oid","id","join","valueObj","subs","length","equals"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/ca/verify/signer.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifySignerIdentity = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst error_1 = require(\"../../error\");\nconst sigstore = __importStar(require(\"../../types/sigstore\"));\n// https://github.com/sigstore/fulcio/blob/main/docs/oid-info.md#1361415726411--issuer\nconst OID_FULCIO_ISSUER = '1.3.6.1.4.1.57264.1.1';\n// https://github.com/sigstore/fulcio/blob/main/docs/oid-info.md#1361415726417--othername-san\nconst OID_FULCIO_USERNAME_SUBJECT = '1.3.6.1.4.1.57264.1.7';\n// Verifies the identity embedded in a Fulcio-issued signing certificate against\n// the list of trusted identities. Returns without error if at least one of the\n// identities matches the signing certificate; otherwise, throws a\n// VerificationError.\nfunction verifySignerIdentity(signingCert, identities) {\n    // Check that the signing certificate was issued to at least one of the\n    // specified identities\n    const signerVerified = identities.identities.some((identity) => verifyIdentity(signingCert, identity));\n    if (!signerVerified) {\n        throw new error_1.PolicyError('Certificate issued to untrusted signer');\n    }\n}\nexports.verifySignerIdentity = verifySignerIdentity;\n// Checks that the specified certificate was issued to the specified identity.\n// The certificate must match the issuer, subject alternative name, and an\n// optional list of certificate extensions. Returns true if the certificate was\n// issued to the identity; otherwise, returns false.\nfunction verifyIdentity(cert, identity) {\n    return (verifyIssuer(cert, identity.issuer) &&\n        verifySAN(cert, identity.san) &&\n        verifyOIDs(cert, identity.oids));\n}\n// Checks the Fulcio issuer extension against the expected issuer. Returns true\n// if the issuer matches; otherwise, returns false.\nfunction verifyIssuer(cert, issuer) {\n    const issuerExtension = cert.extension(OID_FULCIO_ISSUER);\n    return issuerExtension?.value.toString('ascii') === issuer;\n}\n// Checks the certificate against the expected subject alternative name. Returns\n// true if the SAN matches; otherwise, returns false.\nfunction verifySAN(cert, expectedSAN) {\n    // Fail if the SAN is not specified or is not a supported type\n    if (expectedSAN === undefined ||\n        expectedSAN.identity === undefined ||\n        expectedSAN.type ===\n            sigstore.SubjectAlternativeNameType\n                .SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED) {\n        return false;\n    }\n    const sanExtension = cert.extSubjectAltName;\n    // Fail if the certificate does not have a SAN extension\n    if (!sanExtension) {\n        return false;\n    }\n    let sanValue;\n    switch (expectedSAN.type) {\n        case sigstore.SubjectAlternativeNameType.EMAIL:\n            sanValue = sanExtension.rfc822Name;\n            break;\n        case sigstore.SubjectAlternativeNameType.URI:\n            sanValue = sanExtension.uri;\n            break;\n        case sigstore.SubjectAlternativeNameType.OTHER_NAME:\n            sanValue = sanExtension.otherName(OID_FULCIO_USERNAME_SUBJECT);\n            break;\n    }\n    // Missing SAN value is an automatic failure\n    if (sanValue === undefined) {\n        return false;\n    }\n    let match;\n    switch (expectedSAN.identity.$case) {\n        case 'value':\n            match = expectedSAN.identity.value;\n            break;\n        case 'regexp':\n            // TODO support regex\n            break;\n    }\n    return sanValue === match;\n}\n// Checks that the certificate contains the specified extensions. Returns true\n// if all extensions are present and match the expected values; otherwise,\n// returns false.\nfunction verifyOIDs(cert, oids) {\n    return oids.every((expectedExtension) => {\n        if (!expectedExtension.oid) {\n            return false;\n        }\n        const oid = expectedExtension.oid.id.join('.');\n        const extension = cert.extension(oid);\n        // If the extension is not present, or there is no value, return false\n        const valueObj = extension?.valueObj;\n        if (!valueObj) {\n            return false;\n        }\n        // Check to see if this is a newer style extension with an embedded\n        // UTF8String, or an older style extension with a raw string\n        if (valueObj.subs.length > 0) {\n            return valueObj.subs[0].value.equals(expectedExtension.value);\n        }\n        else {\n            return valueObj.value.equals(expectedExtension.value);\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}