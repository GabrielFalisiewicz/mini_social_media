{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst api_1 = require(\"./api\");\nconst exception_1 = require(\"./exception\");\nclass JobArgumentSchemaValidationError extends core_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Argument failed to validate. Errors: ');\n  }\n}\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\nclass JobInboundMessageSchemaValidationError extends core_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Inbound Message failed to validate. Errors: ');\n  }\n}\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\nclass JobOutputSchemaValidationError extends core_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Output failed to validate. Errors: ');\n  }\n}\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\nfunction _jobShare() {\n  // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n  // ReplaySubject.\n  return source => {\n    let refCount = 0;\n    let subject;\n    let hasError = false;\n    let isComplete = false;\n    let subscription;\n    return new rxjs_1.Observable(subscriber => {\n      let innerSub;\n      refCount++;\n      if (!subject) {\n        subject = new rxjs_1.Subject();\n        innerSub = subject.subscribe(subscriber);\n        subscription = source.subscribe({\n          next(value) {\n            subject.next(value);\n          },\n          error(err) {\n            hasError = true;\n            subject.error(err);\n          },\n          complete() {\n            isComplete = true;\n            subject.complete();\n          }\n        });\n      } else {\n        innerSub = subject.subscribe(subscriber);\n      }\n      return () => {\n        refCount--;\n        innerSub.unsubscribe();\n        if (subscription && refCount === 0 && (isComplete || hasError)) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\nclass SimpleScheduler {\n  constructor(_jobRegistry, _schemaRegistry = new core_1.schema.CoreSchemaRegistry()) {\n    this._jobRegistry = _jobRegistry;\n    this._schemaRegistry = _schemaRegistry;\n    this._internalJobDescriptionMap = new Map();\n    this._queue = [];\n    this._pauseCounter = 0;\n  }\n  _getInternalDescription(name) {\n    const maybeHandler = this._internalJobDescriptionMap.get(name);\n    if (maybeHandler !== undefined) {\n      return (0, rxjs_1.of)(maybeHandler);\n    }\n    const handler = this._jobRegistry.get(name);\n    return handler.pipe((0, rxjs_1.switchMap)(handler => {\n      if (handler === null) {\n        return (0, rxjs_1.of)(null);\n      }\n      const description = {\n        // Make a copy of it to be sure it's proper JSON.\n        ...JSON.parse(JSON.stringify(handler.jobDescription)),\n        name: handler.jobDescription.name || name,\n        argument: handler.jobDescription.argument || true,\n        input: handler.jobDescription.input || true,\n        output: handler.jobDescription.output || true,\n        channels: handler.jobDescription.channels || {}\n      };\n      const handlerWithExtra = Object.assign(handler.bind(undefined), {\n        jobDescription: description,\n        argumentV: this._schemaRegistry.compile(description.argument),\n        inputV: this._schemaRegistry.compile(description.input),\n        outputV: this._schemaRegistry.compile(description.output)\n      });\n      this._internalJobDescriptionMap.set(name, handlerWithExtra);\n      return (0, rxjs_1.of)(handlerWithExtra);\n    }));\n  }\n  /**\n   * Get a job description for a named job.\n   *\n   * @param name The name of the job.\n   * @returns A description, or null if the job is not registered.\n   */\n  getDescription(name) {\n    return (0, rxjs_1.concat)(this._getInternalDescription(name).pipe((0, rxjs_1.map)(x => x && x.jobDescription)), (0, rxjs_1.of)(null)).pipe((0, rxjs_1.first)());\n  }\n  /**\n   * Returns true if the job name has been registered.\n   * @param name The name of the job.\n   * @returns True if the job exists, false otherwise.\n   */\n  has(name) {\n    return this.getDescription(name).pipe((0, rxjs_1.map)(x => x !== null));\n  }\n  /**\n   * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n   * used to resume execution. If multiple `pause()` were called, all their resume functions must\n   * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n   * function will have no effect.\n   *\n   * Jobs already running are NOT paused. This is pausing the scheduler only.\n   */\n  pause() {\n    let called = false;\n    this._pauseCounter++;\n    return () => {\n      if (!called) {\n        called = true;\n        if (--this._pauseCounter == 0) {\n          // Resume the queue.\n          const q = this._queue;\n          this._queue = [];\n          q.forEach(fn => fn());\n        }\n      }\n    };\n  }\n  /**\n   * Schedule a job to be run, using its name.\n   * @param name The name of job to be run.\n   * @param argument The argument to send to the job when starting it.\n   * @param options Scheduling options.\n   * @returns The Job being run.\n   */\n  schedule(name, argument, options) {\n    if (this._pauseCounter > 0) {\n      const waitable = new rxjs_1.Subject();\n      this._queue.push(() => waitable.complete());\n      return this._scheduleJob(name, argument, options || {}, waitable);\n    }\n    return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n  }\n  /**\n   * Filter messages.\n   * @private\n   */\n  _filterJobOutboundMessages(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return state == api_1.JobState.Queued;\n      case api_1.JobOutboundMessageKind.Start:\n        return state == api_1.JobState.Ready;\n      case api_1.JobOutboundMessageKind.End:\n        return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n    }\n    return true;\n  }\n  /**\n   * Return a new state. This is just to simplify the reading of the _createJob method.\n   * @private\n   */\n  _updateState(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return api_1.JobState.Ready;\n      case api_1.JobOutboundMessageKind.Start:\n        return api_1.JobState.Started;\n      case api_1.JobOutboundMessageKind.End:\n        return api_1.JobState.Ended;\n    }\n    return state;\n  }\n  /**\n   * Create the job.\n   * @private\n   */\n  // eslint-disable-next-line max-lines-per-function\n  _createJob(name, argument, handler, inboundBus, outboundBus) {\n    const schemaRegistry = this._schemaRegistry;\n    const channelsSubject = new Map();\n    const channels = new Map();\n    let state = api_1.JobState.Queued;\n    let pingId = 0;\n    // Create the input channel by having a filter.\n    const input = new rxjs_1.Subject();\n    input.pipe((0, rxjs_1.concatMap)(message => handler.pipe((0, rxjs_1.switchMap)( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (handler) {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        }\n        const validator = yield handler.inputV;\n        return validator(message);\n      });\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()))), (0, rxjs_1.filter)(result => result.success), (0, rxjs_1.map)(result => result.data)).subscribe(value => inboundBus.next({\n      kind: api_1.JobInboundMessageKind.Input,\n      value\n    }));\n    outboundBus = (0, rxjs_1.concat)(outboundBus,\n    // Add an End message at completion. This will be filtered out if the job actually send an\n    // End.\n    handler.pipe((0, rxjs_1.switchMap)(handler => {\n      if (handler) {\n        return (0, rxjs_1.of)({\n          kind: api_1.JobOutboundMessageKind.End,\n          description: handler.jobDescription\n        });\n      } else {\n        return rxjs_1.EMPTY;\n      }\n    }))).pipe((0, rxjs_1.filter)(message => this._filterJobOutboundMessages(message, state)),\n    // Update internal logic and Job<> members.\n    (0, rxjs_1.tap)(message => {\n      // Update the state.\n      state = this._updateState(message, state);\n      switch (message.kind) {\n        case api_1.JobOutboundMessageKind.ChannelCreate:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            // If it doesn't exist or it's closed on the other end.\n            if (!maybeSubject) {\n              const s = new rxjs_1.Subject();\n              channelsSubject.set(message.name, s);\n              channels.set(message.name, s.asObservable());\n            }\n            break;\n          }\n        case api_1.JobOutboundMessageKind.ChannelMessage:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            if (maybeSubject) {\n              maybeSubject.next(message.message);\n            }\n            break;\n          }\n        case api_1.JobOutboundMessageKind.ChannelComplete:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            if (maybeSubject) {\n              maybeSubject.complete();\n              channelsSubject.delete(message.name);\n            }\n            break;\n          }\n        case api_1.JobOutboundMessageKind.ChannelError:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n            if (maybeSubject) {\n              maybeSubject.error(message.error);\n              channelsSubject.delete(message.name);\n            }\n            break;\n          }\n      }\n    }, () => {\n      state = api_1.JobState.Errored;\n    }),\n    // Do output validation (might include default values so this might have side\n    // effects). We keep all messages in order.\n    (0, rxjs_1.concatMap)(message => {\n      if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n        return (0, rxjs_1.of)(message);\n      }\n      return handler.pipe((0, rxjs_1.switchMap)( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (handler) {\n          if (handler === null) {\n            throw new exception_1.JobDoesNotExistException(name);\n          }\n          const validate = yield handler.outputV;\n          const output = yield validate(message.value);\n          if (!output.success) {\n            throw new JobOutputSchemaValidationError(output.errors);\n          }\n          return {\n            ...message,\n            output: output.data\n          };\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }()));\n    }), _jobShare());\n    const output = outboundBus.pipe((0, rxjs_1.filter)(x => x.kind == api_1.JobOutboundMessageKind.Output), (0, rxjs_1.map)(x => x.value), (0, rxjs_1.shareReplay)(1));\n    // Return the Job.\n    return {\n      get state() {\n        return state;\n      },\n      argument,\n      description: handler.pipe((0, rxjs_1.switchMap)(handler => {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        } else {\n          return (0, rxjs_1.of)(handler.jobDescription);\n        }\n      })),\n      output,\n      getChannel(name, schema = true) {\n        let maybeObservable = channels.get(name);\n        if (!maybeObservable) {\n          const s = new rxjs_1.Subject();\n          channelsSubject.set(name, s);\n          channels.set(name, s.asObservable());\n          maybeObservable = s.asObservable();\n        }\n        return maybeObservable.pipe(\n        // Keep the order of messages.\n        (0, rxjs_1.concatMap)(message => {\n          return (0, rxjs_1.from)(schemaRegistry.compile(schema)).pipe((0, rxjs_1.switchMap)(validate => validate(message)), (0, rxjs_1.filter)(x => x.success), (0, rxjs_1.map)(x => x.data));\n        }));\n      },\n      ping() {\n        const id = pingId++;\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Ping,\n          id\n        });\n        return outboundBus.pipe((0, rxjs_1.filter)(x => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), (0, rxjs_1.first)(), (0, rxjs_1.ignoreElements)());\n      },\n      stop() {\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Stop\n        });\n      },\n      input,\n      inboundBus,\n      outboundBus\n    };\n  }\n  _scheduleJob(name, argument, options, waitable) {\n    // Get handler first, since this can error out if there's no handler for the job name.\n    const handler = this._getInternalDescription(name);\n    const optionsDeps = options && options.dependencies || [];\n    const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n    const inboundBus = new rxjs_1.Subject();\n    const outboundBus = (0, rxjs_1.concat)(\n    // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n    // all dependencies at the same time so they run concurrently.\n    (0, rxjs_1.merge)(...dependencies.map(x => x.outboundBus)).pipe((0, rxjs_1.ignoreElements)()),\n    // Wait for pause() to clear (if necessary).\n    waitable, (0, rxjs_1.from)(handler).pipe((0, rxjs_1.switchMap)(handler => new rxjs_1.Observable(subscriber => {\n      if (!handler) {\n        throw new exception_1.JobDoesNotExistException(name);\n      }\n      // Validate the argument.\n      return (0, rxjs_1.from)(handler.argumentV).pipe((0, rxjs_1.switchMap)(validate => validate(argument)), (0, rxjs_1.switchMap)(output => {\n        if (!output.success) {\n          throw new JobArgumentSchemaValidationError(output.errors);\n        }\n        const argument = output.data;\n        const description = handler.jobDescription;\n        subscriber.next({\n          kind: api_1.JobOutboundMessageKind.OnReady,\n          description\n        });\n        const context = {\n          description,\n          dependencies: [...dependencies],\n          inboundBus: inboundBus.asObservable(),\n          scheduler: this\n        };\n        return handler(argument, context);\n      })).subscribe(subscriber);\n    }))));\n    return this._createJob(name, argument, handler, inboundBus, outboundBus);\n  }\n}\nexports.SimpleScheduler = SimpleScheduler;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","SimpleScheduler","JobOutputSchemaValidationError","JobInboundMessageSchemaValidationError","JobArgumentSchemaValidationError","core_1","rxjs_1","api_1","exception_1","schema","SchemaValidationException","constructor","errors","_jobShare","source","refCount","subject","hasError","isComplete","subscription","Observable","subscriber","innerSub","Subject","subscribe","next","error","err","complete","unsubscribe","_jobRegistry","_schemaRegistry","CoreSchemaRegistry","_internalJobDescriptionMap","Map","_queue","_pauseCounter","_getInternalDescription","name","maybeHandler","get","undefined","of","handler","pipe","switchMap","description","JSON","parse","stringify","jobDescription","argument","input","output","channels","handlerWithExtra","assign","bind","argumentV","compile","inputV","outputV","set","getDescription","concat","map","x","first","has","pause","called","q","forEach","fn","schedule","options","waitable","push","_scheduleJob","EMPTY","_filterJobOutboundMessages","message","state","kind","JobOutboundMessageKind","OnReady","JobState","Queued","Start","Ready","End","Started","_updateState","Ended","_createJob","inboundBus","outboundBus","schemaRegistry","channelsSubject","pingId","concatMap","_ref","JobDoesNotExistException","validator","_x","apply","arguments","filter","result","success","data","JobInboundMessageKind","Input","tap","ChannelCreate","maybeSubject","s","asObservable","ChannelMessage","ChannelComplete","delete","ChannelError","Errored","Output","_ref2","validate","_x2","shareReplay","getChannel","maybeObservable","from","ping","id","Ping","Pong","ignoreElements","stop","Stop","optionsDeps","dependencies","Array","isArray","merge","context","scheduler"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular-devkit/architect/src/jobs/simple-scheduler.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst api_1 = require(\"./api\");\nconst exception_1 = require(\"./exception\");\nclass JobArgumentSchemaValidationError extends core_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Argument failed to validate. Errors: ');\n    }\n}\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\nclass JobInboundMessageSchemaValidationError extends core_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Inbound Message failed to validate. Errors: ');\n    }\n}\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\nclass JobOutputSchemaValidationError extends core_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Output failed to validate. Errors: ');\n    }\n}\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\nfunction _jobShare() {\n    // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n    // ReplaySubject.\n    return (source) => {\n        let refCount = 0;\n        let subject;\n        let hasError = false;\n        let isComplete = false;\n        let subscription;\n        return new rxjs_1.Observable((subscriber) => {\n            let innerSub;\n            refCount++;\n            if (!subject) {\n                subject = new rxjs_1.Subject();\n                innerSub = subject.subscribe(subscriber);\n                subscription = source.subscribe({\n                    next(value) {\n                        subject.next(value);\n                    },\n                    error(err) {\n                        hasError = true;\n                        subject.error(err);\n                    },\n                    complete() {\n                        isComplete = true;\n                        subject.complete();\n                    },\n                });\n            }\n            else {\n                innerSub = subject.subscribe(subscriber);\n            }\n            return () => {\n                refCount--;\n                innerSub.unsubscribe();\n                if (subscription && refCount === 0 && (isComplete || hasError)) {\n                    subscription.unsubscribe();\n                }\n            };\n        });\n    };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\nclass SimpleScheduler {\n    constructor(_jobRegistry, _schemaRegistry = new core_1.schema.CoreSchemaRegistry()) {\n        this._jobRegistry = _jobRegistry;\n        this._schemaRegistry = _schemaRegistry;\n        this._internalJobDescriptionMap = new Map();\n        this._queue = [];\n        this._pauseCounter = 0;\n    }\n    _getInternalDescription(name) {\n        const maybeHandler = this._internalJobDescriptionMap.get(name);\n        if (maybeHandler !== undefined) {\n            return (0, rxjs_1.of)(maybeHandler);\n        }\n        const handler = this._jobRegistry.get(name);\n        return handler.pipe((0, rxjs_1.switchMap)((handler) => {\n            if (handler === null) {\n                return (0, rxjs_1.of)(null);\n            }\n            const description = {\n                // Make a copy of it to be sure it's proper JSON.\n                ...JSON.parse(JSON.stringify(handler.jobDescription)),\n                name: handler.jobDescription.name || name,\n                argument: handler.jobDescription.argument || true,\n                input: handler.jobDescription.input || true,\n                output: handler.jobDescription.output || true,\n                channels: handler.jobDescription.channels || {},\n            };\n            const handlerWithExtra = Object.assign(handler.bind(undefined), {\n                jobDescription: description,\n                argumentV: this._schemaRegistry.compile(description.argument),\n                inputV: this._schemaRegistry.compile(description.input),\n                outputV: this._schemaRegistry.compile(description.output),\n            });\n            this._internalJobDescriptionMap.set(name, handlerWithExtra);\n            return (0, rxjs_1.of)(handlerWithExtra);\n        }));\n    }\n    /**\n     * Get a job description for a named job.\n     *\n     * @param name The name of the job.\n     * @returns A description, or null if the job is not registered.\n     */\n    getDescription(name) {\n        return (0, rxjs_1.concat)(this._getInternalDescription(name).pipe((0, rxjs_1.map)((x) => x && x.jobDescription)), (0, rxjs_1.of)(null)).pipe((0, rxjs_1.first)());\n    }\n    /**\n     * Returns true if the job name has been registered.\n     * @param name The name of the job.\n     * @returns True if the job exists, false otherwise.\n     */\n    has(name) {\n        return this.getDescription(name).pipe((0, rxjs_1.map)((x) => x !== null));\n    }\n    /**\n     * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n     * used to resume execution. If multiple `pause()` were called, all their resume functions must\n     * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n     * function will have no effect.\n     *\n     * Jobs already running are NOT paused. This is pausing the scheduler only.\n     */\n    pause() {\n        let called = false;\n        this._pauseCounter++;\n        return () => {\n            if (!called) {\n                called = true;\n                if (--this._pauseCounter == 0) {\n                    // Resume the queue.\n                    const q = this._queue;\n                    this._queue = [];\n                    q.forEach((fn) => fn());\n                }\n            }\n        };\n    }\n    /**\n     * Schedule a job to be run, using its name.\n     * @param name The name of job to be run.\n     * @param argument The argument to send to the job when starting it.\n     * @param options Scheduling options.\n     * @returns The Job being run.\n     */\n    schedule(name, argument, options) {\n        if (this._pauseCounter > 0) {\n            const waitable = new rxjs_1.Subject();\n            this._queue.push(() => waitable.complete());\n            return this._scheduleJob(name, argument, options || {}, waitable);\n        }\n        return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n    }\n    /**\n     * Filter messages.\n     * @private\n     */\n    _filterJobOutboundMessages(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return state == api_1.JobState.Queued;\n            case api_1.JobOutboundMessageKind.Start:\n                return state == api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.End:\n                return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n        }\n        return true;\n    }\n    /**\n     * Return a new state. This is just to simplify the reading of the _createJob method.\n     * @private\n     */\n    _updateState(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.Start:\n                return api_1.JobState.Started;\n            case api_1.JobOutboundMessageKind.End:\n                return api_1.JobState.Ended;\n        }\n        return state;\n    }\n    /**\n     * Create the job.\n     * @private\n     */\n    // eslint-disable-next-line max-lines-per-function\n    _createJob(name, argument, handler, inboundBus, outboundBus) {\n        const schemaRegistry = this._schemaRegistry;\n        const channelsSubject = new Map();\n        const channels = new Map();\n        let state = api_1.JobState.Queued;\n        let pingId = 0;\n        // Create the input channel by having a filter.\n        const input = new rxjs_1.Subject();\n        input\n            .pipe((0, rxjs_1.concatMap)((message) => handler.pipe((0, rxjs_1.switchMap)(async (handler) => {\n            if (handler === null) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            const validator = await handler.inputV;\n            return validator(message);\n        }))), (0, rxjs_1.filter)((result) => result.success), (0, rxjs_1.map)((result) => result.data))\n            .subscribe((value) => inboundBus.next({ kind: api_1.JobInboundMessageKind.Input, value }));\n        outboundBus = (0, rxjs_1.concat)(outboundBus, \n        // Add an End message at completion. This will be filtered out if the job actually send an\n        // End.\n        handler.pipe((0, rxjs_1.switchMap)((handler) => {\n            if (handler) {\n                return (0, rxjs_1.of)({\n                    kind: api_1.JobOutboundMessageKind.End,\n                    description: handler.jobDescription,\n                });\n            }\n            else {\n                return rxjs_1.EMPTY;\n            }\n        }))).pipe((0, rxjs_1.filter)((message) => this._filterJobOutboundMessages(message, state)), \n        // Update internal logic and Job<> members.\n        (0, rxjs_1.tap)((message) => {\n            // Update the state.\n            state = this._updateState(message, state);\n            switch (message.kind) {\n                case api_1.JobOutboundMessageKind.ChannelCreate: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    // If it doesn't exist or it's closed on the other end.\n                    if (!maybeSubject) {\n                        const s = new rxjs_1.Subject();\n                        channelsSubject.set(message.name, s);\n                        channels.set(message.name, s.asObservable());\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelMessage: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.next(message.message);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelComplete: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.complete();\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelError: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.error(message.error);\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n            }\n        }, () => {\n            state = api_1.JobState.Errored;\n        }), \n        // Do output validation (might include default values so this might have side\n        // effects). We keep all messages in order.\n        (0, rxjs_1.concatMap)((message) => {\n            if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n                return (0, rxjs_1.of)(message);\n            }\n            return handler.pipe((0, rxjs_1.switchMap)(async (handler) => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                const validate = await handler.outputV;\n                const output = await validate(message.value);\n                if (!output.success) {\n                    throw new JobOutputSchemaValidationError(output.errors);\n                }\n                return {\n                    ...message,\n                    output: output.data,\n                };\n            }));\n        }), _jobShare());\n        const output = outboundBus.pipe((0, rxjs_1.filter)((x) => x.kind == api_1.JobOutboundMessageKind.Output), (0, rxjs_1.map)((x) => x.value), (0, rxjs_1.shareReplay)(1));\n        // Return the Job.\n        return {\n            get state() {\n                return state;\n            },\n            argument,\n            description: handler.pipe((0, rxjs_1.switchMap)((handler) => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                else {\n                    return (0, rxjs_1.of)(handler.jobDescription);\n                }\n            })),\n            output,\n            getChannel(name, schema = true) {\n                let maybeObservable = channels.get(name);\n                if (!maybeObservable) {\n                    const s = new rxjs_1.Subject();\n                    channelsSubject.set(name, s);\n                    channels.set(name, s.asObservable());\n                    maybeObservable = s.asObservable();\n                }\n                return maybeObservable.pipe(\n                // Keep the order of messages.\n                (0, rxjs_1.concatMap)((message) => {\n                    return (0, rxjs_1.from)(schemaRegistry.compile(schema)).pipe((0, rxjs_1.switchMap)((validate) => validate(message)), (0, rxjs_1.filter)((x) => x.success), (0, rxjs_1.map)((x) => x.data));\n                }));\n            },\n            ping() {\n                const id = pingId++;\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Ping, id });\n                return outboundBus.pipe((0, rxjs_1.filter)((x) => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), (0, rxjs_1.first)(), (0, rxjs_1.ignoreElements)());\n            },\n            stop() {\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Stop });\n            },\n            input,\n            inboundBus,\n            outboundBus,\n        };\n    }\n    _scheduleJob(name, argument, options, waitable) {\n        // Get handler first, since this can error out if there's no handler for the job name.\n        const handler = this._getInternalDescription(name);\n        const optionsDeps = (options && options.dependencies) || [];\n        const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n        const inboundBus = new rxjs_1.Subject();\n        const outboundBus = (0, rxjs_1.concat)(\n        // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n        // all dependencies at the same time so they run concurrently.\n        (0, rxjs_1.merge)(...dependencies.map((x) => x.outboundBus)).pipe((0, rxjs_1.ignoreElements)()), \n        // Wait for pause() to clear (if necessary).\n        waitable, (0, rxjs_1.from)(handler).pipe((0, rxjs_1.switchMap)((handler) => new rxjs_1.Observable((subscriber) => {\n            if (!handler) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            // Validate the argument.\n            return (0, rxjs_1.from)(handler.argumentV)\n                .pipe((0, rxjs_1.switchMap)((validate) => validate(argument)), (0, rxjs_1.switchMap)((output) => {\n                if (!output.success) {\n                    throw new JobArgumentSchemaValidationError(output.errors);\n                }\n                const argument = output.data;\n                const description = handler.jobDescription;\n                subscriber.next({ kind: api_1.JobOutboundMessageKind.OnReady, description });\n                const context = {\n                    description,\n                    dependencies: [...dependencies],\n                    inboundBus: inboundBus.asObservable(),\n                    scheduler: this,\n                };\n                return handler(argument, context);\n            }))\n                .subscribe(subscriber);\n        }))));\n        return this._createJob(name, argument, handler, inboundBus, outboundBus);\n    }\n}\nexports.SimpleScheduler = SimpleScheduler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}