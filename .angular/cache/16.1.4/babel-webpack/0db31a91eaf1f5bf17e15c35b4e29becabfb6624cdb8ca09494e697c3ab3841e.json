{"ast":null,"code":"\"use strict\";\n\n// synchronous utility for filtering entries and calculating subwalks\nvar _defineProperty = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = require(\"minimatch\");\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n  constructor(store = new Map()) {\n    _defineProperty(this, \"store\", void 0);\n    this.store = store;\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store));\n  }\n  hasWalked(target, pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString());\n  }\n  storeWalked(target, pattern) {\n    const fullpath = target.fullpath();\n    const cached = this.store.get(fullpath);\n    if (cached) cached.add(pattern.globString());else this.store.set(fullpath, new Set([pattern.globString()]));\n  }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n  constructor() {\n    _defineProperty(this, \"store\", new Map());\n  }\n  add(target, absolute, ifDir) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n    const current = this.store.get(target);\n    this.store.set(target, current === undefined ? n : n & current);\n  }\n  // match, absolute, ifdir\n  entries() {\n    return [...this.store.entries()].map(([path, n]) => [path, !!(n & 2), !!(n & 1)]);\n  }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n  constructor() {\n    _defineProperty(this, \"store\", new Map());\n  }\n  add(target, pattern) {\n    if (!target.canReaddir()) {\n      return;\n    }\n    const subs = this.store.get(target);\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern);\n      }\n    } else this.store.set(target, [pattern]);\n  }\n  get(target) {\n    const subs = this.store.get(target);\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path');\n    }\n    /* c8 ignore stop */\n    return subs;\n  }\n  entries() {\n    return this.keys().map(k => [k, this.store.get(k)]);\n  }\n  keys() {\n    return [...this.store.keys()].filter(t => t.canReaddir());\n  }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n  constructor(opts, hasWalkedCache) {\n    _defineProperty(this, \"hasWalkedCache\", void 0);\n    _defineProperty(this, \"matches\", new MatchRecord());\n    _defineProperty(this, \"subwalks\", new SubWalks());\n    _defineProperty(this, \"patterns\", void 0);\n    _defineProperty(this, \"follow\", void 0);\n    _defineProperty(this, \"dot\", void 0);\n    _defineProperty(this, \"opts\", void 0);\n    this.opts = opts;\n    this.follow = !!opts.follow;\n    this.dot = !!opts.dot;\n    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n  }\n  processPatterns(target, patterns) {\n    this.patterns = patterns;\n    const processingSet = patterns.map(p => [target, p]);\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern);\n      const root = pattern.root();\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(root === '/' && this.opts.root !== undefined ? this.opts.root : root);\n        const rest = pattern.rest();\n        if (!rest) {\n          this.matches.add(t, true, false);\n          continue;\n        } else {\n          pattern = rest;\n        }\n      }\n      if (t.isENOENT()) continue;\n      let p;\n      let rest;\n      let changed = false;\n      while (typeof (p = pattern.pattern()) === 'string' && (rest = pattern.rest())) {\n        const c = t.resolve(p);\n        // we can be reasonably sure that .. is a readable dir\n        if (c.isUnknown() && p !== '..') break;\n        t = c;\n        pattern = rest;\n        changed = true;\n      }\n      p = pattern.pattern();\n      rest = pattern.rest();\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue;\n        this.hasWalkedCache.storeWalked(t, pattern);\n      }\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must be final entry\n        if (!rest) {\n          const ifDir = p === '..' || p === '' || p === '.';\n          this.matches.add(t.resolve(p), absolute, ifDir);\n        } else {\n          this.subwalks.add(t, pattern);\n        }\n        continue;\n      } else if (p === minimatch_1.GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {\n          this.subwalks.add(t, pattern);\n        }\n        const rp = rest?.pattern();\n        const rrest = rest?.rest();\n        if (!rest || (rp === '' || rp === '.') && !rrest) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.');\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t;\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true);else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest);\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern);\n      }\n    }\n    return this;\n  }\n  subwalkTargets() {\n    return this.subwalks.keys();\n  }\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache);\n  }\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent, entries) {\n    const patterns = this.subwalks.get(parent);\n    // put matches and entry walks into the results processor\n    const results = this.child();\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute();\n        const p = pattern.pattern();\n        const rest = pattern.rest();\n        if (p === minimatch_1.GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute);\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute);\n        } else {\n          results.testString(e, p, rest, absolute);\n        }\n      }\n    }\n    return results;\n  }\n  testGlobstar(e, pattern, rest, absolute) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false);\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern);\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest);\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern);\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern();\n      if (typeof rp === 'string' &&\n      // dots and empty were handled already\n      rp !== '..' && rp !== '' && rp !== '.') {\n        this.testString(e, rp, rest.rest(), absolute);\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e;\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest);\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute);\n      }\n    }\n  }\n  testRegExp(e, p, rest, absolute) {\n    if (!p.test(e.name)) return;\n    if (!rest) {\n      this.matches.add(e, absolute, false);\n    } else {\n      this.subwalks.add(e, rest);\n    }\n  }\n  testString(e, p, rest, absolute) {\n    // should never happen?\n    if (!e.isNamed(p)) return;\n    if (!rest) {\n      this.matches.add(e, absolute, false);\n    } else {\n      this.subwalks.add(e, rest);\n    }\n  }\n}\nexports.Processor = Processor;","map":{"version":3,"names":["_defineProperty","require","default","Object","defineProperty","exports","value","Processor","SubWalks","MatchRecord","HasWalkedCache","minimatch_1","constructor","store","Map","copy","hasWalked","target","pattern","get","fullpath","has","globString","storeWalked","cached","add","set","Set","absolute","ifDir","n","current","undefined","entries","map","path","canReaddir","subs","find","p","push","Error","keys","k","filter","t","opts","hasWalkedCache","follow","dot","processPatterns","patterns","processingSet","root","isAbsolute","resolve","rest","matches","isENOENT","changed","c","isUnknown","subwalks","GLOBSTAR","isSymbolicLink","checkFollowGlobstar","rp","rrest","tp","parent","RegExp","subwalkTargets","child","filterEntries","results","e","testGlobstar","testRegExp","testString","name","startsWith","hasMore","markFollowGlobstar","ep","test","isNamed"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/glob/dist/cjs/src/processor.js"],"sourcesContent":["\"use strict\";\n// synchronous utility for filtering entries and calculating subwalks\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = require(\"minimatch\");\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n    store;\n    constructor(store = new Map()) {\n        this.store = store;\n    }\n    copy() {\n        return new HasWalkedCache(new Map(this.store));\n    }\n    hasWalked(target, pattern) {\n        return this.store.get(target.fullpath())?.has(pattern.globString());\n    }\n    storeWalked(target, pattern) {\n        const fullpath = target.fullpath();\n        const cached = this.store.get(fullpath);\n        if (cached)\n            cached.add(pattern.globString());\n        else\n            this.store.set(fullpath, new Set([pattern.globString()]));\n    }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n    store = new Map();\n    add(target, absolute, ifDir) {\n        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n        const current = this.store.get(target);\n        this.store.set(target, current === undefined ? n : n & current);\n    }\n    // match, absolute, ifdir\n    entries() {\n        return [...this.store.entries()].map(([path, n]) => [\n            path,\n            !!(n & 2),\n            !!(n & 1),\n        ]);\n    }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n    store = new Map();\n    add(target, pattern) {\n        if (!target.canReaddir()) {\n            return;\n        }\n        const subs = this.store.get(target);\n        if (subs) {\n            if (!subs.find(p => p.globString() === pattern.globString())) {\n                subs.push(pattern);\n            }\n        }\n        else\n            this.store.set(target, [pattern]);\n    }\n    get(target) {\n        const subs = this.store.get(target);\n        /* c8 ignore start */\n        if (!subs) {\n            throw new Error('attempting to walk unknown path');\n        }\n        /* c8 ignore stop */\n        return subs;\n    }\n    entries() {\n        return this.keys().map(k => [k, this.store.get(k)]);\n    }\n    keys() {\n        return [...this.store.keys()].filter(t => t.canReaddir());\n    }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n    hasWalkedCache;\n    matches = new MatchRecord();\n    subwalks = new SubWalks();\n    patterns;\n    follow;\n    dot;\n    opts;\n    constructor(opts, hasWalkedCache) {\n        this.opts = opts;\n        this.follow = !!opts.follow;\n        this.dot = !!opts.dot;\n        this.hasWalkedCache = hasWalkedCache\n            ? hasWalkedCache.copy()\n            : new HasWalkedCache();\n    }\n    processPatterns(target, patterns) {\n        this.patterns = patterns;\n        const processingSet = patterns.map(p => [target, p]);\n        // map of paths to the magic-starting subwalks they need to walk\n        // first item in patterns is the filter\n        for (let [t, pattern] of processingSet) {\n            this.hasWalkedCache.storeWalked(t, pattern);\n            const root = pattern.root();\n            const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n            // start absolute patterns at root\n            if (root) {\n                t = t.resolve(root === '/' && this.opts.root !== undefined\n                    ? this.opts.root\n                    : root);\n                const rest = pattern.rest();\n                if (!rest) {\n                    this.matches.add(t, true, false);\n                    continue;\n                }\n                else {\n                    pattern = rest;\n                }\n            }\n            if (t.isENOENT())\n                continue;\n            let p;\n            let rest;\n            let changed = false;\n            while (typeof (p = pattern.pattern()) === 'string' &&\n                (rest = pattern.rest())) {\n                const c = t.resolve(p);\n                // we can be reasonably sure that .. is a readable dir\n                if (c.isUnknown() && p !== '..')\n                    break;\n                t = c;\n                pattern = rest;\n                changed = true;\n            }\n            p = pattern.pattern();\n            rest = pattern.rest();\n            if (changed) {\n                if (this.hasWalkedCache.hasWalked(t, pattern))\n                    continue;\n                this.hasWalkedCache.storeWalked(t, pattern);\n            }\n            // now we have either a final string for a known entry,\n            // more strings for an unknown entry,\n            // or a pattern starting with magic, mounted on t.\n            if (typeof p === 'string') {\n                // must be final entry\n                if (!rest) {\n                    const ifDir = p === '..' || p === '' || p === '.';\n                    this.matches.add(t.resolve(p), absolute, ifDir);\n                }\n                else {\n                    this.subwalks.add(t, pattern);\n                }\n                continue;\n            }\n            else if (p === minimatch_1.GLOBSTAR) {\n                // if no rest, match and subwalk pattern\n                // if rest, process rest and subwalk pattern\n                // if it's a symlink, but we didn't get here by way of a\n                // globstar match (meaning it's the first time THIS globstar\n                // has traversed a symlink), then we follow it. Otherwise, stop.\n                if (!t.isSymbolicLink() ||\n                    this.follow ||\n                    pattern.checkFollowGlobstar()) {\n                    this.subwalks.add(t, pattern);\n                }\n                const rp = rest?.pattern();\n                const rrest = rest?.rest();\n                if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n                    // only HAS to be a dir if it ends in **/ or **/.\n                    // but ending in ** will match files as well.\n                    this.matches.add(t, absolute, rp === '' || rp === '.');\n                }\n                else {\n                    if (rp === '..') {\n                        // this would mean you're matching **/.. at the fs root,\n                        // and no thanks, I'm not gonna test that specific case.\n                        /* c8 ignore start */\n                        const tp = t.parent || t;\n                        /* c8 ignore stop */\n                        if (!rrest)\n                            this.matches.add(tp, absolute, true);\n                        else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n                            this.subwalks.add(tp, rrest);\n                        }\n                    }\n                }\n            }\n            else if (p instanceof RegExp) {\n                this.subwalks.add(t, pattern);\n            }\n        }\n        return this;\n    }\n    subwalkTargets() {\n        return this.subwalks.keys();\n    }\n    child() {\n        return new Processor(this.opts, this.hasWalkedCache);\n    }\n    // return a new Processor containing the subwalks for each\n    // child entry, and a set of matches, and\n    // a hasWalkedCache that's a copy of this one\n    // then we're going to call\n    filterEntries(parent, entries) {\n        const patterns = this.subwalks.get(parent);\n        // put matches and entry walks into the results processor\n        const results = this.child();\n        for (const e of entries) {\n            for (const pattern of patterns) {\n                const absolute = pattern.isAbsolute();\n                const p = pattern.pattern();\n                const rest = pattern.rest();\n                if (p === minimatch_1.GLOBSTAR) {\n                    results.testGlobstar(e, pattern, rest, absolute);\n                }\n                else if (p instanceof RegExp) {\n                    results.testRegExp(e, p, rest, absolute);\n                }\n                else {\n                    results.testString(e, p, rest, absolute);\n                }\n            }\n        }\n        return results;\n    }\n    testGlobstar(e, pattern, rest, absolute) {\n        if (this.dot || !e.name.startsWith('.')) {\n            if (!pattern.hasMore()) {\n                this.matches.add(e, absolute, false);\n            }\n            if (e.canReaddir()) {\n                // if we're in follow mode or it's not a symlink, just keep\n                // testing the same pattern. If there's more after the globstar,\n                // then this symlink consumes the globstar. If not, then we can\n                // follow at most ONE symlink along the way, so we mark it, which\n                // also checks to ensure that it wasn't already marked.\n                if (this.follow || !e.isSymbolicLink()) {\n                    this.subwalks.add(e, pattern);\n                }\n                else if (e.isSymbolicLink()) {\n                    if (rest && pattern.checkFollowGlobstar()) {\n                        this.subwalks.add(e, rest);\n                    }\n                    else if (pattern.markFollowGlobstar()) {\n                        this.subwalks.add(e, pattern);\n                    }\n                }\n            }\n        }\n        // if the NEXT thing matches this entry, then also add\n        // the rest.\n        if (rest) {\n            const rp = rest.pattern();\n            if (typeof rp === 'string' &&\n                // dots and empty were handled already\n                rp !== '..' &&\n                rp !== '' &&\n                rp !== '.') {\n                this.testString(e, rp, rest.rest(), absolute);\n            }\n            else if (rp === '..') {\n                /* c8 ignore start */\n                const ep = e.parent || e;\n                /* c8 ignore stop */\n                this.subwalks.add(ep, rest);\n            }\n            else if (rp instanceof RegExp) {\n                this.testRegExp(e, rp, rest.rest(), absolute);\n            }\n        }\n    }\n    testRegExp(e, p, rest, absolute) {\n        if (!p.test(e.name))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n    testString(e, p, rest, absolute) {\n        // should never happen?\n        if (!e.isNamed(p))\n            return;\n        if (!rest) {\n            this.matches.add(e, absolute, false);\n        }\n        else {\n            this.subwalks.add(e, rest);\n        }\n    }\n}\nexports.Processor = Processor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}