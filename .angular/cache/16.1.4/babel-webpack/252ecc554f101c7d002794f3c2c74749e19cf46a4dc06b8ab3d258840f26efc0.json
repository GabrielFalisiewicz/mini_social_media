{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Key = void 0;\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst key_1 = require(\"./utils/key\");\n// A container class representing the public portion of a Key.\nclass Key {\n  constructor(options) {\n    const {\n      keyID,\n      keyType,\n      scheme,\n      keyVal,\n      unrecognizedFields\n    } = options;\n    this.keyID = keyID;\n    this.keyType = keyType;\n    this.scheme = scheme;\n    this.keyVal = keyVal;\n    this.unrecognizedFields = unrecognizedFields || {};\n  }\n  // Verifies the that the metadata.signatures contains a signature made with\n  // this key and is correctly signed.\n  verifySignature(metadata) {\n    const signature = metadata.signatures[this.keyID];\n    if (!signature) throw new error_1.UnsignedMetadataError('no signature for key found in metadata');\n    if (!this.keyVal.public) throw new error_1.UnsignedMetadataError('no public key found');\n    const publicKey = (0, key_1.getPublicKey)({\n      keyType: this.keyType,\n      scheme: this.scheme,\n      keyVal: this.keyVal.public\n    });\n    const signedData = metadata.signed.toJSON();\n    try {\n      if (!utils_1.crypto.verifySignature(signedData, publicKey, signature.sig)) {\n        throw new error_1.UnsignedMetadataError(`failed to verify ${this.keyID} signature`);\n      }\n    } catch (error) {\n      if (error instanceof error_1.UnsignedMetadataError) {\n        throw error;\n      }\n      throw new error_1.UnsignedMetadataError(`failed to verify ${this.keyID} signature`);\n    }\n  }\n  equals(other) {\n    if (!(other instanceof Key)) {\n      return false;\n    }\n    return this.keyID === other.keyID && this.keyType === other.keyType && this.scheme === other.scheme && util_1.default.isDeepStrictEqual(this.keyVal, other.keyVal) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);\n  }\n  toJSON() {\n    return {\n      keytype: this.keyType,\n      scheme: this.scheme,\n      keyval: this.keyVal,\n      ...this.unrecognizedFields\n    };\n  }\n  static fromJSON(keyID, data) {\n    const {\n      keytype,\n      scheme,\n      keyval,\n      ...rest\n    } = data;\n    if (typeof keytype !== 'string') {\n      throw new TypeError('keytype must be a string');\n    }\n    if (typeof scheme !== 'string') {\n      throw new TypeError('scheme must be a string');\n    }\n    if (!utils_1.guard.isStringRecord(keyval)) {\n      throw new TypeError('keyval must be a string record');\n    }\n    return new Key({\n      keyID,\n      keyType: keytype,\n      scheme,\n      keyVal: keyval,\n      unrecognizedFields: rest\n    });\n  }\n}\nexports.Key = Key;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Key","util_1","require","error_1","utils_1","key_1","constructor","options","keyID","keyType","scheme","keyVal","unrecognizedFields","verifySignature","metadata","signature","signatures","UnsignedMetadataError","public","publicKey","getPublicKey","signedData","signed","toJSON","crypto","sig","error","equals","other","default","isDeepStrictEqual","keytype","keyval","fromJSON","data","rest","TypeError","guard","isStringRecord"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@tufjs/models/dist/key.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Key = void 0;\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst key_1 = require(\"./utils/key\");\n// A container class representing the public portion of a Key.\nclass Key {\n    constructor(options) {\n        const { keyID, keyType, scheme, keyVal, unrecognizedFields } = options;\n        this.keyID = keyID;\n        this.keyType = keyType;\n        this.scheme = scheme;\n        this.keyVal = keyVal;\n        this.unrecognizedFields = unrecognizedFields || {};\n    }\n    // Verifies the that the metadata.signatures contains a signature made with\n    // this key and is correctly signed.\n    verifySignature(metadata) {\n        const signature = metadata.signatures[this.keyID];\n        if (!signature)\n            throw new error_1.UnsignedMetadataError('no signature for key found in metadata');\n        if (!this.keyVal.public)\n            throw new error_1.UnsignedMetadataError('no public key found');\n        const publicKey = (0, key_1.getPublicKey)({\n            keyType: this.keyType,\n            scheme: this.scheme,\n            keyVal: this.keyVal.public,\n        });\n        const signedData = metadata.signed.toJSON();\n        try {\n            if (!utils_1.crypto.verifySignature(signedData, publicKey, signature.sig)) {\n                throw new error_1.UnsignedMetadataError(`failed to verify ${this.keyID} signature`);\n            }\n        }\n        catch (error) {\n            if (error instanceof error_1.UnsignedMetadataError) {\n                throw error;\n            }\n            throw new error_1.UnsignedMetadataError(`failed to verify ${this.keyID} signature`);\n        }\n    }\n    equals(other) {\n        if (!(other instanceof Key)) {\n            return false;\n        }\n        return (this.keyID === other.keyID &&\n            this.keyType === other.keyType &&\n            this.scheme === other.scheme &&\n            util_1.default.isDeepStrictEqual(this.keyVal, other.keyVal) &&\n            util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields));\n    }\n    toJSON() {\n        return {\n            keytype: this.keyType,\n            scheme: this.scheme,\n            keyval: this.keyVal,\n            ...this.unrecognizedFields,\n        };\n    }\n    static fromJSON(keyID, data) {\n        const { keytype, scheme, keyval, ...rest } = data;\n        if (typeof keytype !== 'string') {\n            throw new TypeError('keytype must be a string');\n        }\n        if (typeof scheme !== 'string') {\n            throw new TypeError('scheme must be a string');\n        }\n        if (!utils_1.guard.isStringRecord(keyval)) {\n            throw new TypeError('keyval must be a string record');\n        }\n        return new Key({\n            keyID,\n            keyType: keytype,\n            scheme,\n            keyVal: keyval,\n            unrecognizedFields: rest,\n        });\n    }\n}\nexports.Key = Key;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}