{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultFetcher = exports.BaseFetcher = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst make_fetch_happen_1 = __importDefault(require(\"make-fetch-happen\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst tmpfile_1 = require(\"./utils/tmpfile\");\nconst log = (0, debug_1.default)('tuf:fetch');\nclass BaseFetcher {\n  // Download file from given URL. The file is downloaded to a temporary\n  // location and then passed to the given handler. The handler is responsible\n  // for moving the file to its final location. The temporary file is deleted\n  // after the handler returns.\n  downloadFile(url, maxLength, handler) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return (0, tmpfile_1.withTempFile)( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (tmpFile) {\n          const reader = yield _this.fetch(url);\n          let numberOfBytesReceived = 0;\n          const fileStream = fs_1.default.createWriteStream(tmpFile);\n          // Read the stream a chunk at a time so that we can check\n          // the length of the file as we go\n          try {\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n            var _iteratorError;\n            try {\n              for (var _iterator = _asyncIterator(reader), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n                const chunk = _step.value;\n                {\n                  const bufferChunk = Buffer.from(chunk);\n                  numberOfBytesReceived += bufferChunk.length;\n                  if (numberOfBytesReceived > maxLength) {\n                    throw new error_1.DownloadLengthMismatchError('Max length reached');\n                  }\n                  yield writeBufferToStream(fileStream, bufferChunk);\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          } finally {\n            // Make sure we always close the stream\n            yield util_1.default.promisify(fileStream.close).bind(fileStream)();\n          }\n          return handler(tmpFile);\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  // Download bytes from given URL.\n  downloadBytes(url, maxLength) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.downloadFile(url, maxLength, /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (file) {\n          const stream = fs_1.default.createReadStream(file);\n          const chunks = [];\n          var _iteratorAbruptCompletion2 = false;\n          var _didIteratorError2 = false;\n          var _iteratorError2;\n          try {\n            for (var _iterator2 = _asyncIterator(stream), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {\n              const chunk = _step2.value;\n              {\n                chunks.push(chunk);\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n                yield _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n          return Buffer.concat(chunks);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n}\nexports.BaseFetcher = BaseFetcher;\nclass DefaultFetcher extends BaseFetcher {\n  constructor(options = {}) {\n    super();\n    this.timeout = options.timeout;\n    this.retries = options.retries;\n  }\n  fetch(url) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      log('GET %s', url);\n      const response = yield (0, make_fetch_happen_1.default)(url, {\n        timeout: _this3.timeout,\n        retry: _this3.retries\n      });\n      if (!response.ok || !response?.body) {\n        throw new error_1.DownloadHTTPError('Failed to download', response.status);\n      }\n      return response.body;\n    })();\n  }\n}\nexports.DefaultFetcher = DefaultFetcher;\nconst writeBufferToStream = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (stream, buffer) {\n    return new Promise((resolve, reject) => {\n      stream.write(buffer, err => {\n        if (err) {\n          reject(err);\n        }\n        resolve(true);\n      });\n    });\n  });\n  return function writeBufferToStream(_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["_asyncToGenerator","require","default","_asyncIterator","__importDefault","mod","__esModule","Object","defineProperty","exports","value","DefaultFetcher","BaseFetcher","debug_1","fs_1","make_fetch_happen_1","util_1","error_1","tmpfile_1","log","downloadFile","url","maxLength","handler","_this","withTempFile","_ref","tmpFile","reader","fetch","numberOfBytesReceived","fileStream","createWriteStream","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","chunk","bufferChunk","Buffer","from","length","DownloadLengthMismatchError","writeBufferToStream","err","return","promisify","close","bind","_x","apply","arguments","downloadBytes","_this2","_ref2","file","stream","createReadStream","chunks","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","push","concat","_x2","constructor","options","timeout","retries","_this3","response","retry","ok","body","DownloadHTTPError","status","_ref3","buffer","Promise","resolve","reject","write","_x3","_x4"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/tuf-js/dist/fetcher.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DefaultFetcher = exports.BaseFetcher = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst make_fetch_happen_1 = __importDefault(require(\"make-fetch-happen\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst error_1 = require(\"./error\");\nconst tmpfile_1 = require(\"./utils/tmpfile\");\nconst log = (0, debug_1.default)('tuf:fetch');\nclass BaseFetcher {\n    // Download file from given URL. The file is downloaded to a temporary\n    // location and then passed to the given handler. The handler is responsible\n    // for moving the file to its final location. The temporary file is deleted\n    // after the handler returns.\n    async downloadFile(url, maxLength, handler) {\n        return (0, tmpfile_1.withTempFile)(async (tmpFile) => {\n            const reader = await this.fetch(url);\n            let numberOfBytesReceived = 0;\n            const fileStream = fs_1.default.createWriteStream(tmpFile);\n            // Read the stream a chunk at a time so that we can check\n            // the length of the file as we go\n            try {\n                for await (const chunk of reader) {\n                    const bufferChunk = Buffer.from(chunk);\n                    numberOfBytesReceived += bufferChunk.length;\n                    if (numberOfBytesReceived > maxLength) {\n                        throw new error_1.DownloadLengthMismatchError('Max length reached');\n                    }\n                    await writeBufferToStream(fileStream, bufferChunk);\n                }\n            }\n            finally {\n                // Make sure we always close the stream\n                await util_1.default.promisify(fileStream.close).bind(fileStream)();\n            }\n            return handler(tmpFile);\n        });\n    }\n    // Download bytes from given URL.\n    async downloadBytes(url, maxLength) {\n        return this.downloadFile(url, maxLength, async (file) => {\n            const stream = fs_1.default.createReadStream(file);\n            const chunks = [];\n            for await (const chunk of stream) {\n                chunks.push(chunk);\n            }\n            return Buffer.concat(chunks);\n        });\n    }\n}\nexports.BaseFetcher = BaseFetcher;\nclass DefaultFetcher extends BaseFetcher {\n    constructor(options = {}) {\n        super();\n        this.timeout = options.timeout;\n        this.retries = options.retries;\n    }\n    async fetch(url) {\n        log('GET %s', url);\n        const response = await (0, make_fetch_happen_1.default)(url, {\n            timeout: this.timeout,\n            retry: this.retries,\n        });\n        if (!response.ok || !response?.body) {\n            throw new error_1.DownloadHTTPError('Failed to download', response.status);\n        }\n        return response.body;\n    }\n}\nexports.DefaultFetcher = DefaultFetcher;\nconst writeBufferToStream = async (stream, buffer) => {\n    return new Promise((resolve, reject) => {\n        stream.write(buffer, (err) => {\n            if (err) {\n                reject(err);\n            }\n            resolve(true);\n        });\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}