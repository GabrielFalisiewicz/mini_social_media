{"ast":null,"code":"const {\n  hasOwnProperty\n} = Object.prototype;\nconst encode = (obj, opt = {}) => {\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt\n    };\n  }\n  opt.align = opt.align === true;\n  opt.newline = opt.newline === true;\n  opt.sort = opt.sort === true;\n  opt.whitespace = opt.whitespace === true || opt.align === true;\n  // The `typeof` check is required because accessing the `process` directly fails on browsers.\n  /* istanbul ignore next */\n  opt.platform = opt.platform || typeof process !== 'undefined' && process.platform;\n  opt.bracketedArray = opt.bracketedArray !== false;\n\n  /* istanbul ignore next */\n  const eol = opt.platform === 'win32' ? '\\r\\n' : '\\n';\n  const separator = opt.whitespace ? ' = ' : '=';\n  const children = [];\n  const keys = opt.sort ? Object.keys(obj).sort() : Object.keys(obj);\n  let padToChars = 0;\n  // If aligning on the separator, then padToChars is determined as follows:\n  // 1. Get the keys\n  // 2. Exclude keys pointing to objects unless the value is null or an array\n  // 3. Add `[]` to array keys\n  // 4. Ensure non empty set of keys\n  // 5. Reduce the set to the longest `safe` key\n  // 6. Get the `safe` length\n  if (opt.align) {\n    padToChars = safe(keys.filter(k => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== 'object').map(k => Array.isArray(obj[k]) ? `${k}[]` : k).concat(['']).reduce((a, b) => safe(a).length >= safe(b).length ? a : b)).length;\n  }\n  let out = '';\n  const arraySuffix = opt.bracketedArray ? '[]' : '';\n  for (const k of keys) {\n    const val = obj[k];\n    if (val && Array.isArray(val)) {\n      for (const item of val) {\n        out += safe(`${k}${arraySuffix}`).padEnd(padToChars, ' ') + separator + safe(item) + eol;\n      }\n    } else if (val && typeof val === 'object') {\n      children.push(k);\n    } else {\n      out += safe(k).padEnd(padToChars, ' ') + separator + safe(val) + eol;\n    }\n  }\n  if (opt.section && out.length) {\n    out = '[' + safe(opt.section) + ']' + (opt.newline ? eol + eol : eol) + out;\n  }\n  for (const k of children) {\n    const nk = splitSections(k, '.').join('\\\\.');\n    const section = (opt.section ? opt.section + '.' : '') + nk;\n    const child = encode(obj[k], {\n      ...opt,\n      section\n    });\n    if (out.length && child.length) {\n      out += eol;\n    }\n    out += child;\n  }\n  return out;\n};\nfunction splitSections(str, separator) {\n  var lastMatchIndex = 0;\n  var lastSeparatorIndex = 0;\n  var nextIndex = 0;\n  var sections = [];\n  do {\n    nextIndex = str.indexOf(separator, lastMatchIndex);\n    if (nextIndex !== -1) {\n      lastMatchIndex = nextIndex + separator.length;\n      if (nextIndex > 0 && str[nextIndex - 1] === '\\\\') {\n        continue;\n      }\n      sections.push(str.slice(lastSeparatorIndex, nextIndex));\n      lastSeparatorIndex = nextIndex + separator.length;\n    }\n  } while (nextIndex !== -1);\n  sections.push(str.slice(lastSeparatorIndex));\n  return sections;\n}\nconst decode = (str, opt = {}) => {\n  opt.bracketedArray = opt.bracketedArray !== false;\n  const out = Object.create(null);\n  let p = out;\n  let section = null;\n  //          section          |key      = value\n  const re = /^\\[([^\\]]*)\\]\\s*$|^([^=]+)(=(.*))?$/i;\n  const lines = str.split(/[\\r\\n]+/g);\n  const duplicates = {};\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/) || line.match(/^\\s*$/)) {\n      continue;\n    }\n    const match = line.match(re);\n    if (!match) {\n      continue;\n    }\n    if (match[1] !== undefined) {\n      section = unsafe(match[1]);\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null);\n        continue;\n      }\n      p = out[section] = out[section] || Object.create(null);\n      continue;\n    }\n    const keyRaw = unsafe(match[2]);\n    let isArray;\n    if (opt.bracketedArray) {\n      isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]';\n    } else {\n      duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1;\n      isArray = duplicates[keyRaw] > 1;\n    }\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw;\n    if (key === '__proto__') {\n      continue;\n    }\n    const valueRaw = match[3] ? unsafe(match[4]) : true;\n    const value = valueRaw === 'true' || valueRaw === 'false' || valueRaw === 'null' ? JSON.parse(valueRaw) : valueRaw;\n\n    // Convert keys with '[]' suffix to an array\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key)) {\n        p[key] = [];\n      } else if (!Array.isArray(p[key])) {\n        p[key] = [p[key]];\n      }\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) {\n      p[key].push(value);\n    } else {\n      p[key] = value;\n    }\n  }\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  const remove = [];\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) || typeof out[k] !== 'object' || Array.isArray(out[k])) {\n      continue;\n    }\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    const parts = splitSections(k, '.');\n    p = out;\n    const l = parts.pop();\n    const nl = l.replace(/\\\\\\./g, '.');\n    for (const part of parts) {\n      if (part === '__proto__') {\n        continue;\n      }\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object') {\n        p[part] = Object.create(null);\n      }\n      p = p[part];\n    }\n    if (p === out && nl === l) {\n      continue;\n    }\n    p[nl] = out[k];\n    remove.push(k);\n  }\n  for (const del of remove) {\n    delete out[del];\n  }\n  return out;\n};\nconst isQuoted = val => {\n  return val.startsWith('\"') && val.endsWith('\"') || val.startsWith(\"'\") && val.endsWith(\"'\");\n};\nconst safe = val => {\n  if (typeof val !== 'string' || val.match(/[=\\r\\n]/) || val.match(/^\\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {\n    return JSON.stringify(val);\n  }\n  return val.split(';').join('\\\\;').split('#').join('\\\\#');\n};\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim();\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.slice(1, -1);\n    }\n    try {\n      val = JSON.parse(val);\n    } catch {\n      // ignore errors\n    }\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false;\n    let unesc = '';\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i);\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) {\n          unesc += c;\n        } else {\n          unesc += '\\\\' + c;\n        }\n        esc = false;\n      } else if (';#'.indexOf(c) !== -1) {\n        break;\n      } else if (c === '\\\\') {\n        esc = true;\n      } else {\n        unesc += c;\n      }\n    }\n    if (esc) {\n      unesc += '\\\\';\n    }\n    return unesc.trim();\n  }\n  return val;\n};\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe\n};","map":{"version":3,"names":["hasOwnProperty","Object","prototype","encode","obj","opt","section","align","newline","sort","whitespace","platform","process","bracketedArray","eol","separator","children","keys","padToChars","safe","filter","k","Array","isArray","map","concat","reduce","a","b","length","out","arraySuffix","val","item","padEnd","push","nk","splitSections","join","child","str","lastMatchIndex","lastSeparatorIndex","nextIndex","sections","indexOf","slice","decode","create","p","re","lines","split","duplicates","line","match","undefined","unsafe","keyRaw","key","valueRaw","value","JSON","parse","call","remove","parts","l","pop","nl","replace","part","del","isQuoted","startsWith","endsWith","trim","stringify","doUnesc","charAt","esc","unesc","i","c","module","exports"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/ini/lib/ini.js"],"sourcesContent":["const { hasOwnProperty } = Object.prototype\n\nconst encode = (obj, opt = {}) => {\n  if (typeof opt === 'string') {\n    opt = { section: opt }\n  }\n  opt.align = opt.align === true\n  opt.newline = opt.newline === true\n  opt.sort = opt.sort === true\n  opt.whitespace = opt.whitespace === true || opt.align === true\n  // The `typeof` check is required because accessing the `process` directly fails on browsers.\n  /* istanbul ignore next */\n  opt.platform = opt.platform || (typeof process !== 'undefined' && process.platform)\n  opt.bracketedArray = opt.bracketedArray !== false\n\n  /* istanbul ignore next */\n  const eol = opt.platform === 'win32' ? '\\r\\n' : '\\n'\n  const separator = opt.whitespace ? ' = ' : '='\n  const children = []\n\n  const keys = opt.sort ? Object.keys(obj).sort() : Object.keys(obj)\n\n  let padToChars = 0\n  // If aligning on the separator, then padToChars is determined as follows:\n  // 1. Get the keys\n  // 2. Exclude keys pointing to objects unless the value is null or an array\n  // 3. Add `[]` to array keys\n  // 4. Ensure non empty set of keys\n  // 5. Reduce the set to the longest `safe` key\n  // 6. Get the `safe` length\n  if (opt.align) {\n    padToChars = safe(\n      (\n        keys\n          .filter(k => obj[k] === null || Array.isArray(obj[k]) || typeof obj[k] !== 'object')\n          .map(k => Array.isArray(obj[k]) ? `${k}[]` : k)\n      )\n        .concat([''])\n        .reduce((a, b) => safe(a).length >= safe(b).length ? a : b)\n    ).length\n  }\n\n  let out = ''\n  const arraySuffix = opt.bracketedArray ? '[]' : ''\n\n  for (const k of keys) {\n    const val = obj[k]\n    if (val && Array.isArray(val)) {\n      for (const item of val) {\n        out += safe(`${k}${arraySuffix}`).padEnd(padToChars, ' ') + separator + safe(item) + eol\n      }\n    } else if (val && typeof val === 'object') {\n      children.push(k)\n    } else {\n      out += safe(k).padEnd(padToChars, ' ') + separator + safe(val) + eol\n    }\n  }\n\n  if (opt.section && out.length) {\n    out = '[' + safe(opt.section) + ']' + (opt.newline ? eol + eol : eol) + out\n  }\n\n  for (const k of children) {\n    const nk = splitSections(k, '.').join('\\\\.')\n    const section = (opt.section ? opt.section + '.' : '') + nk\n    const child = encode(obj[k], {\n      ...opt,\n      section,\n    })\n    if (out.length && child.length) {\n      out += eol\n    }\n\n    out += child\n  }\n\n  return out\n}\n\nfunction splitSections (str, separator) {\n  var lastMatchIndex = 0\n  var lastSeparatorIndex = 0\n  var nextIndex = 0\n  var sections = []\n\n  do {\n    nextIndex = str.indexOf(separator, lastMatchIndex)\n\n    if (nextIndex !== -1) {\n      lastMatchIndex = nextIndex + separator.length\n\n      if (nextIndex > 0 && str[nextIndex - 1] === '\\\\') {\n        continue\n      }\n\n      sections.push(str.slice(lastSeparatorIndex, nextIndex))\n      lastSeparatorIndex = nextIndex + separator.length\n    }\n  } while (nextIndex !== -1)\n\n  sections.push(str.slice(lastSeparatorIndex))\n\n  return sections\n}\n\nconst decode = (str, opt = {}) => {\n  opt.bracketedArray = opt.bracketedArray !== false\n  const out = Object.create(null)\n  let p = out\n  let section = null\n  //          section          |key      = value\n  const re = /^\\[([^\\]]*)\\]\\s*$|^([^=]+)(=(.*))?$/i\n  const lines = str.split(/[\\r\\n]+/g)\n  const duplicates = {}\n\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/) || line.match(/^\\s*$/)) {\n      continue\n    }\n    const match = line.match(re)\n    if (!match) {\n      continue\n    }\n    if (match[1] !== undefined) {\n      section = unsafe(match[1])\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null)\n        continue\n      }\n      p = out[section] = out[section] || Object.create(null)\n      continue\n    }\n    const keyRaw = unsafe(match[2])\n    let isArray\n    if (opt.bracketedArray) {\n      isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]'\n    } else {\n      duplicates[keyRaw] = (duplicates?.[keyRaw] || 0) + 1\n      isArray = duplicates[keyRaw] > 1\n    }\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw\n    if (key === '__proto__') {\n      continue\n    }\n    const valueRaw = match[3] ? unsafe(match[4]) : true\n    const value = valueRaw === 'true' ||\n      valueRaw === 'false' ||\n      valueRaw === 'null' ? JSON.parse(valueRaw)\n      : valueRaw\n\n    // Convert keys with '[]' suffix to an array\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key)) {\n        p[key] = []\n      } else if (!Array.isArray(p[key])) {\n        p[key] = [p[key]]\n      }\n    }\n\n    // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n    if (Array.isArray(p[key])) {\n      p[key].push(value)\n    } else {\n      p[key] = value\n    }\n  }\n\n  // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n  const remove = []\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) ||\n      typeof out[k] !== 'object' ||\n      Array.isArray(out[k])) {\n      continue\n    }\n\n    // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n    const parts = splitSections(k, '.')\n    p = out\n    const l = parts.pop()\n    const nl = l.replace(/\\\\\\./g, '.')\n    for (const part of parts) {\n      if (part === '__proto__') {\n        continue\n      }\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object') {\n        p[part] = Object.create(null)\n      }\n      p = p[part]\n    }\n    if (p === out && nl === l) {\n      continue\n    }\n\n    p[nl] = out[k]\n    remove.push(k)\n  }\n  for (const del of remove) {\n    delete out[del]\n  }\n\n  return out\n}\n\nconst isQuoted = val => {\n  return (val.startsWith('\"') && val.endsWith('\"')) ||\n    (val.startsWith(\"'\") && val.endsWith(\"'\"))\n}\n\nconst safe = val => {\n  if (\n    typeof val !== 'string' ||\n    val.match(/[=\\r\\n]/) ||\n    val.match(/^\\[/) ||\n    (val.length > 1 && isQuoted(val)) ||\n    val !== val.trim()\n  ) {\n    return JSON.stringify(val)\n  }\n  return val.split(';').join('\\\\;').split('#').join('\\\\#')\n}\n\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim()\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.slice(1, -1)\n    }\n    try {\n      val = JSON.parse(val)\n    } catch {\n      // ignore errors\n    }\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false\n    let unesc = ''\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i)\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) {\n          unesc += c\n        } else {\n          unesc += '\\\\' + c\n        }\n\n        esc = false\n      } else if (';#'.indexOf(c) !== -1) {\n        break\n      } else if (c === '\\\\') {\n        esc = true\n      } else {\n        unesc += c\n      }\n    }\n    if (esc) {\n      unesc += '\\\\'\n    }\n\n    return unesc.trim()\n  }\n  return val\n}\n\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}