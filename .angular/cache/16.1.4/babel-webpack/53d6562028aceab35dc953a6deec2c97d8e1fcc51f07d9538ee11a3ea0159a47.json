{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst schematics_1 = require(\"@angular-devkit/schematics\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst module_1 = require(\"module\");\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\nconst npm_pick_manifest_1 = __importDefault(require(\"npm-pick-manifest\"));\nconst path = __importStar(require(\"path\"));\nconst path_1 = require(\"path\");\nconst semver = __importStar(require(\"semver\"));\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematic_engine_host_1 = require(\"../../command-builder/utilities/schematic-engine-host\");\nconst schematic_workflow_1 = require(\"../../command-builder/utilities/schematic-workflow\");\nconst color_1 = require(\"../../utilities/color\");\nconst environment_options_1 = require(\"../../utilities/environment-options\");\nconst error_1 = require(\"../../utilities/error\");\nconst log_file_1 = require(\"../../utilities/log-file\");\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\nconst package_tree_1 = require(\"../../utilities/package-tree\");\nconst prompt_1 = require(\"../../utilities/prompt\");\nconst tty_1 = require(\"../../utilities/tty\");\nconst version_1 = require(\"../../utilities/version\");\nconst ANGULAR_PACKAGES_REGEXP = /^@(?:angular|nguniversal)\\//;\nconst UPDATE_SCHEMATIC_COLLECTION = path.join(__dirname, 'schematic/collection.json');\nclass UpdateCommandModule extends command_module_1.CommandModule {\n  constructor() {\n    super(...arguments);\n    this.scope = command_module_1.CommandScope.In;\n    this.shouldReportAnalytics = false;\n    this.command = 'update [packages..]';\n    this.describe = 'Updates your workspace and its dependencies. See https://update.angular.io/.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n  }\n  builder(localYargs) {\n    return localYargs.positional('packages', {\n      description: 'The names of package(s) to update.',\n      type: 'string',\n      array: true\n    }).option('force', {\n      description: 'Ignore peer dependency version mismatches.',\n      type: 'boolean',\n      default: false\n    }).option('next', {\n      description: 'Use the prerelease version, including beta and RCs.',\n      type: 'boolean',\n      default: false\n    }).option('migrate-only', {\n      description: 'Only perform a migration, do not update the installed version.',\n      type: 'boolean'\n    }).option('name', {\n      description: 'The name of the migration to run. ' + `Only available with a single package being updated, and only with 'migrate-only' option.`,\n      type: 'string',\n      implies: ['migrate-only'],\n      conflicts: ['to', 'from']\n    }).option('from', {\n      description: 'Version from which to migrate from. ' + `Only available with a single package being updated, and only with 'migrate-only'.`,\n      type: 'string',\n      implies: ['migrate-only'],\n      conflicts: ['name']\n    }).option('to', {\n      describe: 'Version up to which to apply migrations. Only available with a single package being updated, ' + `and only with 'migrate-only' option. Requires 'from' to be specified. Default to the installed version detected.`,\n      type: 'string',\n      implies: ['from', 'migrate-only'],\n      conflicts: ['name']\n    }).option('allow-dirty', {\n      describe: 'Whether to allow updating when the repository contains modified or untracked files.',\n      type: 'boolean',\n      default: false\n    }).option('verbose', {\n      describe: 'Display additional details about internal operations during execution.',\n      type: 'boolean',\n      default: false\n    }).option('create-commits', {\n      describe: 'Create source control commits for updates and migrations.',\n      type: 'boolean',\n      alias: ['C'],\n      default: false\n    }).check(({\n      packages,\n      'allow-dirty': allowDirty,\n      'migrate-only': migrateOnly\n    }) => {\n      const {\n        logger\n      } = this.context;\n      // This allows the user to easily reset any changes from the update.\n      if (packages?.length && !this.checkCleanGit()) {\n        if (allowDirty) {\n          logger.warn('Repository is not clean. Update changes will be mixed with pre-existing changes.');\n        } else {\n          throw new command_module_1.CommandModuleError('Repository is not clean. Please commit or stash any changes before updating.');\n        }\n      }\n      if (migrateOnly) {\n        if (packages?.length !== 1) {\n          throw new command_module_1.CommandModuleError(`A single package must be specified when using the 'migrate-only' option.`);\n        }\n      }\n      return true;\n    }).strict();\n  }\n  run(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger,\n        packageManager\n      } = _this.context;\n      packageManager.ensureCompatibility();\n      // Check if the current installed CLI version is older than the latest compatible version.\n      // Skip when running `ng update` without a package name as this will not trigger an actual update.\n      if (!environment_options_1.disableVersionCheck && options.packages?.length) {\n        const cliVersionToInstall = yield _this.checkCLIVersion(options.packages, options.verbose, options.next);\n        if (cliVersionToInstall) {\n          logger.warn('The installed Angular CLI version is outdated.\\n' + `Installing a temporary Angular CLI versioned ${cliVersionToInstall} to perform the update.`);\n          return _this.runTempBinary(`@angular/cli@${cliVersionToInstall}`, process.argv.slice(2));\n        }\n      }\n      const packages = [];\n      for (const request of options.packages ?? []) {\n        try {\n          const packageIdentifier = (0, npm_package_arg_1.default)(request);\n          // only registry identifiers are supported\n          if (!packageIdentifier.registry) {\n            logger.error(`Package '${request}' is not a registry package identifer.`);\n            return 1;\n          }\n          if (packages.some(v => v.name === packageIdentifier.name)) {\n            logger.error(`Duplicate package '${packageIdentifier.name}' specified.`);\n            return 1;\n          }\n          if (options.migrateOnly && packageIdentifier.rawSpec !== '*') {\n            logger.warn('Package specifier has no effect when using \"migrate-only\" option.');\n          }\n          // If next option is used and no specifier supplied, use next tag\n          if (options.next && packageIdentifier.rawSpec === '*') {\n            packageIdentifier.fetchSpec = 'next';\n          }\n          packages.push(packageIdentifier);\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(e.message);\n          return 1;\n        }\n      }\n      logger.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n      logger.info('Collecting installed dependencies...');\n      const rootDependencies = yield (0, package_tree_1.getProjectDependencies)(_this.context.root);\n      logger.info(`Found ${rootDependencies.size} dependencies.`);\n      const workflow = new tools_1.NodeWorkflow(_this.context.root, {\n        packageManager: packageManager.name,\n        packageManagerForce: _this.packageManagerForce(options.verbose),\n        // __dirname -> favor @schematics/update from this package\n        // Otherwise, use packages from the active workspace (migrations)\n        resolvePaths: [__dirname, _this.context.root],\n        schemaValidation: true,\n        engineHostCreator: options => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths)\n      });\n      if (packages.length === 0) {\n        // Show status\n        const {\n          success\n        } = yield _this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n          force: options.force,\n          next: options.next,\n          verbose: options.verbose,\n          packageManager: packageManager.name,\n          packages: []\n        });\n        return success ? 0 : 1;\n      }\n      return options.migrateOnly ? _this.migrateOnly(workflow, (options.packages ?? [])[0], rootDependencies, options) : _this.updatePackagesAndMigrate(workflow, rootDependencies, options, packages);\n    })();\n  }\n  executeSchematic(workflow, collection, schematic, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this2.context;\n      const workflowSubscription = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger);\n      // TODO: Allow passing a schematic instance directly\n      try {\n        yield workflow.execute({\n          collection,\n          schematic,\n          options,\n          logger\n        }).toPromise();\n        return {\n          success: !workflowSubscription.error,\n          files: workflowSubscription.files\n        };\n      } catch (e) {\n        if (e instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n          logger.error(`${color_1.colors.symbols.cross} Migration failed. See above for further details.\\n`);\n        } else {\n          (0, error_1.assertIsError)(e);\n          const logPath = (0, log_file_1.writeErrorToLogFile)(e);\n          logger.fatal(`${color_1.colors.symbols.cross} Migration failed: ${e.message}\\n` + `  See \"${logPath}\" for further details.\\n`);\n        }\n        return {\n          success: false,\n          files: workflowSubscription.files\n        };\n      } finally {\n        workflowSubscription.unsubscribe();\n      }\n    })();\n  }\n  /**\n   * @return Whether or not the migration was performed successfully.\n   */\n  executeMigration(workflow, packageName, collectionPath, migrationName, commit) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this3.context;\n      const collection = workflow.engine.createCollection(collectionPath);\n      const name = collection.listSchematicNames().find(name => name === migrationName);\n      if (!name) {\n        logger.error(`Cannot find migration '${migrationName}' in '${packageName}'.`);\n        return 1;\n      }\n      logger.info(color_1.colors.cyan(`** Executing '${migrationName}' of package '${packageName}' **\\n`));\n      const schematic = workflow.engine.createSchematic(name, collection);\n      return _this3.executePackageMigrations(workflow, [schematic.description], packageName, commit);\n    })();\n  }\n  /**\n   * @return Whether or not the migrations were performed successfully.\n   */\n  executeMigrations(workflow, packageName, collectionPath, from, to, commit) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const collection = workflow.engine.createCollection(collectionPath);\n      const migrationRange = new semver.Range('>' + (semver.prerelease(from) ? from.split('-')[0] + '-0' : from) + ' <=' + to.split('-')[0]);\n      const requiredMigrations = [];\n      const optionalMigrations = [];\n      for (const name of collection.listSchematicNames()) {\n        const schematic = workflow.engine.createSchematic(name, collection);\n        const description = schematic.description;\n        description.version = coerceVersionNumber(description.version);\n        if (!description.version) {\n          continue;\n        }\n        if (semver.satisfies(description.version, migrationRange, {\n          includePrerelease: true\n        })) {\n          (description.optional ? optionalMigrations : requiredMigrations).push(description);\n        }\n      }\n      if (requiredMigrations.length === 0 && optionalMigrations.length === 0) {\n        return 0;\n      }\n      // Required migrations\n      if (requiredMigrations.length) {\n        _this4.context.logger.info(color_1.colors.cyan(`** Executing migrations of package '${packageName}' **\\n`));\n        requiredMigrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n        const result = yield _this4.executePackageMigrations(workflow, requiredMigrations, packageName, commit);\n        if (result === 1) {\n          return 1;\n        }\n      }\n      // Optional migrations\n      if (optionalMigrations.length) {\n        _this4.context.logger.info(color_1.colors.magenta(`** Optional migrations of package '${packageName}' **\\n`));\n        optionalMigrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n        const migrationsToRun = yield _this4.getOptionalMigrationsToRun(optionalMigrations, packageName);\n        if (migrationsToRun?.length) {\n          return _this4.executePackageMigrations(workflow, migrationsToRun, packageName, commit);\n        }\n      }\n      return 0;\n    })();\n  }\n  executePackageMigrations(workflow, migrations, packageName, commit = false) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this5.context;\n      for (const migration of migrations) {\n        const {\n          title,\n          description\n        } = getMigrationTitleAndDescription(migration);\n        logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) + ' ' + color_1.colors.bold(title));\n        if (description) {\n          logger.info('  ' + description);\n        }\n        const {\n          success,\n          files\n        } = yield _this5.executeSchematic(workflow, migration.collection.name, migration.name);\n        if (!success) {\n          return 1;\n        }\n        let modifiedFilesText;\n        switch (files.size) {\n          case 0:\n            modifiedFilesText = 'No changes made';\n            break;\n          case 1:\n            modifiedFilesText = '1 file modified';\n            break;\n          default:\n            modifiedFilesText = `${files.size} files modified`;\n            break;\n        }\n        logger.info(`  Migration completed (${modifiedFilesText}).`);\n        // Commit migration\n        if (commit) {\n          const commitPrefix = `${packageName} migration - ${migration.name}`;\n          const commitMessage = migration.description ? `${commitPrefix}\\n\\n${migration.description}` : commitPrefix;\n          const committed = _this5.commit(commitMessage);\n          if (!committed) {\n            // Failed to commit, something went wrong. Abort the update.\n            return 1;\n          }\n        }\n        logger.info(''); // Extra trailing newline.\n      }\n\n      return 0;\n    })();\n  }\n  migrateOnly(workflow, packageName, rootDependencies, options) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this6.context;\n      const packageDependency = rootDependencies.get(packageName);\n      let packagePath = packageDependency?.path;\n      let packageNode = packageDependency?.package;\n      if (packageDependency && !packageNode) {\n        logger.error('Package found in package.json but is not installed.');\n        return 1;\n      } else if (!packageDependency) {\n        // Allow running migrations on transitively installed dependencies\n        // There can technically be nested multiple versions\n        // TODO: If multiple, this should find all versions and ask which one to use\n        const packageJson = (0, package_tree_1.findPackageJson)(_this6.context.root, packageName);\n        if (packageJson) {\n          packagePath = path.dirname(packageJson);\n          packageNode = yield (0, package_tree_1.readPackageJson)(packageJson);\n        }\n      }\n      if (!packageNode || !packagePath) {\n        logger.error('Package is not installed.');\n        return 1;\n      }\n      const updateMetadata = packageNode['ng-update'];\n      let migrations = updateMetadata?.migrations;\n      if (migrations === undefined) {\n        logger.error('Package does not provide migrations.');\n        return 1;\n      } else if (typeof migrations !== 'string') {\n        logger.error('Package contains a malformed migrations field.');\n        return 1;\n      } else if (path.posix.isAbsolute(migrations) || path.win32.isAbsolute(migrations)) {\n        logger.error('Package contains an invalid migrations field. Absolute paths are not permitted.');\n        return 1;\n      }\n      // Normalize slashes\n      migrations = migrations.replace(/\\\\/g, '/');\n      if (migrations.startsWith('../')) {\n        logger.error('Package contains an invalid migrations field. Paths outside the package root are not permitted.');\n        return 1;\n      }\n      // Check if it is a package-local location\n      const localMigrations = path.join(packagePath, migrations);\n      if ((0, fs_1.existsSync)(localMigrations)) {\n        migrations = localMigrations;\n      } else {\n        // Try to resolve from package location.\n        // This avoids issues with package hoisting.\n        try {\n          const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n          migrations = packageRequire.resolve(migrations);\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          if (e.code === 'MODULE_NOT_FOUND') {\n            logger.error('Migrations for package were not found.');\n          } else {\n            logger.error(`Unable to resolve migrations for package.  [${e.message}]`);\n          }\n          return 1;\n        }\n      }\n      if (options.name) {\n        return _this6.executeMigration(workflow, packageName, migrations, options.name, options.createCommits);\n      }\n      const from = coerceVersionNumber(options.from);\n      if (!from) {\n        logger.error(`\"from\" value [${options.from}] is not a valid version.`);\n        return 1;\n      }\n      return _this6.executeMigrations(workflow, packageName, migrations, from, options.to || packageNode.version, options.createCommits);\n    })();\n  }\n  // eslint-disable-next-line max-lines-per-function\n  updatePackagesAndMigrate(workflow, rootDependencies, options, packages) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this7.context;\n      const logVerbose = message => {\n        if (options.verbose) {\n          logger.info(message);\n        }\n      };\n      const requests = [];\n      // Validate packages actually are part of the workspace\n      for (const pkg of packages) {\n        const node = rootDependencies.get(pkg.name);\n        if (!node?.package) {\n          logger.error(`Package '${pkg.name}' is not a dependency.`);\n          return 1;\n        }\n        // If a specific version is requested and matches the installed version, skip.\n        if (pkg.type === 'version' && node.package.version === pkg.fetchSpec) {\n          logger.info(`Package '${pkg.name}' is already at '${pkg.fetchSpec}'.`);\n          continue;\n        }\n        requests.push({\n          identifier: pkg,\n          node\n        });\n      }\n      if (requests.length === 0) {\n        return 0;\n      }\n      logger.info('Fetching dependency metadata from registry...');\n      const packagesToUpdate = [];\n      for (const {\n        identifier: requestIdentifier,\n        node\n      } of requests) {\n        const packageName = requestIdentifier.name;\n        let metadata;\n        try {\n          // Metadata requests are internally cached; multiple requests for same name\n          // does not result in additional network traffic\n          metadata = yield (0, package_metadata_1.fetchPackageMetadata)(packageName, logger, {\n            verbose: options.verbose\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(`Error fetching metadata for '${packageName}': ` + e.message);\n          return 1;\n        }\n        // Try to find a package version based on the user requested package specifier\n        // registry specifier types are either version, range, or tag\n        let manifest;\n        if (requestIdentifier.type === 'version' || requestIdentifier.type === 'range' || requestIdentifier.type === 'tag') {\n          try {\n            manifest = (0, npm_pick_manifest_1.default)(metadata, requestIdentifier.fetchSpec);\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n            if (e.code === 'ETARGET') {\n              // If not found and next was used and user did not provide a specifier, try latest.\n              // Package may not have a next tag.\n              if (requestIdentifier.type === 'tag' && requestIdentifier.fetchSpec === 'next' && !requestIdentifier.rawSpec) {\n                try {\n                  manifest = (0, npm_pick_manifest_1.default)(metadata, 'latest');\n                } catch (e) {\n                  (0, error_1.assertIsError)(e);\n                  if (e.code !== 'ETARGET' && e.code !== 'ENOVERSIONS') {\n                    throw e;\n                  }\n                }\n              }\n            } else if (e.code !== 'ENOVERSIONS') {\n              throw e;\n            }\n          }\n        }\n        if (!manifest) {\n          logger.error(`Package specified by '${requestIdentifier.raw}' does not exist within the registry.`);\n          return 1;\n        }\n        if (manifest.version === node.package?.version) {\n          logger.info(`Package '${packageName}' is already up to date.`);\n          continue;\n        }\n        if (node.package && ANGULAR_PACKAGES_REGEXP.test(node.package.name)) {\n          const {\n            name,\n            version\n          } = node.package;\n          const toBeInstalledMajorVersion = +manifest.version.split('.')[0];\n          const currentMajorVersion = +version.split('.')[0];\n          if (toBeInstalledMajorVersion - currentMajorVersion > 1) {\n            // Only allow updating a single version at a time.\n            if (currentMajorVersion < 6) {\n              // Before version 6, the major versions were not always sequential.\n              // Example @angular/core skipped version 3, @angular/cli skipped versions 2-5.\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `For more information about the update process, see https://update.angular.io/.`);\n            } else {\n              const nextMajorVersionFromCurrent = currentMajorVersion + 1;\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `Run 'ng update ${name}@${nextMajorVersionFromCurrent}' in your workspace directory ` + `to update to latest '${nextMajorVersionFromCurrent}.x' version of '${name}'.\\n\\n` + `For more information about the update process, see https://update.angular.io/?v=${currentMajorVersion}.0-${nextMajorVersionFromCurrent}.0`);\n            }\n            return 1;\n          }\n        }\n        packagesToUpdate.push(requestIdentifier.toString());\n      }\n      if (packagesToUpdate.length === 0) {\n        return 0;\n      }\n      const {\n        success\n      } = yield _this7.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n        verbose: options.verbose,\n        force: options.force,\n        next: options.next,\n        packageManager: _this7.context.packageManager.name,\n        packages: packagesToUpdate\n      });\n      if (success) {\n        try {\n          yield fs_1.promises.rm(path.join(_this7.context.root, 'node_modules'), {\n            force: true,\n            recursive: true,\n            maxRetries: 3\n          });\n        } catch {}\n        const installationSuccess = yield _this7.context.packageManager.installAll(_this7.packageManagerForce(options.verbose) ? ['--force'] : [], _this7.context.root);\n        if (!installationSuccess) {\n          return 1;\n        }\n      }\n      if (success && options.createCommits) {\n        if (!_this7.commit(`Angular CLI update for packages - ${packagesToUpdate.join(', ')}`)) {\n          return 1;\n        }\n      }\n      // This is a temporary workaround to allow data to be passed back from the update schematic\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const migrations = global.externalMigrations;\n      if (success && migrations) {\n        const rootRequire = (0, module_1.createRequire)(_this7.context.root + '/');\n        for (const migration of migrations) {\n          // Resolve the package from the workspace root, as otherwise it will be resolved from the temp\n          // installed CLI version.\n          let packagePath;\n          logVerbose(`Resolving migration package '${migration.package}' from '${_this7.context.root}'...`);\n          try {\n            try {\n              packagePath = path.dirname(\n              // This may fail if the `package.json` is not exported as an entry point\n              rootRequire.resolve(path.join(migration.package, 'package.json')));\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n              if (e.code === 'MODULE_NOT_FOUND') {\n                // Fallback to trying to resolve the package's main entry point\n                packagePath = rootRequire.resolve(migration.package);\n              } else {\n                throw e;\n              }\n            }\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n            if (e.code === 'MODULE_NOT_FOUND') {\n              logVerbose(e.toString());\n              logger.error(`Migrations for package (${migration.package}) were not found.` + ' The package could not be found in the workspace.');\n            } else {\n              logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n            }\n            return 1;\n          }\n          let migrations;\n          // Check if it is a package-local location\n          const localMigrations = path.join(packagePath, migration.collection);\n          if ((0, fs_1.existsSync)(localMigrations)) {\n            migrations = localMigrations;\n          } else {\n            // Try to resolve from package location.\n            // This avoids issues with package hoisting.\n            try {\n              const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n              migrations = packageRequire.resolve(migration.collection);\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n              if (e.code === 'MODULE_NOT_FOUND') {\n                logger.error(`Migrations for package (${migration.package}) were not found.`);\n              } else {\n                logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n              }\n              return 1;\n            }\n          }\n          const result = yield _this7.executeMigrations(workflow, migration.package, migrations, migration.from, migration.to, options.createCommits);\n          // A non-zero value is a failure for the package's migrations\n          if (result !== 0) {\n            return result;\n          }\n        }\n      }\n      return success ? 0 : 1;\n    })();\n  }\n  /**\n   * @return Whether or not the commit was successful.\n   */\n  commit(message) {\n    const {\n      logger\n    } = this.context;\n    // Check if a commit is needed.\n    let commitNeeded;\n    try {\n      commitNeeded = hasChangesToCommit();\n    } catch (err) {\n      logger.error(`  Failed to read Git tree:\\n${err.stderr}`);\n      return false;\n    }\n    if (!commitNeeded) {\n      logger.info('  No changes to commit after migration.');\n      return true;\n    }\n    // Commit changes and abort on error.\n    try {\n      createCommit(message);\n    } catch (err) {\n      logger.error(`Failed to commit update (${message}):\\n${err.stderr}`);\n      return false;\n    }\n    // Notify user of the commit.\n    const hash = findCurrentGitSha();\n    const shortMessage = message.split('\\n')[0];\n    if (hash) {\n      logger.info(`  Committed migration step (${getShortHash(hash)}): ${shortMessage}.`);\n    } else {\n      // Commit was successful, but reading the hash was not. Something weird happened,\n      // but nothing that would stop the update. Just log the weirdness and continue.\n      logger.info(`  Committed migration step: ${shortMessage}.`);\n      logger.warn('  Failed to look up hash of most recent commit, continuing anyways.');\n    }\n    return true;\n  }\n  checkCleanGit() {\n    try {\n      const topLevel = (0, child_process_1.execSync)('git rev-parse --show-toplevel', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      const result = (0, child_process_1.execSync)('git status --porcelain', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      if (result.trim().length === 0) {\n        return true;\n      }\n      // Only files inside the workspace root are relevant\n      for (const entry of result.split('\\n')) {\n        const relativeEntry = path.relative(path.resolve(this.context.root), path.resolve(topLevel.trim(), entry.slice(3).trim()));\n        if (!relativeEntry.startsWith('..') && !path.isAbsolute(relativeEntry)) {\n          return false;\n        }\n      }\n    } catch {}\n    return true;\n  }\n  /**\n   * Checks if the current installed CLI version is older or newer than a compatible version.\n   * @returns the version to install or null when there is no update to install.\n   */\n  checkCLIVersion(packagesToUpdate, verbose = false, next = false) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        version\n      } = yield (0, package_metadata_1.fetchPackageManifest)(`@angular/cli@${_this8.getCLIUpdateRunnerVersion(packagesToUpdate, next)}`, _this8.context.logger, {\n        verbose,\n        usingYarn: _this8.context.packageManager.name === workspace_schema_1.PackageManager.Yarn\n      });\n      return version_1.VERSION.full === version ? null : version;\n    })();\n  }\n  getCLIUpdateRunnerVersion(packagesToUpdate, next) {\n    if (next) {\n      return 'next';\n    }\n    const updatingAngularPackage = packagesToUpdate?.find(r => ANGULAR_PACKAGES_REGEXP.test(r));\n    if (updatingAngularPackage) {\n      // If we are updating any Angular package we can update the CLI to the target version because\n      // migrations for @angular/core@13 can be executed using Angular/cli@13.\n      // This is same behaviour as `npx @angular/cli@13 update @angular/core@13`.\n      // `@angular/cli@13` -> ['', 'angular/cli', '13']\n      // `@angular/cli` -> ['', 'angular/cli']\n      const tempVersion = coerceVersionNumber(updatingAngularPackage.split('@')[2]);\n      return semver.parse(tempVersion)?.major ?? 'latest';\n    }\n    // When not updating an Angular package we cannot determine which schematic runtime the migration should to be executed in.\n    // Typically, we can assume that the `@angular/cli` was updated previously.\n    // Example: Angular official packages are typically updated prior to NGRX etc...\n    // Therefore, we only update to the latest patch version of the installed major version of the Angular CLI.\n    // This is important because we might end up in a scenario where locally Angular v12 is installed, updating NGRX from 11 to 12.\n    // We end up using Angular ClI v13 to run the migrations if we run the migrations using the CLI installed major version + 1 logic.\n    return version_1.VERSION.major;\n  }\n  runTempBinary(packageName, args = []) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        success,\n        tempNodeModules\n      } = yield _this9.context.packageManager.installTemp(packageName);\n      if (!success) {\n        return 1;\n      }\n      // Remove version/tag etc... from package name\n      // Ex: @angular/cli@latest -> @angular/cli\n      const packageNameNoVersion = packageName.substring(0, packageName.lastIndexOf('@'));\n      const pkgLocation = (0, path_1.join)(tempNodeModules, packageNameNoVersion);\n      const packageJsonPath = (0, path_1.join)(pkgLocation, 'package.json');\n      // Get a binary location for this package\n      let binPath;\n      if ((0, fs_1.existsSync)(packageJsonPath)) {\n        const content = yield fs_1.promises.readFile(packageJsonPath, 'utf-8');\n        if (content) {\n          const {\n            bin = {}\n          } = JSON.parse(content);\n          const binKeys = Object.keys(bin);\n          if (binKeys.length) {\n            binPath = (0, path_1.resolve)(pkgLocation, bin[binKeys[0]]);\n          }\n        }\n      }\n      if (!binPath) {\n        throw new Error(`Cannot locate bin for temporary package: ${packageNameNoVersion}.`);\n      }\n      const {\n        status,\n        error\n      } = (0, child_process_1.spawnSync)(process.execPath, [binPath, ...args], {\n        stdio: 'inherit',\n        env: {\n          ...process.env,\n          NG_DISABLE_VERSION_CHECK: 'true',\n          NG_CLI_ANALYTICS: 'false'\n        }\n      });\n      if (status === null && error) {\n        throw error;\n      }\n      return status ?? 0;\n    })();\n  }\n  packageManagerForce(verbose) {\n    // npm 7+ can fail due to it incorrectly resolving peer dependencies that have valid SemVer\n    // ranges during an update. Update will set correct versions of dependencies within the\n    // package.json file. The force option is set to workaround these errors.\n    // Example error:\n    // npm ERR! Conflicting peer dependency: @angular/compiler-cli@14.0.0-rc.0\n    // npm ERR! node_modules/@angular/compiler-cli\n    // npm ERR!   peer @angular/compiler-cli@\"^14.0.0 || ^14.0.0-rc\" from @angular-devkit/build-angular@14.0.0-rc.0\n    // npm ERR!   node_modules/@angular-devkit/build-angular\n    // npm ERR!     dev @angular-devkit/build-angular@\"~14.0.0-rc.0\" from the root project\n    if (this.context.packageManager.name === workspace_schema_1.PackageManager.Npm && this.context.packageManager.version && semver.gte(this.context.packageManager.version, '7.0.0')) {\n      if (verbose) {\n        this.context.logger.info('NPM 7+ detected -- enabling force option for package installation');\n      }\n      return true;\n    }\n    return false;\n  }\n  getOptionalMigrationsToRun(optionalMigrations, packageName) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this10.context;\n      const numberOfMigrations = optionalMigrations.length;\n      logger.info(`This package has ${numberOfMigrations} optional migration${numberOfMigrations > 1 ? 's' : ''} that can be executed.`);\n      logger.info(''); // Extra trailing newline.\n      if (!(0, tty_1.isTTY)()) {\n        for (const migration of optionalMigrations) {\n          const {\n            title\n          } = getMigrationTitleAndDescription(migration);\n          logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) + ' ' + color_1.colors.bold(title));\n          logger.info(color_1.colors.gray(`  ng update ${packageName} --migration-only --name ${migration.name}`));\n          logger.info(''); // Extra trailing newline.\n        }\n\n        return undefined;\n      }\n      const answer = yield (0, prompt_1.askChoices)(`Select the migrations that you'd like to run`, optionalMigrations.map(migration => {\n        const {\n          title\n        } = getMigrationTitleAndDescription(migration);\n        return {\n          name: title,\n          value: migration.name\n        };\n      }), null);\n      logger.info(''); // Extra trailing newline.\n      return optionalMigrations.filter(({\n        name\n      }) => answer?.includes(name));\n    })();\n  }\n}\nexports.default = UpdateCommandModule;\n/**\n * @return Whether or not the working directory has Git changes to commit.\n */\nfunction hasChangesToCommit() {\n  // List all modified files not covered by .gitignore.\n  // If any files are returned, then there must be something to commit.\n  return (0, child_process_1.execSync)('git ls-files -m -d -o --exclude-standard').toString() !== '';\n}\n/**\n * Precondition: Must have pending changes to commit, they do not need to be staged.\n * Postcondition: The Git working tree is committed and the repo is clean.\n * @param message The commit message to use.\n */\nfunction createCommit(message) {\n  // Stage entire working tree for commit.\n  (0, child_process_1.execSync)('git add -A', {\n    encoding: 'utf8',\n    stdio: 'pipe'\n  });\n  // Commit with the message passed via stdin to avoid bash escaping issues.\n  (0, child_process_1.execSync)('git commit --no-verify -F -', {\n    encoding: 'utf8',\n    stdio: 'pipe',\n    input: message\n  });\n}\n/**\n * @return The Git SHA hash of the HEAD commit. Returns null if unable to retrieve the hash.\n */\nfunction findCurrentGitSha() {\n  try {\n    return (0, child_process_1.execSync)('git rev-parse HEAD', {\n      encoding: 'utf8',\n      stdio: 'pipe'\n    }).trim();\n  } catch {\n    return null;\n  }\n}\nfunction getShortHash(commitHash) {\n  return commitHash.slice(0, 9);\n}\nfunction coerceVersionNumber(version) {\n  if (!version) {\n    return undefined;\n  }\n  if (!/^\\d{1,30}\\.\\d{1,30}\\.\\d{1,30}/.test(version)) {\n    const match = version.match(/^\\d{1,30}(\\.\\d{1,30})*/);\n    if (!match) {\n      return undefined;\n    }\n    if (!match[1]) {\n      version = version.substring(0, match[0].length) + '.0.0' + version.substring(match[0].length);\n    } else if (!match[2]) {\n      version = version.substring(0, match[0].length) + '.0' + version.substring(match[0].length);\n    } else {\n      return undefined;\n    }\n  }\n  return semver.valid(version) ?? undefined;\n}\nfunction getMigrationTitleAndDescription(migration) {\n  const [title, ...description] = migration.description.split('. ');\n  return {\n    title: title.endsWith('.') ? title : title + '.',\n    description: description.join('.\\n  ')\n  };\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__importDefault","exports","schematics_1","tools_1","child_process_1","fs_1","module_1","npm_package_arg_1","npm_pick_manifest_1","path","path_1","semver","workspace_schema_1","command_module_1","schematic_engine_host_1","schematic_workflow_1","color_1","environment_options_1","error_1","log_file_1","package_metadata_1","package_tree_1","prompt_1","tty_1","version_1","ANGULAR_PACKAGES_REGEXP","UPDATE_SCHEMATIC_COLLECTION","join","__dirname","UpdateCommandModule","CommandModule","constructor","arguments","scope","CommandScope","In","shouldReportAnalytics","command","describe","longDescriptionPath","builder","localYargs","positional","description","type","array","option","implies","conflicts","alias","check","packages","allowDirty","migrateOnly","logger","context","length","checkCleanGit","warn","CommandModuleError","strict","run","options","_this","packageManager","ensureCompatibility","disableVersionCheck","cliVersionToInstall","checkCLIVersion","verbose","next","runTempBinary","process","argv","slice","request","packageIdentifier","registry","error","some","name","rawSpec","fetchSpec","push","e","assertIsError","message","info","colors","grey","rootDependencies","getProjectDependencies","root","size","workflow","NodeWorkflow","packageManagerForce","resolvePaths","schemaValidation","engineHostCreator","SchematicEngineHost","success","executeSchematic","force","updatePackagesAndMigrate","collection","schematic","_this2","workflowSubscription","subscribeToWorkflow","execute","toPromise","files","UnsuccessfulWorkflowExecution","symbols","cross","logPath","writeErrorToLogFile","fatal","unsubscribe","executeMigration","packageName","collectionPath","migrationName","commit","_this3","engine","createCollection","listSchematicNames","find","cyan","createSchematic","executePackageMigrations","executeMigrations","from","to","_this4","migrationRange","Range","prerelease","split","requiredMigrations","optionalMigrations","version","coerceVersionNumber","satisfies","includePrerelease","optional","sort","a","b","compare","localeCompare","magenta","migrationsToRun","getOptionalMigrationsToRun","migrations","_this5","migration","title","getMigrationTitleAndDescription","pointer","bold","modifiedFilesText","commitPrefix","commitMessage","committed","_this6","packageDependency","packagePath","packageNode","package","packageJson","findPackageJson","dirname","readPackageJson","updateMetadata","posix","isAbsolute","win32","replace","startsWith","localMigrations","existsSync","packageRequire","createRequire","resolve","code","createCommits","_this7","logVerbose","requests","pkg","node","identifier","packagesToUpdate","requestIdentifier","metadata","fetchPackageMetadata","manifest","raw","test","toBeInstalledMajorVersion","currentMajorVersion","nextMajorVersionFromCurrent","toString","promises","rm","recursive","maxRetries","installationSuccess","installAll","global","externalMigrations","rootRequire","commitNeeded","hasChangesToCommit","err","stderr","createCommit","hash","findCurrentGitSha","shortMessage","getShortHash","topLevel","execSync","encoding","stdio","trim","entry","relativeEntry","relative","_this8","fetchPackageManifest","getCLIUpdateRunnerVersion","usingYarn","PackageManager","Yarn","VERSION","full","updatingAngularPackage","r","tempVersion","parse","major","args","_this9","tempNodeModules","installTemp","packageNameNoVersion","substring","lastIndexOf","pkgLocation","packageJsonPath","binPath","content","readFile","bin","JSON","binKeys","keys","Error","status","spawnSync","execPath","env","NG_DISABLE_VERSION_CHECK","NG_CLI_ANALYTICS","Npm","gte","_this10","numberOfMigrations","isTTY","gray","answer","askChoices","map","filter","includes","input","commitHash","match","valid","endsWith"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular/cli/src/commands/update/cli.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst schematics_1 = require(\"@angular-devkit/schematics\");\nconst tools_1 = require(\"@angular-devkit/schematics/tools\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst module_1 = require(\"module\");\nconst npm_package_arg_1 = __importDefault(require(\"npm-package-arg\"));\nconst npm_pick_manifest_1 = __importDefault(require(\"npm-pick-manifest\"));\nconst path = __importStar(require(\"path\"));\nconst path_1 = require(\"path\");\nconst semver = __importStar(require(\"semver\"));\nconst workspace_schema_1 = require(\"../../../lib/config/workspace-schema\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematic_engine_host_1 = require(\"../../command-builder/utilities/schematic-engine-host\");\nconst schematic_workflow_1 = require(\"../../command-builder/utilities/schematic-workflow\");\nconst color_1 = require(\"../../utilities/color\");\nconst environment_options_1 = require(\"../../utilities/environment-options\");\nconst error_1 = require(\"../../utilities/error\");\nconst log_file_1 = require(\"../../utilities/log-file\");\nconst package_metadata_1 = require(\"../../utilities/package-metadata\");\nconst package_tree_1 = require(\"../../utilities/package-tree\");\nconst prompt_1 = require(\"../../utilities/prompt\");\nconst tty_1 = require(\"../../utilities/tty\");\nconst version_1 = require(\"../../utilities/version\");\nconst ANGULAR_PACKAGES_REGEXP = /^@(?:angular|nguniversal)\\//;\nconst UPDATE_SCHEMATIC_COLLECTION = path.join(__dirname, 'schematic/collection.json');\nclass UpdateCommandModule extends command_module_1.CommandModule {\n    constructor() {\n        super(...arguments);\n        this.scope = command_module_1.CommandScope.In;\n        this.shouldReportAnalytics = false;\n        this.command = 'update [packages..]';\n        this.describe = 'Updates your workspace and its dependencies. See https://update.angular.io/.';\n        this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n    }\n    builder(localYargs) {\n        return localYargs\n            .positional('packages', {\n            description: 'The names of package(s) to update.',\n            type: 'string',\n            array: true,\n        })\n            .option('force', {\n            description: 'Ignore peer dependency version mismatches.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('next', {\n            description: 'Use the prerelease version, including beta and RCs.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('migrate-only', {\n            description: 'Only perform a migration, do not update the installed version.',\n            type: 'boolean',\n        })\n            .option('name', {\n            description: 'The name of the migration to run. ' +\n                `Only available with a single package being updated, and only with 'migrate-only' option.`,\n            type: 'string',\n            implies: ['migrate-only'],\n            conflicts: ['to', 'from'],\n        })\n            .option('from', {\n            description: 'Version from which to migrate from. ' +\n                `Only available with a single package being updated, and only with 'migrate-only'.`,\n            type: 'string',\n            implies: ['migrate-only'],\n            conflicts: ['name'],\n        })\n            .option('to', {\n            describe: 'Version up to which to apply migrations. Only available with a single package being updated, ' +\n                `and only with 'migrate-only' option. Requires 'from' to be specified. Default to the installed version detected.`,\n            type: 'string',\n            implies: ['from', 'migrate-only'],\n            conflicts: ['name'],\n        })\n            .option('allow-dirty', {\n            describe: 'Whether to allow updating when the repository contains modified or untracked files.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('verbose', {\n            describe: 'Display additional details about internal operations during execution.',\n            type: 'boolean',\n            default: false,\n        })\n            .option('create-commits', {\n            describe: 'Create source control commits for updates and migrations.',\n            type: 'boolean',\n            alias: ['C'],\n            default: false,\n        })\n            .check(({ packages, 'allow-dirty': allowDirty, 'migrate-only': migrateOnly }) => {\n            const { logger } = this.context;\n            // This allows the user to easily reset any changes from the update.\n            if (packages?.length && !this.checkCleanGit()) {\n                if (allowDirty) {\n                    logger.warn('Repository is not clean. Update changes will be mixed with pre-existing changes.');\n                }\n                else {\n                    throw new command_module_1.CommandModuleError('Repository is not clean. Please commit or stash any changes before updating.');\n                }\n            }\n            if (migrateOnly) {\n                if (packages?.length !== 1) {\n                    throw new command_module_1.CommandModuleError(`A single package must be specified when using the 'migrate-only' option.`);\n                }\n            }\n            return true;\n        })\n            .strict();\n    }\n    async run(options) {\n        const { logger, packageManager } = this.context;\n        packageManager.ensureCompatibility();\n        // Check if the current installed CLI version is older than the latest compatible version.\n        // Skip when running `ng update` without a package name as this will not trigger an actual update.\n        if (!environment_options_1.disableVersionCheck && options.packages?.length) {\n            const cliVersionToInstall = await this.checkCLIVersion(options.packages, options.verbose, options.next);\n            if (cliVersionToInstall) {\n                logger.warn('The installed Angular CLI version is outdated.\\n' +\n                    `Installing a temporary Angular CLI versioned ${cliVersionToInstall} to perform the update.`);\n                return this.runTempBinary(`@angular/cli@${cliVersionToInstall}`, process.argv.slice(2));\n            }\n        }\n        const packages = [];\n        for (const request of options.packages ?? []) {\n            try {\n                const packageIdentifier = (0, npm_package_arg_1.default)(request);\n                // only registry identifiers are supported\n                if (!packageIdentifier.registry) {\n                    logger.error(`Package '${request}' is not a registry package identifer.`);\n                    return 1;\n                }\n                if (packages.some((v) => v.name === packageIdentifier.name)) {\n                    logger.error(`Duplicate package '${packageIdentifier.name}' specified.`);\n                    return 1;\n                }\n                if (options.migrateOnly && packageIdentifier.rawSpec !== '*') {\n                    logger.warn('Package specifier has no effect when using \"migrate-only\" option.');\n                }\n                // If next option is used and no specifier supplied, use next tag\n                if (options.next && packageIdentifier.rawSpec === '*') {\n                    packageIdentifier.fetchSpec = 'next';\n                }\n                packages.push(packageIdentifier);\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                logger.error(e.message);\n                return 1;\n            }\n        }\n        logger.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n        logger.info('Collecting installed dependencies...');\n        const rootDependencies = await (0, package_tree_1.getProjectDependencies)(this.context.root);\n        logger.info(`Found ${rootDependencies.size} dependencies.`);\n        const workflow = new tools_1.NodeWorkflow(this.context.root, {\n            packageManager: packageManager.name,\n            packageManagerForce: this.packageManagerForce(options.verbose),\n            // __dirname -> favor @schematics/update from this package\n            // Otherwise, use packages from the active workspace (migrations)\n            resolvePaths: [__dirname, this.context.root],\n            schemaValidation: true,\n            engineHostCreator: (options) => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths),\n        });\n        if (packages.length === 0) {\n            // Show status\n            const { success } = await this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n                force: options.force,\n                next: options.next,\n                verbose: options.verbose,\n                packageManager: packageManager.name,\n                packages: [],\n            });\n            return success ? 0 : 1;\n        }\n        return options.migrateOnly\n            ? this.migrateOnly(workflow, (options.packages ?? [])[0], rootDependencies, options)\n            : this.updatePackagesAndMigrate(workflow, rootDependencies, options, packages);\n    }\n    async executeSchematic(workflow, collection, schematic, options = {}) {\n        const { logger } = this.context;\n        const workflowSubscription = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger);\n        // TODO: Allow passing a schematic instance directly\n        try {\n            await workflow\n                .execute({\n                collection,\n                schematic,\n                options,\n                logger,\n            })\n                .toPromise();\n            return { success: !workflowSubscription.error, files: workflowSubscription.files };\n        }\n        catch (e) {\n            if (e instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n                logger.error(`${color_1.colors.symbols.cross} Migration failed. See above for further details.\\n`);\n            }\n            else {\n                (0, error_1.assertIsError)(e);\n                const logPath = (0, log_file_1.writeErrorToLogFile)(e);\n                logger.fatal(`${color_1.colors.symbols.cross} Migration failed: ${e.message}\\n` +\n                    `  See \"${logPath}\" for further details.\\n`);\n            }\n            return { success: false, files: workflowSubscription.files };\n        }\n        finally {\n            workflowSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @return Whether or not the migration was performed successfully.\n     */\n    async executeMigration(workflow, packageName, collectionPath, migrationName, commit) {\n        const { logger } = this.context;\n        const collection = workflow.engine.createCollection(collectionPath);\n        const name = collection.listSchematicNames().find((name) => name === migrationName);\n        if (!name) {\n            logger.error(`Cannot find migration '${migrationName}' in '${packageName}'.`);\n            return 1;\n        }\n        logger.info(color_1.colors.cyan(`** Executing '${migrationName}' of package '${packageName}' **\\n`));\n        const schematic = workflow.engine.createSchematic(name, collection);\n        return this.executePackageMigrations(workflow, [schematic.description], packageName, commit);\n    }\n    /**\n     * @return Whether or not the migrations were performed successfully.\n     */\n    async executeMigrations(workflow, packageName, collectionPath, from, to, commit) {\n        const collection = workflow.engine.createCollection(collectionPath);\n        const migrationRange = new semver.Range('>' + (semver.prerelease(from) ? from.split('-')[0] + '-0' : from) + ' <=' + to.split('-')[0]);\n        const requiredMigrations = [];\n        const optionalMigrations = [];\n        for (const name of collection.listSchematicNames()) {\n            const schematic = workflow.engine.createSchematic(name, collection);\n            const description = schematic.description;\n            description.version = coerceVersionNumber(description.version);\n            if (!description.version) {\n                continue;\n            }\n            if (semver.satisfies(description.version, migrationRange, { includePrerelease: true })) {\n                (description.optional ? optionalMigrations : requiredMigrations).push(description);\n            }\n        }\n        if (requiredMigrations.length === 0 && optionalMigrations.length === 0) {\n            return 0;\n        }\n        // Required migrations\n        if (requiredMigrations.length) {\n            this.context.logger.info(color_1.colors.cyan(`** Executing migrations of package '${packageName}' **\\n`));\n            requiredMigrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n            const result = await this.executePackageMigrations(workflow, requiredMigrations, packageName, commit);\n            if (result === 1) {\n                return 1;\n            }\n        }\n        // Optional migrations\n        if (optionalMigrations.length) {\n            this.context.logger.info(color_1.colors.magenta(`** Optional migrations of package '${packageName}' **\\n`));\n            optionalMigrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n            const migrationsToRun = await this.getOptionalMigrationsToRun(optionalMigrations, packageName);\n            if (migrationsToRun?.length) {\n                return this.executePackageMigrations(workflow, migrationsToRun, packageName, commit);\n            }\n        }\n        return 0;\n    }\n    async executePackageMigrations(workflow, migrations, packageName, commit = false) {\n        const { logger } = this.context;\n        for (const migration of migrations) {\n            const { title, description } = getMigrationTitleAndDescription(migration);\n            logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) + ' ' + color_1.colors.bold(title));\n            if (description) {\n                logger.info('  ' + description);\n            }\n            const { success, files } = await this.executeSchematic(workflow, migration.collection.name, migration.name);\n            if (!success) {\n                return 1;\n            }\n            let modifiedFilesText;\n            switch (files.size) {\n                case 0:\n                    modifiedFilesText = 'No changes made';\n                    break;\n                case 1:\n                    modifiedFilesText = '1 file modified';\n                    break;\n                default:\n                    modifiedFilesText = `${files.size} files modified`;\n                    break;\n            }\n            logger.info(`  Migration completed (${modifiedFilesText}).`);\n            // Commit migration\n            if (commit) {\n                const commitPrefix = `${packageName} migration - ${migration.name}`;\n                const commitMessage = migration.description\n                    ? `${commitPrefix}\\n\\n${migration.description}`\n                    : commitPrefix;\n                const committed = this.commit(commitMessage);\n                if (!committed) {\n                    // Failed to commit, something went wrong. Abort the update.\n                    return 1;\n                }\n            }\n            logger.info(''); // Extra trailing newline.\n        }\n        return 0;\n    }\n    async migrateOnly(workflow, packageName, rootDependencies, options) {\n        const { logger } = this.context;\n        const packageDependency = rootDependencies.get(packageName);\n        let packagePath = packageDependency?.path;\n        let packageNode = packageDependency?.package;\n        if (packageDependency && !packageNode) {\n            logger.error('Package found in package.json but is not installed.');\n            return 1;\n        }\n        else if (!packageDependency) {\n            // Allow running migrations on transitively installed dependencies\n            // There can technically be nested multiple versions\n            // TODO: If multiple, this should find all versions and ask which one to use\n            const packageJson = (0, package_tree_1.findPackageJson)(this.context.root, packageName);\n            if (packageJson) {\n                packagePath = path.dirname(packageJson);\n                packageNode = await (0, package_tree_1.readPackageJson)(packageJson);\n            }\n        }\n        if (!packageNode || !packagePath) {\n            logger.error('Package is not installed.');\n            return 1;\n        }\n        const updateMetadata = packageNode['ng-update'];\n        let migrations = updateMetadata?.migrations;\n        if (migrations === undefined) {\n            logger.error('Package does not provide migrations.');\n            return 1;\n        }\n        else if (typeof migrations !== 'string') {\n            logger.error('Package contains a malformed migrations field.');\n            return 1;\n        }\n        else if (path.posix.isAbsolute(migrations) || path.win32.isAbsolute(migrations)) {\n            logger.error('Package contains an invalid migrations field. Absolute paths are not permitted.');\n            return 1;\n        }\n        // Normalize slashes\n        migrations = migrations.replace(/\\\\/g, '/');\n        if (migrations.startsWith('../')) {\n            logger.error('Package contains an invalid migrations field. Paths outside the package root are not permitted.');\n            return 1;\n        }\n        // Check if it is a package-local location\n        const localMigrations = path.join(packagePath, migrations);\n        if ((0, fs_1.existsSync)(localMigrations)) {\n            migrations = localMigrations;\n        }\n        else {\n            // Try to resolve from package location.\n            // This avoids issues with package hoisting.\n            try {\n                const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n                migrations = packageRequire.resolve(migrations);\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                if (e.code === 'MODULE_NOT_FOUND') {\n                    logger.error('Migrations for package were not found.');\n                }\n                else {\n                    logger.error(`Unable to resolve migrations for package.  [${e.message}]`);\n                }\n                return 1;\n            }\n        }\n        if (options.name) {\n            return this.executeMigration(workflow, packageName, migrations, options.name, options.createCommits);\n        }\n        const from = coerceVersionNumber(options.from);\n        if (!from) {\n            logger.error(`\"from\" value [${options.from}] is not a valid version.`);\n            return 1;\n        }\n        return this.executeMigrations(workflow, packageName, migrations, from, options.to || packageNode.version, options.createCommits);\n    }\n    // eslint-disable-next-line max-lines-per-function\n    async updatePackagesAndMigrate(workflow, rootDependencies, options, packages) {\n        const { logger } = this.context;\n        const logVerbose = (message) => {\n            if (options.verbose) {\n                logger.info(message);\n            }\n        };\n        const requests = [];\n        // Validate packages actually are part of the workspace\n        for (const pkg of packages) {\n            const node = rootDependencies.get(pkg.name);\n            if (!node?.package) {\n                logger.error(`Package '${pkg.name}' is not a dependency.`);\n                return 1;\n            }\n            // If a specific version is requested and matches the installed version, skip.\n            if (pkg.type === 'version' && node.package.version === pkg.fetchSpec) {\n                logger.info(`Package '${pkg.name}' is already at '${pkg.fetchSpec}'.`);\n                continue;\n            }\n            requests.push({ identifier: pkg, node });\n        }\n        if (requests.length === 0) {\n            return 0;\n        }\n        logger.info('Fetching dependency metadata from registry...');\n        const packagesToUpdate = [];\n        for (const { identifier: requestIdentifier, node } of requests) {\n            const packageName = requestIdentifier.name;\n            let metadata;\n            try {\n                // Metadata requests are internally cached; multiple requests for same name\n                // does not result in additional network traffic\n                metadata = await (0, package_metadata_1.fetchPackageMetadata)(packageName, logger, {\n                    verbose: options.verbose,\n                });\n            }\n            catch (e) {\n                (0, error_1.assertIsError)(e);\n                logger.error(`Error fetching metadata for '${packageName}': ` + e.message);\n                return 1;\n            }\n            // Try to find a package version based on the user requested package specifier\n            // registry specifier types are either version, range, or tag\n            let manifest;\n            if (requestIdentifier.type === 'version' ||\n                requestIdentifier.type === 'range' ||\n                requestIdentifier.type === 'tag') {\n                try {\n                    manifest = (0, npm_pick_manifest_1.default)(metadata, requestIdentifier.fetchSpec);\n                }\n                catch (e) {\n                    (0, error_1.assertIsError)(e);\n                    if (e.code === 'ETARGET') {\n                        // If not found and next was used and user did not provide a specifier, try latest.\n                        // Package may not have a next tag.\n                        if (requestIdentifier.type === 'tag' &&\n                            requestIdentifier.fetchSpec === 'next' &&\n                            !requestIdentifier.rawSpec) {\n                            try {\n                                manifest = (0, npm_pick_manifest_1.default)(metadata, 'latest');\n                            }\n                            catch (e) {\n                                (0, error_1.assertIsError)(e);\n                                if (e.code !== 'ETARGET' && e.code !== 'ENOVERSIONS') {\n                                    throw e;\n                                }\n                            }\n                        }\n                    }\n                    else if (e.code !== 'ENOVERSIONS') {\n                        throw e;\n                    }\n                }\n            }\n            if (!manifest) {\n                logger.error(`Package specified by '${requestIdentifier.raw}' does not exist within the registry.`);\n                return 1;\n            }\n            if (manifest.version === node.package?.version) {\n                logger.info(`Package '${packageName}' is already up to date.`);\n                continue;\n            }\n            if (node.package && ANGULAR_PACKAGES_REGEXP.test(node.package.name)) {\n                const { name, version } = node.package;\n                const toBeInstalledMajorVersion = +manifest.version.split('.')[0];\n                const currentMajorVersion = +version.split('.')[0];\n                if (toBeInstalledMajorVersion - currentMajorVersion > 1) {\n                    // Only allow updating a single version at a time.\n                    if (currentMajorVersion < 6) {\n                        // Before version 6, the major versions were not always sequential.\n                        // Example @angular/core skipped version 3, @angular/cli skipped versions 2-5.\n                        logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` +\n                            `For more information about the update process, see https://update.angular.io/.`);\n                    }\n                    else {\n                        const nextMajorVersionFromCurrent = currentMajorVersion + 1;\n                        logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` +\n                            `Run 'ng update ${name}@${nextMajorVersionFromCurrent}' in your workspace directory ` +\n                            `to update to latest '${nextMajorVersionFromCurrent}.x' version of '${name}'.\\n\\n` +\n                            `For more information about the update process, see https://update.angular.io/?v=${currentMajorVersion}.0-${nextMajorVersionFromCurrent}.0`);\n                    }\n                    return 1;\n                }\n            }\n            packagesToUpdate.push(requestIdentifier.toString());\n        }\n        if (packagesToUpdate.length === 0) {\n            return 0;\n        }\n        const { success } = await this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n            verbose: options.verbose,\n            force: options.force,\n            next: options.next,\n            packageManager: this.context.packageManager.name,\n            packages: packagesToUpdate,\n        });\n        if (success) {\n            try {\n                await fs_1.promises.rm(path.join(this.context.root, 'node_modules'), {\n                    force: true,\n                    recursive: true,\n                    maxRetries: 3,\n                });\n            }\n            catch { }\n            const installationSuccess = await this.context.packageManager.installAll(this.packageManagerForce(options.verbose) ? ['--force'] : [], this.context.root);\n            if (!installationSuccess) {\n                return 1;\n            }\n        }\n        if (success && options.createCommits) {\n            if (!this.commit(`Angular CLI update for packages - ${packagesToUpdate.join(', ')}`)) {\n                return 1;\n            }\n        }\n        // This is a temporary workaround to allow data to be passed back from the update schematic\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const migrations = global.externalMigrations;\n        if (success && migrations) {\n            const rootRequire = (0, module_1.createRequire)(this.context.root + '/');\n            for (const migration of migrations) {\n                // Resolve the package from the workspace root, as otherwise it will be resolved from the temp\n                // installed CLI version.\n                let packagePath;\n                logVerbose(`Resolving migration package '${migration.package}' from '${this.context.root}'...`);\n                try {\n                    try {\n                        packagePath = path.dirname(\n                        // This may fail if the `package.json` is not exported as an entry point\n                        rootRequire.resolve(path.join(migration.package, 'package.json')));\n                    }\n                    catch (e) {\n                        (0, error_1.assertIsError)(e);\n                        if (e.code === 'MODULE_NOT_FOUND') {\n                            // Fallback to trying to resolve the package's main entry point\n                            packagePath = rootRequire.resolve(migration.package);\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                }\n                catch (e) {\n                    (0, error_1.assertIsError)(e);\n                    if (e.code === 'MODULE_NOT_FOUND') {\n                        logVerbose(e.toString());\n                        logger.error(`Migrations for package (${migration.package}) were not found.` +\n                            ' The package could not be found in the workspace.');\n                    }\n                    else {\n                        logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n                    }\n                    return 1;\n                }\n                let migrations;\n                // Check if it is a package-local location\n                const localMigrations = path.join(packagePath, migration.collection);\n                if ((0, fs_1.existsSync)(localMigrations)) {\n                    migrations = localMigrations;\n                }\n                else {\n                    // Try to resolve from package location.\n                    // This avoids issues with package hoisting.\n                    try {\n                        const packageRequire = (0, module_1.createRequire)(packagePath + '/');\n                        migrations = packageRequire.resolve(migration.collection);\n                    }\n                    catch (e) {\n                        (0, error_1.assertIsError)(e);\n                        if (e.code === 'MODULE_NOT_FOUND') {\n                            logger.error(`Migrations for package (${migration.package}) were not found.`);\n                        }\n                        else {\n                            logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n                        }\n                        return 1;\n                    }\n                }\n                const result = await this.executeMigrations(workflow, migration.package, migrations, migration.from, migration.to, options.createCommits);\n                // A non-zero value is a failure for the package's migrations\n                if (result !== 0) {\n                    return result;\n                }\n            }\n        }\n        return success ? 0 : 1;\n    }\n    /**\n     * @return Whether or not the commit was successful.\n     */\n    commit(message) {\n        const { logger } = this.context;\n        // Check if a commit is needed.\n        let commitNeeded;\n        try {\n            commitNeeded = hasChangesToCommit();\n        }\n        catch (err) {\n            logger.error(`  Failed to read Git tree:\\n${err.stderr}`);\n            return false;\n        }\n        if (!commitNeeded) {\n            logger.info('  No changes to commit after migration.');\n            return true;\n        }\n        // Commit changes and abort on error.\n        try {\n            createCommit(message);\n        }\n        catch (err) {\n            logger.error(`Failed to commit update (${message}):\\n${err.stderr}`);\n            return false;\n        }\n        // Notify user of the commit.\n        const hash = findCurrentGitSha();\n        const shortMessage = message.split('\\n')[0];\n        if (hash) {\n            logger.info(`  Committed migration step (${getShortHash(hash)}): ${shortMessage}.`);\n        }\n        else {\n            // Commit was successful, but reading the hash was not. Something weird happened,\n            // but nothing that would stop the update. Just log the weirdness and continue.\n            logger.info(`  Committed migration step: ${shortMessage}.`);\n            logger.warn('  Failed to look up hash of most recent commit, continuing anyways.');\n        }\n        return true;\n    }\n    checkCleanGit() {\n        try {\n            const topLevel = (0, child_process_1.execSync)('git rev-parse --show-toplevel', {\n                encoding: 'utf8',\n                stdio: 'pipe',\n            });\n            const result = (0, child_process_1.execSync)('git status --porcelain', { encoding: 'utf8', stdio: 'pipe' });\n            if (result.trim().length === 0) {\n                return true;\n            }\n            // Only files inside the workspace root are relevant\n            for (const entry of result.split('\\n')) {\n                const relativeEntry = path.relative(path.resolve(this.context.root), path.resolve(topLevel.trim(), entry.slice(3).trim()));\n                if (!relativeEntry.startsWith('..') && !path.isAbsolute(relativeEntry)) {\n                    return false;\n                }\n            }\n        }\n        catch { }\n        return true;\n    }\n    /**\n     * Checks if the current installed CLI version is older or newer than a compatible version.\n     * @returns the version to install or null when there is no update to install.\n     */\n    async checkCLIVersion(packagesToUpdate, verbose = false, next = false) {\n        const { version } = await (0, package_metadata_1.fetchPackageManifest)(`@angular/cli@${this.getCLIUpdateRunnerVersion(packagesToUpdate, next)}`, this.context.logger, {\n            verbose,\n            usingYarn: this.context.packageManager.name === workspace_schema_1.PackageManager.Yarn,\n        });\n        return version_1.VERSION.full === version ? null : version;\n    }\n    getCLIUpdateRunnerVersion(packagesToUpdate, next) {\n        if (next) {\n            return 'next';\n        }\n        const updatingAngularPackage = packagesToUpdate?.find((r) => ANGULAR_PACKAGES_REGEXP.test(r));\n        if (updatingAngularPackage) {\n            // If we are updating any Angular package we can update the CLI to the target version because\n            // migrations for @angular/core@13 can be executed using Angular/cli@13.\n            // This is same behaviour as `npx @angular/cli@13 update @angular/core@13`.\n            // `@angular/cli@13` -> ['', 'angular/cli', '13']\n            // `@angular/cli` -> ['', 'angular/cli']\n            const tempVersion = coerceVersionNumber(updatingAngularPackage.split('@')[2]);\n            return semver.parse(tempVersion)?.major ?? 'latest';\n        }\n        // When not updating an Angular package we cannot determine which schematic runtime the migration should to be executed in.\n        // Typically, we can assume that the `@angular/cli` was updated previously.\n        // Example: Angular official packages are typically updated prior to NGRX etc...\n        // Therefore, we only update to the latest patch version of the installed major version of the Angular CLI.\n        // This is important because we might end up in a scenario where locally Angular v12 is installed, updating NGRX from 11 to 12.\n        // We end up using Angular ClI v13 to run the migrations if we run the migrations using the CLI installed major version + 1 logic.\n        return version_1.VERSION.major;\n    }\n    async runTempBinary(packageName, args = []) {\n        const { success, tempNodeModules } = await this.context.packageManager.installTemp(packageName);\n        if (!success) {\n            return 1;\n        }\n        // Remove version/tag etc... from package name\n        // Ex: @angular/cli@latest -> @angular/cli\n        const packageNameNoVersion = packageName.substring(0, packageName.lastIndexOf('@'));\n        const pkgLocation = (0, path_1.join)(tempNodeModules, packageNameNoVersion);\n        const packageJsonPath = (0, path_1.join)(pkgLocation, 'package.json');\n        // Get a binary location for this package\n        let binPath;\n        if ((0, fs_1.existsSync)(packageJsonPath)) {\n            const content = await fs_1.promises.readFile(packageJsonPath, 'utf-8');\n            if (content) {\n                const { bin = {} } = JSON.parse(content);\n                const binKeys = Object.keys(bin);\n                if (binKeys.length) {\n                    binPath = (0, path_1.resolve)(pkgLocation, bin[binKeys[0]]);\n                }\n            }\n        }\n        if (!binPath) {\n            throw new Error(`Cannot locate bin for temporary package: ${packageNameNoVersion}.`);\n        }\n        const { status, error } = (0, child_process_1.spawnSync)(process.execPath, [binPath, ...args], {\n            stdio: 'inherit',\n            env: {\n                ...process.env,\n                NG_DISABLE_VERSION_CHECK: 'true',\n                NG_CLI_ANALYTICS: 'false',\n            },\n        });\n        if (status === null && error) {\n            throw error;\n        }\n        return status ?? 0;\n    }\n    packageManagerForce(verbose) {\n        // npm 7+ can fail due to it incorrectly resolving peer dependencies that have valid SemVer\n        // ranges during an update. Update will set correct versions of dependencies within the\n        // package.json file. The force option is set to workaround these errors.\n        // Example error:\n        // npm ERR! Conflicting peer dependency: @angular/compiler-cli@14.0.0-rc.0\n        // npm ERR! node_modules/@angular/compiler-cli\n        // npm ERR!   peer @angular/compiler-cli@\"^14.0.0 || ^14.0.0-rc\" from @angular-devkit/build-angular@14.0.0-rc.0\n        // npm ERR!   node_modules/@angular-devkit/build-angular\n        // npm ERR!     dev @angular-devkit/build-angular@\"~14.0.0-rc.0\" from the root project\n        if (this.context.packageManager.name === workspace_schema_1.PackageManager.Npm &&\n            this.context.packageManager.version &&\n            semver.gte(this.context.packageManager.version, '7.0.0')) {\n            if (verbose) {\n                this.context.logger.info('NPM 7+ detected -- enabling force option for package installation');\n            }\n            return true;\n        }\n        return false;\n    }\n    async getOptionalMigrationsToRun(optionalMigrations, packageName) {\n        const { logger } = this.context;\n        const numberOfMigrations = optionalMigrations.length;\n        logger.info(`This package has ${numberOfMigrations} optional migration${numberOfMigrations > 1 ? 's' : ''} that can be executed.`);\n        logger.info(''); // Extra trailing newline.\n        if (!(0, tty_1.isTTY)()) {\n            for (const migration of optionalMigrations) {\n                const { title } = getMigrationTitleAndDescription(migration);\n                logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) + ' ' + color_1.colors.bold(title));\n                logger.info(color_1.colors.gray(`  ng update ${packageName} --migration-only --name ${migration.name}`));\n                logger.info(''); // Extra trailing newline.\n            }\n            return undefined;\n        }\n        const answer = await (0, prompt_1.askChoices)(`Select the migrations that you'd like to run`, optionalMigrations.map((migration) => {\n            const { title } = getMigrationTitleAndDescription(migration);\n            return {\n                name: title,\n                value: migration.name,\n            };\n        }), null);\n        logger.info(''); // Extra trailing newline.\n        return optionalMigrations.filter(({ name }) => answer?.includes(name));\n    }\n}\nexports.default = UpdateCommandModule;\n/**\n * @return Whether or not the working directory has Git changes to commit.\n */\nfunction hasChangesToCommit() {\n    // List all modified files not covered by .gitignore.\n    // If any files are returned, then there must be something to commit.\n    return (0, child_process_1.execSync)('git ls-files -m -d -o --exclude-standard').toString() !== '';\n}\n/**\n * Precondition: Must have pending changes to commit, they do not need to be staged.\n * Postcondition: The Git working tree is committed and the repo is clean.\n * @param message The commit message to use.\n */\nfunction createCommit(message) {\n    // Stage entire working tree for commit.\n    (0, child_process_1.execSync)('git add -A', { encoding: 'utf8', stdio: 'pipe' });\n    // Commit with the message passed via stdin to avoid bash escaping issues.\n    (0, child_process_1.execSync)('git commit --no-verify -F -', { encoding: 'utf8', stdio: 'pipe', input: message });\n}\n/**\n * @return The Git SHA hash of the HEAD commit. Returns null if unable to retrieve the hash.\n */\nfunction findCurrentGitSha() {\n    try {\n        return (0, child_process_1.execSync)('git rev-parse HEAD', { encoding: 'utf8', stdio: 'pipe' }).trim();\n    }\n    catch {\n        return null;\n    }\n}\nfunction getShortHash(commitHash) {\n    return commitHash.slice(0, 9);\n}\nfunction coerceVersionNumber(version) {\n    if (!version) {\n        return undefined;\n    }\n    if (!/^\\d{1,30}\\.\\d{1,30}\\.\\d{1,30}/.test(version)) {\n        const match = version.match(/^\\d{1,30}(\\.\\d{1,30})*/);\n        if (!match) {\n            return undefined;\n        }\n        if (!match[1]) {\n            version = version.substring(0, match[0].length) + '.0.0' + version.substring(match[0].length);\n        }\n        else if (!match[2]) {\n            version = version.substring(0, match[0].length) + '.0' + version.substring(match[0].length);\n        }\n        else {\n            return undefined;\n        }\n    }\n    return semver.valid(version) ?? undefined;\n}\nfunction getMigrationTitleAndDescription(migration) {\n    const [title, ...description] = migration.description.split('. ');\n    return {\n        title: title.endsWith('.') ? title : title + '.',\n        description: description.join('.\\n  '),\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}