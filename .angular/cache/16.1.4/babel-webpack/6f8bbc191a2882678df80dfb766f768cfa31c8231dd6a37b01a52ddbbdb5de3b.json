{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar _awaitAsyncGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\nvar _wrapAsyncGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst core_1 = require(\"@angular-devkit/core\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematics_command_module_1 = require(\"../../command-builder/schematics-command-module\");\nconst command_1 = require(\"../../command-builder/utilities/command\");\nconst command_config_1 = require(\"../command-config\");\nclass GenerateCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n  constructor() {\n    super(...arguments);\n    this.command = 'generate';\n    this.aliases = command_config_1.RootCommands['generate'].aliases;\n    this.describe = 'Generates and/or modifies files based on a schematic.';\n  }\n  builder(argv) {\n    var _superprop_getBuilder = () => super.builder,\n      _this2 = this;\n    return _asyncToGenerator(function* () {\n      let localYargs = (yield _superprop_getBuilder().call(_this2, argv)).command({\n        command: '$0 <schematic>',\n        describe: 'Run the provided schematic.',\n        builder: localYargs => localYargs.positional('schematic', {\n          describe: 'The [collection:schematic] to run.',\n          type: 'string',\n          demandOption: true\n        }).strict(),\n        handler: options => _this2.handler(options)\n      });\n      for (const [schematicName, collectionName] of yield _this2.getSchematicsToRegister()) {\n        const workflow = _this2.getOrCreateWorkflowForBuilder(collectionName);\n        const collection = workflow.engine.createCollection(collectionName);\n        const {\n          description: {\n            schemaJson,\n            aliases: schematicAliases,\n            hidden: schematicHidden,\n            description: schematicDescription\n          }\n        } = collection.createSchematic(schematicName, true);\n        if (!schemaJson) {\n          continue;\n        }\n        const {\n          'x-deprecated': xDeprecated,\n          description = schematicDescription,\n          hidden = schematicHidden\n        } = schemaJson;\n        const options = yield _this2.getSchematicOptions(collection, schematicName, workflow);\n        localYargs = localYargs.command({\n          command: yield _this2.generateCommandString(collectionName, schematicName, options),\n          // When 'describe' is set to false, it results in a hidden command.\n          describe: hidden === true ? false : typeof description === 'string' ? description : '',\n          deprecated: xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : false,\n          aliases: Array.isArray(schematicAliases) ? yield _this2.generateCommandAliasesStrings(collectionName, schematicAliases) : undefined,\n          builder: localYargs => _this2.addSchemaOptionsToCommand(localYargs, options).strict(),\n          handler: options => _this2.handler({\n            ...options,\n            schematic: `${collectionName}:${schematicName}`\n          })\n        });\n      }\n      return localYargs.demandCommand(1, command_1.demandCommandFailureMessage);\n    })();\n  }\n  run(options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        dryRun,\n        schematic,\n        defaults,\n        force,\n        interactive,\n        ...schematicOptions\n      } = options;\n      const [collectionName, schematicName] = _this3.parseSchematicInfo(schematic);\n      if (!collectionName || !schematicName) {\n        throw new command_module_1.CommandModuleError('A collection and schematic is required during execution.');\n      }\n      return _this3.runSchematic({\n        collectionName,\n        schematicName,\n        schematicOptions,\n        executionOptions: {\n          dryRun,\n          defaults,\n          force,\n          interactive\n        }\n      });\n    })();\n  }\n  getCollectionNames() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const [collectionName] = _this4.parseSchematicInfo(\n      // positional = [generate, component] or [generate]\n      _this4.context.args.positional[1]);\n      return collectionName ? [collectionName] : [...(yield _this4.getSchematicCollections())];\n    })();\n  }\n  shouldAddCollectionNameAsPartOfCommand() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const [collectionNameFromArgs] = _this5.parseSchematicInfo(\n      // positional = [generate, component] or [generate]\n      _this5.context.args.positional[1]);\n      const schematicCollectionsFromConfig = yield _this5.getSchematicCollections();\n      const collectionNames = yield _this5.getCollectionNames();\n      // Only add the collection name as part of the command when it's not a known\n      // schematics collection or when it has been provided via the CLI.\n      // Ex:`ng generate @schematics/angular:c`\n      return !!collectionNameFromArgs || !collectionNames.some(c => schematicCollectionsFromConfig.has(c));\n    })();\n  }\n  /**\n   * Generate an aliases string array to be passed to the command builder.\n   *\n   * @example `[component]` or `[@schematics/angular:component]`.\n   */\n  generateCommandAliasesStrings(collectionName, schematicAliases) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      // Only add the collection name as part of the command when it's not a known\n      // schematics collection or when it has been provided via the CLI.\n      // Ex:`ng generate @schematics/angular:c`\n      return (yield _this6.shouldAddCollectionNameAsPartOfCommand()) ? schematicAliases.map(alias => `${collectionName}:${alias}`) : schematicAliases;\n    })();\n  }\n  /**\n   * Generate a command string to be passed to the command builder.\n   *\n   * @example `component [name]` or `@schematics/angular:component [name]`.\n   */\n  generateCommandString(collectionName, schematicName, options) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const dasherizedSchematicName = core_1.strings.dasherize(schematicName);\n      // Only add the collection name as part of the command when it's not a known\n      // schematics collection or when it has been provided via the CLI.\n      // Ex:`ng generate @schematics/angular:component`\n      const commandName = (yield _this7.shouldAddCollectionNameAsPartOfCommand()) ? collectionName + ':' + dasherizedSchematicName : dasherizedSchematicName;\n      const positionalArgs = options.filter(o => o.positional !== undefined).map(o => {\n        const label = `${core_1.strings.dasherize(o.name)}${o.type === 'array' ? ' ..' : ''}`;\n        return o.required ? `<${label}>` : `[${label}]`;\n      }).join(' ');\n      return `${commandName}${positionalArgs ? ' ' + positionalArgs : ''}`;\n    })();\n  }\n  /**\n   * Get schematics that can to be registered as subcommands.\n   */\n  getSchematics() {\n    var _this = this;\n    return _wrapAsyncGenerator(function* () {\n      const seenNames = new Set();\n      for (const collectionName of yield _awaitAsyncGenerator(_this.getCollectionNames())) {\n        const workflow = _this.getOrCreateWorkflowForBuilder(collectionName);\n        const collection = workflow.engine.createCollection(collectionName);\n        for (const schematicName of collection.listSchematicNames(true /** includeHidden */)) {\n          // If a schematic with this same name is already registered skip.\n          if (!seenNames.has(schematicName)) {\n            seenNames.add(schematicName);\n            yield {\n              schematicName,\n              collectionName,\n              schematicAliases: _this.listSchematicAliases(collection, schematicName)\n            };\n          }\n        }\n      }\n    })();\n  }\n  listSchematicAliases(collection, schematicName) {\n    const description = collection.description.schematics[schematicName];\n    if (description) {\n      return description.aliases && new Set(description.aliases);\n    }\n    // Extended collections\n    if (collection.baseDescriptions) {\n      for (const base of collection.baseDescriptions) {\n        const description = base.schematics[schematicName];\n        if (description) {\n          return description.aliases && new Set(description.aliases);\n        }\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Get schematics that should to be registered as subcommands.\n   *\n   * @returns a sorted list of schematic that needs to be registered as subcommands.\n   */\n  getSchematicsToRegister() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const schematicsToRegister = [];\n      const [, schematicNameFromArgs] = _this8.parseSchematicInfo(\n      // positional = [generate, component] or [generate]\n      _this8.context.args.positional[1]);\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n      var _iteratorError;\n      try {\n        for (var _iterator = _asyncIterator(_this8.getSchematics()), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const {\n            schematicName,\n            collectionName,\n            schematicAliases\n          } = _step.value;\n          {\n            if (schematicNameFromArgs && (schematicName === schematicNameFromArgs || schematicAliases?.has(schematicNameFromArgs))) {\n              return [[schematicName, collectionName]];\n            }\n            schematicsToRegister.push([schematicName, collectionName]);\n          }\n        }\n        // Didn't find the schematic or no schematic name was provided Ex: `ng generate --help`.\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      return schematicsToRegister.sort(([nameA], [nameB]) => nameA.localeCompare(nameB, undefined, {\n        sensitivity: 'accent'\n      }));\n    })();\n  }\n}\nexports.default = GenerateCommandModule;","map":{"version":3,"names":["_asyncToGenerator","require","default","_asyncIterator","_awaitAsyncGenerator","_wrapAsyncGenerator","Object","defineProperty","exports","value","core_1","command_module_1","schematics_command_module_1","command_1","command_config_1","GenerateCommandModule","SchematicsCommandModule","constructor","arguments","command","aliases","RootCommands","describe","builder","argv","_superprop_getBuilder","_this2","localYargs","call","positional","type","demandOption","strict","handler","options","schematicName","collectionName","getSchematicsToRegister","workflow","getOrCreateWorkflowForBuilder","collection","engine","createCollection","description","schemaJson","schematicAliases","hidden","schematicHidden","schematicDescription","createSchematic","xDeprecated","getSchematicOptions","generateCommandString","deprecated","Array","isArray","generateCommandAliasesStrings","undefined","addSchemaOptionsToCommand","schematic","demandCommand","demandCommandFailureMessage","run","_this3","dryRun","defaults","force","interactive","schematicOptions","parseSchematicInfo","CommandModuleError","runSchematic","executionOptions","getCollectionNames","_this4","context","args","getSchematicCollections","shouldAddCollectionNameAsPartOfCommand","_this5","collectionNameFromArgs","schematicCollectionsFromConfig","collectionNames","some","c","has","_this6","map","alias","_this7","dasherizedSchematicName","strings","dasherize","commandName","positionalArgs","filter","o","label","name","required","join","getSchematics","_this","seenNames","Set","listSchematicNames","add","listSchematicAliases","schematics","baseDescriptions","base","_this8","schematicsToRegister","schematicNameFromArgs","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","push","err","return","sort","nameA","nameB","localeCompare","sensitivity"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular/cli/src/commands/generate/cli.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core_1 = require(\"@angular-devkit/core\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst schematics_command_module_1 = require(\"../../command-builder/schematics-command-module\");\nconst command_1 = require(\"../../command-builder/utilities/command\");\nconst command_config_1 = require(\"../command-config\");\nclass GenerateCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n    constructor() {\n        super(...arguments);\n        this.command = 'generate';\n        this.aliases = command_config_1.RootCommands['generate'].aliases;\n        this.describe = 'Generates and/or modifies files based on a schematic.';\n    }\n    async builder(argv) {\n        let localYargs = (await super.builder(argv)).command({\n            command: '$0 <schematic>',\n            describe: 'Run the provided schematic.',\n            builder: (localYargs) => localYargs\n                .positional('schematic', {\n                describe: 'The [collection:schematic] to run.',\n                type: 'string',\n                demandOption: true,\n            })\n                .strict(),\n            handler: (options) => this.handler(options),\n        });\n        for (const [schematicName, collectionName] of await this.getSchematicsToRegister()) {\n            const workflow = this.getOrCreateWorkflowForBuilder(collectionName);\n            const collection = workflow.engine.createCollection(collectionName);\n            const { description: { schemaJson, aliases: schematicAliases, hidden: schematicHidden, description: schematicDescription, }, } = collection.createSchematic(schematicName, true);\n            if (!schemaJson) {\n                continue;\n            }\n            const { 'x-deprecated': xDeprecated, description = schematicDescription, hidden = schematicHidden, } = schemaJson;\n            const options = await this.getSchematicOptions(collection, schematicName, workflow);\n            localYargs = localYargs.command({\n                command: await this.generateCommandString(collectionName, schematicName, options),\n                // When 'describe' is set to false, it results in a hidden command.\n                describe: hidden === true ? false : typeof description === 'string' ? description : '',\n                deprecated: xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : false,\n                aliases: Array.isArray(schematicAliases)\n                    ? await this.generateCommandAliasesStrings(collectionName, schematicAliases)\n                    : undefined,\n                builder: (localYargs) => this.addSchemaOptionsToCommand(localYargs, options).strict(),\n                handler: (options) => this.handler({\n                    ...options,\n                    schematic: `${collectionName}:${schematicName}`,\n                }),\n            });\n        }\n        return localYargs.demandCommand(1, command_1.demandCommandFailureMessage);\n    }\n    async run(options) {\n        const { dryRun, schematic, defaults, force, interactive, ...schematicOptions } = options;\n        const [collectionName, schematicName] = this.parseSchematicInfo(schematic);\n        if (!collectionName || !schematicName) {\n            throw new command_module_1.CommandModuleError('A collection and schematic is required during execution.');\n        }\n        return this.runSchematic({\n            collectionName,\n            schematicName,\n            schematicOptions,\n            executionOptions: {\n                dryRun,\n                defaults,\n                force,\n                interactive,\n            },\n        });\n    }\n    async getCollectionNames() {\n        const [collectionName] = this.parseSchematicInfo(\n        // positional = [generate, component] or [generate]\n        this.context.args.positional[1]);\n        return collectionName ? [collectionName] : [...(await this.getSchematicCollections())];\n    }\n    async shouldAddCollectionNameAsPartOfCommand() {\n        const [collectionNameFromArgs] = this.parseSchematicInfo(\n        // positional = [generate, component] or [generate]\n        this.context.args.positional[1]);\n        const schematicCollectionsFromConfig = await this.getSchematicCollections();\n        const collectionNames = await this.getCollectionNames();\n        // Only add the collection name as part of the command when it's not a known\n        // schematics collection or when it has been provided via the CLI.\n        // Ex:`ng generate @schematics/angular:c`\n        return (!!collectionNameFromArgs ||\n            !collectionNames.some((c) => schematicCollectionsFromConfig.has(c)));\n    }\n    /**\n     * Generate an aliases string array to be passed to the command builder.\n     *\n     * @example `[component]` or `[@schematics/angular:component]`.\n     */\n    async generateCommandAliasesStrings(collectionName, schematicAliases) {\n        // Only add the collection name as part of the command when it's not a known\n        // schematics collection or when it has been provided via the CLI.\n        // Ex:`ng generate @schematics/angular:c`\n        return (await this.shouldAddCollectionNameAsPartOfCommand())\n            ? schematicAliases.map((alias) => `${collectionName}:${alias}`)\n            : schematicAliases;\n    }\n    /**\n     * Generate a command string to be passed to the command builder.\n     *\n     * @example `component [name]` or `@schematics/angular:component [name]`.\n     */\n    async generateCommandString(collectionName, schematicName, options) {\n        const dasherizedSchematicName = core_1.strings.dasherize(schematicName);\n        // Only add the collection name as part of the command when it's not a known\n        // schematics collection or when it has been provided via the CLI.\n        // Ex:`ng generate @schematics/angular:component`\n        const commandName = (await this.shouldAddCollectionNameAsPartOfCommand())\n            ? collectionName + ':' + dasherizedSchematicName\n            : dasherizedSchematicName;\n        const positionalArgs = options\n            .filter((o) => o.positional !== undefined)\n            .map((o) => {\n            const label = `${core_1.strings.dasherize(o.name)}${o.type === 'array' ? ' ..' : ''}`;\n            return o.required ? `<${label}>` : `[${label}]`;\n        })\n            .join(' ');\n        return `${commandName}${positionalArgs ? ' ' + positionalArgs : ''}`;\n    }\n    /**\n     * Get schematics that can to be registered as subcommands.\n     */\n    async *getSchematics() {\n        const seenNames = new Set();\n        for (const collectionName of await this.getCollectionNames()) {\n            const workflow = this.getOrCreateWorkflowForBuilder(collectionName);\n            const collection = workflow.engine.createCollection(collectionName);\n            for (const schematicName of collection.listSchematicNames(true /** includeHidden */)) {\n                // If a schematic with this same name is already registered skip.\n                if (!seenNames.has(schematicName)) {\n                    seenNames.add(schematicName);\n                    yield {\n                        schematicName,\n                        collectionName,\n                        schematicAliases: this.listSchematicAliases(collection, schematicName),\n                    };\n                }\n            }\n        }\n    }\n    listSchematicAliases(collection, schematicName) {\n        const description = collection.description.schematics[schematicName];\n        if (description) {\n            return description.aliases && new Set(description.aliases);\n        }\n        // Extended collections\n        if (collection.baseDescriptions) {\n            for (const base of collection.baseDescriptions) {\n                const description = base.schematics[schematicName];\n                if (description) {\n                    return description.aliases && new Set(description.aliases);\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get schematics that should to be registered as subcommands.\n     *\n     * @returns a sorted list of schematic that needs to be registered as subcommands.\n     */\n    async getSchematicsToRegister() {\n        const schematicsToRegister = [];\n        const [, schematicNameFromArgs] = this.parseSchematicInfo(\n        // positional = [generate, component] or [generate]\n        this.context.args.positional[1]);\n        for await (const { schematicName, collectionName, schematicAliases } of this.getSchematics()) {\n            if (schematicNameFromArgs &&\n                (schematicName === schematicNameFromArgs || schematicAliases?.has(schematicNameFromArgs))) {\n                return [[schematicName, collectionName]];\n            }\n            schematicsToRegister.push([schematicName, collectionName]);\n        }\n        // Didn't find the schematic or no schematic name was provided Ex: `ng generate --help`.\n        return schematicsToRegister.sort(([nameA], [nameB]) => nameA.localeCompare(nameB, undefined, { sensitivity: 'accent' }));\n    }\n}\nexports.default = GenerateCommandModule;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}