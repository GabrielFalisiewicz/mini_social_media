{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TrustedMetadataStore = void 0;\nconst models_1 = require(\"@tufjs/models\");\nconst error_1 = require(\"./error\");\nclass TrustedMetadataStore {\n  constructor(rootData) {\n    this.trustedSet = {};\n    // Client workflow 5.1: record fixed update start time\n    this.referenceTime = new Date();\n    // Client workflow 5.2: load trusted root metadata\n    this.loadTrustedRoot(rootData);\n  }\n  get root() {\n    if (!this.trustedSet.root) {\n      throw new ReferenceError('No trusted root metadata');\n    }\n    return this.trustedSet.root;\n  }\n  get timestamp() {\n    return this.trustedSet.timestamp;\n  }\n  get snapshot() {\n    return this.trustedSet.snapshot;\n  }\n  get targets() {\n    return this.trustedSet.targets;\n  }\n  getRole(name) {\n    return this.trustedSet[name];\n  }\n  updateRoot(bytesBuffer) {\n    const data = JSON.parse(bytesBuffer.toString('utf8'));\n    const newRoot = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);\n    if (newRoot.signed.type != models_1.MetadataKind.Root) {\n      throw new error_1.RepositoryError(`Expected 'root', got ${newRoot.signed.type}`);\n    }\n    // Client workflow 5.4: check for arbitrary software attack\n    this.root.verifyDelegate(models_1.MetadataKind.Root, newRoot);\n    // Client workflow 5.5: check for rollback attack\n    if (newRoot.signed.version != this.root.signed.version + 1) {\n      throw new error_1.BadVersionError(`Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`);\n    }\n    // Check that new root is signed by self\n    newRoot.verifyDelegate(models_1.MetadataKind.Root, newRoot);\n    // Client workflow 5.7: set new root as trusted root\n    this.trustedSet.root = newRoot;\n    return newRoot;\n  }\n  updateTimestamp(bytesBuffer) {\n    if (this.snapshot) {\n      throw new error_1.RuntimeError('Cannot update timestamp after snapshot');\n    }\n    if (this.root.signed.isExpired(this.referenceTime)) {\n      throw new error_1.ExpiredMetadataError('Final root.json is expired');\n    }\n    const data = JSON.parse(bytesBuffer.toString('utf8'));\n    const newTimestamp = models_1.Metadata.fromJSON(models_1.MetadataKind.Timestamp, data);\n    if (newTimestamp.signed.type != models_1.MetadataKind.Timestamp) {\n      throw new error_1.RepositoryError(`Expected 'timestamp', got ${newTimestamp.signed.type}`);\n    }\n    // Client workflow 5.4.2: check for arbitrary software attack\n    this.root.verifyDelegate(models_1.MetadataKind.Timestamp, newTimestamp);\n    if (this.timestamp) {\n      // Prevent rolling back timestamp version\n      // Client workflow 5.4.3.1: check for rollback attack\n      if (newTimestamp.signed.version < this.timestamp.signed.version) {\n        throw new error_1.BadVersionError(`New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`);\n      }\n      //  Keep using old timestamp if versions are equal.\n      if (newTimestamp.signed.version === this.timestamp.signed.version) {\n        throw new error_1.EqualVersionError(`New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`);\n      }\n      // Prevent rolling back snapshot version\n      // Client workflow 5.4.3.2: check for rollback attack\n      const snapshotMeta = this.timestamp.signed.snapshotMeta;\n      const newSnapshotMeta = newTimestamp.signed.snapshotMeta;\n      if (newSnapshotMeta.version < snapshotMeta.version) {\n        throw new error_1.BadVersionError(`New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`);\n      }\n    }\n    // expiry not checked to allow old timestamp to be used for rollback\n    // protection of new timestamp: expiry is checked in update_snapshot\n    this.trustedSet.timestamp = newTimestamp;\n    // Client workflow 5.4.4: check for freeze attack\n    this.checkFinalTimestamp();\n    return newTimestamp;\n  }\n  updateSnapshot(bytesBuffer, trusted = false) {\n    if (!this.timestamp) {\n      throw new error_1.RuntimeError('Cannot update snapshot before timestamp');\n    }\n    if (this.targets) {\n      throw new error_1.RuntimeError('Cannot update snapshot after targets');\n    }\n    // Snapshot cannot be loaded if final timestamp is expired\n    this.checkFinalTimestamp();\n    const snapshotMeta = this.timestamp.signed.snapshotMeta;\n    // Verify non-trusted data against the hashes in timestamp, if any.\n    // Trusted snapshot data has already been verified once.\n    // Client workflow 5.5.2: check against timestamp role's snaphsot hash\n    if (!trusted) {\n      snapshotMeta.verify(bytesBuffer);\n    }\n    const data = JSON.parse(bytesBuffer.toString('utf8'));\n    const newSnapshot = models_1.Metadata.fromJSON(models_1.MetadataKind.Snapshot, data);\n    if (newSnapshot.signed.type != models_1.MetadataKind.Snapshot) {\n      throw new error_1.RepositoryError(`Expected 'snapshot', got ${newSnapshot.signed.type}`);\n    }\n    // Client workflow 5.5.3: check for arbitrary software attack\n    this.root.verifyDelegate(models_1.MetadataKind.Snapshot, newSnapshot);\n    // version check against meta version (5.5.4) is deferred to allow old\n    // snapshot to be used in rollback protection\n    // Client workflow 5.5.5: check for rollback attack\n    if (this.snapshot) {\n      Object.entries(this.snapshot.signed.meta).forEach(([fileName, fileInfo]) => {\n        const newFileInfo = newSnapshot.signed.meta[fileName];\n        if (!newFileInfo) {\n          throw new error_1.RepositoryError(`Missing file ${fileName} in new snapshot`);\n        }\n        if (newFileInfo.version < fileInfo.version) {\n          throw new error_1.BadVersionError(`New version ${newFileInfo.version} of ${fileName} is less than current version ${fileInfo.version}`);\n        }\n      });\n    }\n    this.trustedSet.snapshot = newSnapshot;\n    // snapshot is loaded, but we raise if it's not valid _final_ snapshot\n    // Client workflow 5.5.4 & 5.5.6\n    this.checkFinalSnapsnot();\n    return newSnapshot;\n  }\n  updateDelegatedTargets(bytesBuffer, roleName, delegatorName) {\n    if (!this.snapshot) {\n      throw new error_1.RuntimeError('Cannot update delegated targets before snapshot');\n    }\n    // Targets cannot be loaded if final snapshot is expired or its version\n    // does not match meta version in timestamp.\n    this.checkFinalSnapsnot();\n    const delegator = this.trustedSet[delegatorName];\n    if (!delegator) {\n      throw new error_1.RuntimeError(`No trusted ${delegatorName} metadata`);\n    }\n    // Extract metadata for the delegated role from snapshot\n    const meta = this.snapshot.signed.meta?.[`${roleName}.json`];\n    if (!meta) {\n      throw new error_1.RepositoryError(`Missing ${roleName}.json in snapshot`);\n    }\n    // Client workflow 5.6.2: check against snapshot role's targets hash\n    meta.verify(bytesBuffer);\n    const data = JSON.parse(bytesBuffer.toString('utf8'));\n    const newDelegate = models_1.Metadata.fromJSON(models_1.MetadataKind.Targets, data);\n    if (newDelegate.signed.type != models_1.MetadataKind.Targets) {\n      throw new error_1.RepositoryError(`Expected 'targets', got ${newDelegate.signed.type}`);\n    }\n    // Client workflow 5.6.3: check for arbitrary software attack\n    delegator.verifyDelegate(roleName, newDelegate);\n    // Client workflow 5.6.4: Check against snapshot role’s targets version\n    const version = newDelegate.signed.version;\n    if (version != meta.version) {\n      throw new error_1.BadVersionError(`Version ${version} of ${roleName} does not match snapshot version ${meta.version}`);\n    }\n    // Client workflow 5.6.5: check for a freeze attack\n    if (newDelegate.signed.isExpired(this.referenceTime)) {\n      throw new error_1.ExpiredMetadataError(`${roleName}.json is expired`);\n    }\n    this.trustedSet[roleName] = newDelegate;\n  }\n  // Verifies and loads data as trusted root metadata.\n  // Note that an expired initial root is still considered valid.\n  loadTrustedRoot(bytesBuffer) {\n    const data = JSON.parse(bytesBuffer.toString('utf8'));\n    const root = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);\n    if (root.signed.type != models_1.MetadataKind.Root) {\n      throw new error_1.RepositoryError(`Expected 'root', got ${root.signed.type}`);\n    }\n    root.verifyDelegate(models_1.MetadataKind.Root, root);\n    this.trustedSet['root'] = root;\n  }\n  checkFinalTimestamp() {\n    // Timestamp MUST be loaded\n    if (!this.timestamp) {\n      throw new ReferenceError('No trusted timestamp metadata');\n    }\n    // Client workflow 5.4.4: check for freeze attack\n    if (this.timestamp.signed.isExpired(this.referenceTime)) {\n      throw new error_1.ExpiredMetadataError('Final timestamp.json is expired');\n    }\n  }\n  checkFinalSnapsnot() {\n    // Snapshot and timestamp MUST be loaded\n    if (!this.snapshot) {\n      throw new ReferenceError('No trusted snapshot metadata');\n    }\n    if (!this.timestamp) {\n      throw new ReferenceError('No trusted timestamp metadata');\n    }\n    // Client workflow 5.5.6: check for freeze attack\n    if (this.snapshot.signed.isExpired(this.referenceTime)) {\n      throw new error_1.ExpiredMetadataError('snapshot.json is expired');\n    }\n    // Client workflow 5.5.4: check against timestamp role’s snapshot version\n    const snapshotMeta = this.timestamp.signed.snapshotMeta;\n    if (this.snapshot.signed.version !== snapshotMeta.version) {\n      throw new error_1.BadVersionError(\"Snapshot version doesn't match timestamp\");\n    }\n  }\n}\nexports.TrustedMetadataStore = TrustedMetadataStore;","map":{"version":3,"names":["Object","defineProperty","exports","value","TrustedMetadataStore","models_1","require","error_1","constructor","rootData","trustedSet","referenceTime","Date","loadTrustedRoot","root","ReferenceError","timestamp","snapshot","targets","getRole","name","updateRoot","bytesBuffer","data","JSON","parse","toString","newRoot","Metadata","fromJSON","MetadataKind","Root","signed","type","RepositoryError","verifyDelegate","version","BadVersionError","updateTimestamp","RuntimeError","isExpired","ExpiredMetadataError","newTimestamp","Timestamp","EqualVersionError","snapshotMeta","newSnapshotMeta","checkFinalTimestamp","updateSnapshot","trusted","verify","newSnapshot","Snapshot","entries","meta","forEach","fileName","fileInfo","newFileInfo","checkFinalSnapsnot","updateDelegatedTargets","roleName","delegatorName","delegator","newDelegate","Targets"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/tuf-js/dist/store.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TrustedMetadataStore = void 0;\nconst models_1 = require(\"@tufjs/models\");\nconst error_1 = require(\"./error\");\nclass TrustedMetadataStore {\n    constructor(rootData) {\n        this.trustedSet = {};\n        // Client workflow 5.1: record fixed update start time\n        this.referenceTime = new Date();\n        // Client workflow 5.2: load trusted root metadata\n        this.loadTrustedRoot(rootData);\n    }\n    get root() {\n        if (!this.trustedSet.root) {\n            throw new ReferenceError('No trusted root metadata');\n        }\n        return this.trustedSet.root;\n    }\n    get timestamp() {\n        return this.trustedSet.timestamp;\n    }\n    get snapshot() {\n        return this.trustedSet.snapshot;\n    }\n    get targets() {\n        return this.trustedSet.targets;\n    }\n    getRole(name) {\n        return this.trustedSet[name];\n    }\n    updateRoot(bytesBuffer) {\n        const data = JSON.parse(bytesBuffer.toString('utf8'));\n        const newRoot = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);\n        if (newRoot.signed.type != models_1.MetadataKind.Root) {\n            throw new error_1.RepositoryError(`Expected 'root', got ${newRoot.signed.type}`);\n        }\n        // Client workflow 5.4: check for arbitrary software attack\n        this.root.verifyDelegate(models_1.MetadataKind.Root, newRoot);\n        // Client workflow 5.5: check for rollback attack\n        if (newRoot.signed.version != this.root.signed.version + 1) {\n            throw new error_1.BadVersionError(`Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`);\n        }\n        // Check that new root is signed by self\n        newRoot.verifyDelegate(models_1.MetadataKind.Root, newRoot);\n        // Client workflow 5.7: set new root as trusted root\n        this.trustedSet.root = newRoot;\n        return newRoot;\n    }\n    updateTimestamp(bytesBuffer) {\n        if (this.snapshot) {\n            throw new error_1.RuntimeError('Cannot update timestamp after snapshot');\n        }\n        if (this.root.signed.isExpired(this.referenceTime)) {\n            throw new error_1.ExpiredMetadataError('Final root.json is expired');\n        }\n        const data = JSON.parse(bytesBuffer.toString('utf8'));\n        const newTimestamp = models_1.Metadata.fromJSON(models_1.MetadataKind.Timestamp, data);\n        if (newTimestamp.signed.type != models_1.MetadataKind.Timestamp) {\n            throw new error_1.RepositoryError(`Expected 'timestamp', got ${newTimestamp.signed.type}`);\n        }\n        // Client workflow 5.4.2: check for arbitrary software attack\n        this.root.verifyDelegate(models_1.MetadataKind.Timestamp, newTimestamp);\n        if (this.timestamp) {\n            // Prevent rolling back timestamp version\n            // Client workflow 5.4.3.1: check for rollback attack\n            if (newTimestamp.signed.version < this.timestamp.signed.version) {\n                throw new error_1.BadVersionError(`New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`);\n            }\n            //  Keep using old timestamp if versions are equal.\n            if (newTimestamp.signed.version === this.timestamp.signed.version) {\n                throw new error_1.EqualVersionError(`New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`);\n            }\n            // Prevent rolling back snapshot version\n            // Client workflow 5.4.3.2: check for rollback attack\n            const snapshotMeta = this.timestamp.signed.snapshotMeta;\n            const newSnapshotMeta = newTimestamp.signed.snapshotMeta;\n            if (newSnapshotMeta.version < snapshotMeta.version) {\n                throw new error_1.BadVersionError(`New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`);\n            }\n        }\n        // expiry not checked to allow old timestamp to be used for rollback\n        // protection of new timestamp: expiry is checked in update_snapshot\n        this.trustedSet.timestamp = newTimestamp;\n        // Client workflow 5.4.4: check for freeze attack\n        this.checkFinalTimestamp();\n        return newTimestamp;\n    }\n    updateSnapshot(bytesBuffer, trusted = false) {\n        if (!this.timestamp) {\n            throw new error_1.RuntimeError('Cannot update snapshot before timestamp');\n        }\n        if (this.targets) {\n            throw new error_1.RuntimeError('Cannot update snapshot after targets');\n        }\n        // Snapshot cannot be loaded if final timestamp is expired\n        this.checkFinalTimestamp();\n        const snapshotMeta = this.timestamp.signed.snapshotMeta;\n        // Verify non-trusted data against the hashes in timestamp, if any.\n        // Trusted snapshot data has already been verified once.\n        // Client workflow 5.5.2: check against timestamp role's snaphsot hash\n        if (!trusted) {\n            snapshotMeta.verify(bytesBuffer);\n        }\n        const data = JSON.parse(bytesBuffer.toString('utf8'));\n        const newSnapshot = models_1.Metadata.fromJSON(models_1.MetadataKind.Snapshot, data);\n        if (newSnapshot.signed.type != models_1.MetadataKind.Snapshot) {\n            throw new error_1.RepositoryError(`Expected 'snapshot', got ${newSnapshot.signed.type}`);\n        }\n        // Client workflow 5.5.3: check for arbitrary software attack\n        this.root.verifyDelegate(models_1.MetadataKind.Snapshot, newSnapshot);\n        // version check against meta version (5.5.4) is deferred to allow old\n        // snapshot to be used in rollback protection\n        // Client workflow 5.5.5: check for rollback attack\n        if (this.snapshot) {\n            Object.entries(this.snapshot.signed.meta).forEach(([fileName, fileInfo]) => {\n                const newFileInfo = newSnapshot.signed.meta[fileName];\n                if (!newFileInfo) {\n                    throw new error_1.RepositoryError(`Missing file ${fileName} in new snapshot`);\n                }\n                if (newFileInfo.version < fileInfo.version) {\n                    throw new error_1.BadVersionError(`New version ${newFileInfo.version} of ${fileName} is less than current version ${fileInfo.version}`);\n                }\n            });\n        }\n        this.trustedSet.snapshot = newSnapshot;\n        // snapshot is loaded, but we raise if it's not valid _final_ snapshot\n        // Client workflow 5.5.4 & 5.5.6\n        this.checkFinalSnapsnot();\n        return newSnapshot;\n    }\n    updateDelegatedTargets(bytesBuffer, roleName, delegatorName) {\n        if (!this.snapshot) {\n            throw new error_1.RuntimeError('Cannot update delegated targets before snapshot');\n        }\n        // Targets cannot be loaded if final snapshot is expired or its version\n        // does not match meta version in timestamp.\n        this.checkFinalSnapsnot();\n        const delegator = this.trustedSet[delegatorName];\n        if (!delegator) {\n            throw new error_1.RuntimeError(`No trusted ${delegatorName} metadata`);\n        }\n        // Extract metadata for the delegated role from snapshot\n        const meta = this.snapshot.signed.meta?.[`${roleName}.json`];\n        if (!meta) {\n            throw new error_1.RepositoryError(`Missing ${roleName}.json in snapshot`);\n        }\n        // Client workflow 5.6.2: check against snapshot role's targets hash\n        meta.verify(bytesBuffer);\n        const data = JSON.parse(bytesBuffer.toString('utf8'));\n        const newDelegate = models_1.Metadata.fromJSON(models_1.MetadataKind.Targets, data);\n        if (newDelegate.signed.type != models_1.MetadataKind.Targets) {\n            throw new error_1.RepositoryError(`Expected 'targets', got ${newDelegate.signed.type}`);\n        }\n        // Client workflow 5.6.3: check for arbitrary software attack\n        delegator.verifyDelegate(roleName, newDelegate);\n        // Client workflow 5.6.4: Check against snapshot role’s targets version\n        const version = newDelegate.signed.version;\n        if (version != meta.version) {\n            throw new error_1.BadVersionError(`Version ${version} of ${roleName} does not match snapshot version ${meta.version}`);\n        }\n        // Client workflow 5.6.5: check for a freeze attack\n        if (newDelegate.signed.isExpired(this.referenceTime)) {\n            throw new error_1.ExpiredMetadataError(`${roleName}.json is expired`);\n        }\n        this.trustedSet[roleName] = newDelegate;\n    }\n    // Verifies and loads data as trusted root metadata.\n    // Note that an expired initial root is still considered valid.\n    loadTrustedRoot(bytesBuffer) {\n        const data = JSON.parse(bytesBuffer.toString('utf8'));\n        const root = models_1.Metadata.fromJSON(models_1.MetadataKind.Root, data);\n        if (root.signed.type != models_1.MetadataKind.Root) {\n            throw new error_1.RepositoryError(`Expected 'root', got ${root.signed.type}`);\n        }\n        root.verifyDelegate(models_1.MetadataKind.Root, root);\n        this.trustedSet['root'] = root;\n    }\n    checkFinalTimestamp() {\n        // Timestamp MUST be loaded\n        if (!this.timestamp) {\n            throw new ReferenceError('No trusted timestamp metadata');\n        }\n        // Client workflow 5.4.4: check for freeze attack\n        if (this.timestamp.signed.isExpired(this.referenceTime)) {\n            throw new error_1.ExpiredMetadataError('Final timestamp.json is expired');\n        }\n    }\n    checkFinalSnapsnot() {\n        // Snapshot and timestamp MUST be loaded\n        if (!this.snapshot) {\n            throw new ReferenceError('No trusted snapshot metadata');\n        }\n        if (!this.timestamp) {\n            throw new ReferenceError('No trusted timestamp metadata');\n        }\n        // Client workflow 5.5.6: check for freeze attack\n        if (this.snapshot.signed.isExpired(this.referenceTime)) {\n            throw new error_1.ExpiredMetadataError('snapshot.json is expired');\n        }\n        // Client workflow 5.5.4: check against timestamp role’s snapshot version\n        const snapshotMeta = this.timestamp.signed.snapshotMeta;\n        if (this.snapshot.signed.version !== snapshotMeta.version) {\n            throw new error_1.BadVersionError(\"Snapshot version doesn't match timestamp\");\n        }\n    }\n}\nexports.TrustedMetadataStore = TrustedMetadataStore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}