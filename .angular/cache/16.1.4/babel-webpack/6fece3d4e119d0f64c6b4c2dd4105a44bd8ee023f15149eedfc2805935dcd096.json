{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Metadata = void 0;\nconst canonical_json_1 = require(\"@tufjs/canonical-json\");\nconst util_1 = __importDefault(require(\"util\"));\nconst base_1 = require(\"./base\");\nconst error_1 = require(\"./error\");\nconst root_1 = require(\"./root\");\nconst signature_1 = require(\"./signature\");\nconst snapshot_1 = require(\"./snapshot\");\nconst targets_1 = require(\"./targets\");\nconst timestamp_1 = require(\"./timestamp\");\nconst utils_1 = require(\"./utils\");\n/***\n * A container for signed TUF metadata.\n *\n * Provides methods to convert to and from json, read and write to and\n * from JSON and to create and verify metadata signatures.\n *\n * ``Metadata[T]`` is a generic container type where T can be any one type of\n * [``Root``, ``Timestamp``, ``Snapshot``, ``Targets``]. The purpose of this\n * is to allow static type checking of the signed attribute in code using\n * Metadata::\n *\n * root_md = Metadata[Root].fromJSON(\"root.json\")\n * # root_md type is now Metadata[Root]. This means signed and its\n * # attributes like consistent_snapshot are now statically typed and the\n * # types can be verified by static type checkers and shown by IDEs\n *\n * Using a type constraint is not required but not doing so means T is not a\n * specific type so static typing cannot happen. Note that the type constraint\n * ``[Root]`` is not validated at runtime (as pure annotations are not available\n * then).\n *\n * Apart from ``expires`` all of the arguments to the inner constructors have\n * reasonable default values for new metadata.\n */\nclass Metadata {\n  constructor(signed, signatures, unrecognizedFields) {\n    this.signed = signed;\n    this.signatures = signatures || {};\n    this.unrecognizedFields = unrecognizedFields || {};\n  }\n  sign(signer, append = true) {\n    const bytes = Buffer.from((0, canonical_json_1.canonicalize)(this.signed.toJSON()));\n    const signature = signer(bytes);\n    if (!append) {\n      this.signatures = {};\n    }\n    this.signatures[signature.keyID] = signature;\n  }\n  verifyDelegate(delegatedRole, delegatedMetadata) {\n    let role;\n    let keys = {};\n    switch (this.signed.type) {\n      case base_1.MetadataKind.Root:\n        keys = this.signed.keys;\n        role = this.signed.roles[delegatedRole];\n        break;\n      case base_1.MetadataKind.Targets:\n        if (!this.signed.delegations) {\n          throw new error_1.ValueError(`No delegations found for ${delegatedRole}`);\n        }\n        keys = this.signed.delegations.keys;\n        if (this.signed.delegations.roles) {\n          role = this.signed.delegations.roles[delegatedRole];\n        } else if (this.signed.delegations.succinctRoles) {\n          if (this.signed.delegations.succinctRoles.isDelegatedRole(delegatedRole)) {\n            role = this.signed.delegations.succinctRoles;\n          }\n        }\n        break;\n      default:\n        throw new TypeError('invalid metadata type');\n    }\n    if (!role) {\n      throw new error_1.ValueError(`no delegation found for ${delegatedRole}`);\n    }\n    const signingKeys = new Set();\n    role.keyIDs.forEach(keyID => {\n      const key = keys[keyID];\n      // If we dont' have the key, continue checking other keys\n      if (!key) {\n        return;\n      }\n      try {\n        key.verifySignature(delegatedMetadata);\n        signingKeys.add(key.keyID);\n      } catch (error) {\n        // continue\n      }\n    });\n    if (signingKeys.size < role.threshold) {\n      throw new error_1.UnsignedMetadataError(`${delegatedRole} was signed by ${signingKeys.size}/${role.threshold} keys`);\n    }\n  }\n  equals(other) {\n    if (!(other instanceof Metadata)) {\n      return false;\n    }\n    return this.signed.equals(other.signed) && util_1.default.isDeepStrictEqual(this.signatures, other.signatures) && util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields);\n  }\n  toJSON() {\n    const signatures = Object.values(this.signatures).map(signature => {\n      return signature.toJSON();\n    });\n    return {\n      signatures,\n      signed: this.signed.toJSON(),\n      ...this.unrecognizedFields\n    };\n  }\n  static fromJSON(type, data) {\n    const {\n      signed,\n      signatures,\n      ...rest\n    } = data;\n    if (!utils_1.guard.isDefined(signed) || !utils_1.guard.isObject(signed)) {\n      throw new TypeError('signed is not defined');\n    }\n    if (type !== signed._type) {\n      throw new error_1.ValueError(`expected '${type}', got ${signed['_type']}`);\n    }\n    let signedObj;\n    switch (type) {\n      case base_1.MetadataKind.Root:\n        signedObj = root_1.Root.fromJSON(signed);\n        break;\n      case base_1.MetadataKind.Timestamp:\n        signedObj = timestamp_1.Timestamp.fromJSON(signed);\n        break;\n      case base_1.MetadataKind.Snapshot:\n        signedObj = snapshot_1.Snapshot.fromJSON(signed);\n        break;\n      case base_1.MetadataKind.Targets:\n        signedObj = targets_1.Targets.fromJSON(signed);\n        break;\n      default:\n        throw new TypeError('invalid metadata type');\n    }\n    const sigMap = signaturesFromJSON(signatures);\n    return new Metadata(signedObj, sigMap, rest);\n  }\n}\nexports.Metadata = Metadata;\nfunction signaturesFromJSON(data) {\n  if (!utils_1.guard.isObjectArray(data)) {\n    throw new TypeError('signatures is not an array');\n  }\n  return data.reduce((acc, sigData) => {\n    const signature = signature_1.Signature.fromJSON(sigData);\n    return {\n      ...acc,\n      [signature.keyID]: signature\n    };\n  }, {});\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Metadata","canonical_json_1","require","util_1","base_1","error_1","root_1","signature_1","snapshot_1","targets_1","timestamp_1","utils_1","constructor","signed","signatures","unrecognizedFields","sign","signer","append","bytes","Buffer","from","canonicalize","toJSON","signature","keyID","verifyDelegate","delegatedRole","delegatedMetadata","role","keys","type","MetadataKind","Root","roles","Targets","delegations","ValueError","succinctRoles","isDelegatedRole","TypeError","signingKeys","Set","keyIDs","forEach","key","verifySignature","add","error","size","threshold","UnsignedMetadataError","equals","other","default","isDeepStrictEqual","values","map","fromJSON","data","rest","guard","isDefined","isObject","_type","signedObj","Timestamp","Snapshot","sigMap","signaturesFromJSON","isObjectArray","reduce","acc","sigData","Signature"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@tufjs/models/dist/metadata.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Metadata = void 0;\nconst canonical_json_1 = require(\"@tufjs/canonical-json\");\nconst util_1 = __importDefault(require(\"util\"));\nconst base_1 = require(\"./base\");\nconst error_1 = require(\"./error\");\nconst root_1 = require(\"./root\");\nconst signature_1 = require(\"./signature\");\nconst snapshot_1 = require(\"./snapshot\");\nconst targets_1 = require(\"./targets\");\nconst timestamp_1 = require(\"./timestamp\");\nconst utils_1 = require(\"./utils\");\n/***\n * A container for signed TUF metadata.\n *\n * Provides methods to convert to and from json, read and write to and\n * from JSON and to create and verify metadata signatures.\n *\n * ``Metadata[T]`` is a generic container type where T can be any one type of\n * [``Root``, ``Timestamp``, ``Snapshot``, ``Targets``]. The purpose of this\n * is to allow static type checking of the signed attribute in code using\n * Metadata::\n *\n * root_md = Metadata[Root].fromJSON(\"root.json\")\n * # root_md type is now Metadata[Root]. This means signed and its\n * # attributes like consistent_snapshot are now statically typed and the\n * # types can be verified by static type checkers and shown by IDEs\n *\n * Using a type constraint is not required but not doing so means T is not a\n * specific type so static typing cannot happen. Note that the type constraint\n * ``[Root]`` is not validated at runtime (as pure annotations are not available\n * then).\n *\n * Apart from ``expires`` all of the arguments to the inner constructors have\n * reasonable default values for new metadata.\n */\nclass Metadata {\n    constructor(signed, signatures, unrecognizedFields) {\n        this.signed = signed;\n        this.signatures = signatures || {};\n        this.unrecognizedFields = unrecognizedFields || {};\n    }\n    sign(signer, append = true) {\n        const bytes = Buffer.from((0, canonical_json_1.canonicalize)(this.signed.toJSON()));\n        const signature = signer(bytes);\n        if (!append) {\n            this.signatures = {};\n        }\n        this.signatures[signature.keyID] = signature;\n    }\n    verifyDelegate(delegatedRole, delegatedMetadata) {\n        let role;\n        let keys = {};\n        switch (this.signed.type) {\n            case base_1.MetadataKind.Root:\n                keys = this.signed.keys;\n                role = this.signed.roles[delegatedRole];\n                break;\n            case base_1.MetadataKind.Targets:\n                if (!this.signed.delegations) {\n                    throw new error_1.ValueError(`No delegations found for ${delegatedRole}`);\n                }\n                keys = this.signed.delegations.keys;\n                if (this.signed.delegations.roles) {\n                    role = this.signed.delegations.roles[delegatedRole];\n                }\n                else if (this.signed.delegations.succinctRoles) {\n                    if (this.signed.delegations.succinctRoles.isDelegatedRole(delegatedRole)) {\n                        role = this.signed.delegations.succinctRoles;\n                    }\n                }\n                break;\n            default:\n                throw new TypeError('invalid metadata type');\n        }\n        if (!role) {\n            throw new error_1.ValueError(`no delegation found for ${delegatedRole}`);\n        }\n        const signingKeys = new Set();\n        role.keyIDs.forEach((keyID) => {\n            const key = keys[keyID];\n            // If we dont' have the key, continue checking other keys\n            if (!key) {\n                return;\n            }\n            try {\n                key.verifySignature(delegatedMetadata);\n                signingKeys.add(key.keyID);\n            }\n            catch (error) {\n                // continue\n            }\n        });\n        if (signingKeys.size < role.threshold) {\n            throw new error_1.UnsignedMetadataError(`${delegatedRole} was signed by ${signingKeys.size}/${role.threshold} keys`);\n        }\n    }\n    equals(other) {\n        if (!(other instanceof Metadata)) {\n            return false;\n        }\n        return (this.signed.equals(other.signed) &&\n            util_1.default.isDeepStrictEqual(this.signatures, other.signatures) &&\n            util_1.default.isDeepStrictEqual(this.unrecognizedFields, other.unrecognizedFields));\n    }\n    toJSON() {\n        const signatures = Object.values(this.signatures).map((signature) => {\n            return signature.toJSON();\n        });\n        return {\n            signatures,\n            signed: this.signed.toJSON(),\n            ...this.unrecognizedFields,\n        };\n    }\n    static fromJSON(type, data) {\n        const { signed, signatures, ...rest } = data;\n        if (!utils_1.guard.isDefined(signed) || !utils_1.guard.isObject(signed)) {\n            throw new TypeError('signed is not defined');\n        }\n        if (type !== signed._type) {\n            throw new error_1.ValueError(`expected '${type}', got ${signed['_type']}`);\n        }\n        let signedObj;\n        switch (type) {\n            case base_1.MetadataKind.Root:\n                signedObj = root_1.Root.fromJSON(signed);\n                break;\n            case base_1.MetadataKind.Timestamp:\n                signedObj = timestamp_1.Timestamp.fromJSON(signed);\n                break;\n            case base_1.MetadataKind.Snapshot:\n                signedObj = snapshot_1.Snapshot.fromJSON(signed);\n                break;\n            case base_1.MetadataKind.Targets:\n                signedObj = targets_1.Targets.fromJSON(signed);\n                break;\n            default:\n                throw new TypeError('invalid metadata type');\n        }\n        const sigMap = signaturesFromJSON(signatures);\n        return new Metadata(signedObj, sigMap, rest);\n    }\n}\nexports.Metadata = Metadata;\nfunction signaturesFromJSON(data) {\n    if (!utils_1.guard.isObjectArray(data)) {\n        throw new TypeError('signatures is not an array');\n    }\n    return data.reduce((acc, sigData) => {\n        const signature = signature_1.Signature.fromJSON(sigData);\n        return { ...acc, [signature.keyID]: signature };\n    }, {});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}