{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ASN1Obj = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst stream_1 = require(\"../stream\");\nconst error_1 = require(\"./error\");\nconst length_1 = require(\"./length\");\nconst parse_1 = require(\"./parse\");\nconst tag_1 = require(\"./tag\");\nclass ASN1Obj {\n  constructor(tag, value, subs) {\n    this.tag = tag;\n    this.value = value;\n    this.subs = subs;\n  }\n  // Constructs an ASN.1 object from a Buffer of DER-encoded bytes.\n  static parseBuffer(buf) {\n    return parseStream(new stream_1.ByteStream(buf));\n  }\n  toDER() {\n    const valueStream = new stream_1.ByteStream();\n    if (this.subs.length > 0) {\n      for (const sub of this.subs) {\n        valueStream.appendView(sub.toDER());\n      }\n    } else {\n      valueStream.appendView(this.value);\n    }\n    const value = valueStream.buffer;\n    // Concat tag/length/value\n    const obj = new stream_1.ByteStream();\n    obj.appendChar(this.tag.toDER());\n    obj.appendView((0, length_1.encodeLength)(value.length));\n    obj.appendView(value);\n    return obj.buffer;\n  }\n  /////////////////////////////////////////////////////////////////////////////\n  // Convenience methods for parsing ASN.1 primitives into JS types\n  // Returns the ASN.1 object's value as a boolean. Throws an error if the\n  // object is not a boolean.\n  toBoolean() {\n    if (!this.tag.isBoolean()) {\n      throw new error_1.ASN1TypeError('not a boolean');\n    }\n    return (0, parse_1.parseBoolean)(this.value);\n  }\n  // Returns the ASN.1 object's value as a BigInt. Throws an error if the\n  // object is not an integer.\n  toInteger() {\n    if (!this.tag.isInteger()) {\n      throw new error_1.ASN1TypeError('not an integer');\n    }\n    return (0, parse_1.parseInteger)(this.value);\n  }\n  // Returns the ASN.1 object's value as an OID string. Throws an error if the\n  // object is not an OID.\n  toOID() {\n    if (!this.tag.isOID()) {\n      throw new error_1.ASN1TypeError('not an OID');\n    }\n    return (0, parse_1.parseOID)(this.value);\n  }\n  // Returns the ASN.1 object's value as a Date. Throws an error if the object\n  // is not either a UTCTime or a GeneralizedTime.\n  toDate() {\n    switch (true) {\n      case this.tag.isUTCTime():\n        return (0, parse_1.parseTime)(this.value, true);\n      case this.tag.isGeneralizedTime():\n        return (0, parse_1.parseTime)(this.value, false);\n      default:\n        throw new error_1.ASN1TypeError('not a date');\n    }\n  }\n  // Returns the ASN.1 object's value as a number[] where each number is the\n  // value of a bit in the bit string. Throws an error if the object is not a\n  // bit string.\n  toBitString() {\n    if (!this.tag.isBitString()) {\n      throw new error_1.ASN1TypeError('not a bit string');\n    }\n    return (0, parse_1.parseBitString)(this.value);\n  }\n}\nexports.ASN1Obj = ASN1Obj;\n/////////////////////////////////////////////////////////////////////////////\n// Internal stream parsing functions\nfunction parseStream(stream) {\n  // Parse tag, length, and value from stream\n  const tag = new tag_1.ASN1Tag(stream.getUint8());\n  const len = (0, length_1.decodeLength)(stream);\n  const value = stream.slice(stream.position, len);\n  const start = stream.position;\n  let subs = [];\n  // If the object is constructed, parse its children. Sometimes, children\n  // are embedded in OCTESTRING objects, so we need to check those\n  // for children as well.\n  if (tag.constructed) {\n    subs = collectSubs(stream, len);\n  } else if (tag.isOctetString()) {\n    // Attempt to parse children of OCTETSTRING objects. If anything fails,\n    // assume the object is not constructed and treat as primitive.\n    try {\n      subs = collectSubs(stream, len);\n    } catch (e) {\n      // Fail silently and treat as primitive\n    }\n  }\n  // If there are no children, move stream cursor to the end of the object\n  if (subs.length === 0) {\n    stream.seek(start + len);\n  }\n  return new ASN1Obj(tag, value, subs);\n}\nfunction collectSubs(stream, len) {\n  // Calculate end of object content\n  const end = stream.position + len;\n  // Make sure there are enough bytes left in the stream. This should never\n  // happen, cause it'll get caught when the stream is sliced in parseStream.\n  // Leaving as an extra check just in case.\n  /* istanbul ignore if */\n  if (end > stream.length) {\n    throw new error_1.ASN1ParseError('invalid length');\n  }\n  // Parse all children\n  const subs = [];\n  while (stream.position < end) {\n    subs.push(parseStream(stream));\n  }\n  // When we're done parsing children, we should be at the end of the object\n  if (stream.position !== end) {\n    throw new error_1.ASN1ParseError('invalid length');\n  }\n  return subs;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ASN1Obj","stream_1","require","error_1","length_1","parse_1","tag_1","constructor","tag","subs","parseBuffer","buf","parseStream","ByteStream","toDER","valueStream","length","sub","appendView","buffer","obj","appendChar","encodeLength","toBoolean","isBoolean","ASN1TypeError","parseBoolean","toInteger","isInteger","parseInteger","toOID","isOID","parseOID","toDate","isUTCTime","parseTime","isGeneralizedTime","toBitString","isBitString","parseBitString","stream","ASN1Tag","getUint8","len","decodeLength","slice","position","start","constructed","collectSubs","isOctetString","e","seek","end","ASN1ParseError","push"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/util/asn1/obj.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ASN1Obj = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst stream_1 = require(\"../stream\");\nconst error_1 = require(\"./error\");\nconst length_1 = require(\"./length\");\nconst parse_1 = require(\"./parse\");\nconst tag_1 = require(\"./tag\");\nclass ASN1Obj {\n    constructor(tag, value, subs) {\n        this.tag = tag;\n        this.value = value;\n        this.subs = subs;\n    }\n    // Constructs an ASN.1 object from a Buffer of DER-encoded bytes.\n    static parseBuffer(buf) {\n        return parseStream(new stream_1.ByteStream(buf));\n    }\n    toDER() {\n        const valueStream = new stream_1.ByteStream();\n        if (this.subs.length > 0) {\n            for (const sub of this.subs) {\n                valueStream.appendView(sub.toDER());\n            }\n        }\n        else {\n            valueStream.appendView(this.value);\n        }\n        const value = valueStream.buffer;\n        // Concat tag/length/value\n        const obj = new stream_1.ByteStream();\n        obj.appendChar(this.tag.toDER());\n        obj.appendView((0, length_1.encodeLength)(value.length));\n        obj.appendView(value);\n        return obj.buffer;\n    }\n    /////////////////////////////////////////////////////////////////////////////\n    // Convenience methods for parsing ASN.1 primitives into JS types\n    // Returns the ASN.1 object's value as a boolean. Throws an error if the\n    // object is not a boolean.\n    toBoolean() {\n        if (!this.tag.isBoolean()) {\n            throw new error_1.ASN1TypeError('not a boolean');\n        }\n        return (0, parse_1.parseBoolean)(this.value);\n    }\n    // Returns the ASN.1 object's value as a BigInt. Throws an error if the\n    // object is not an integer.\n    toInteger() {\n        if (!this.tag.isInteger()) {\n            throw new error_1.ASN1TypeError('not an integer');\n        }\n        return (0, parse_1.parseInteger)(this.value);\n    }\n    // Returns the ASN.1 object's value as an OID string. Throws an error if the\n    // object is not an OID.\n    toOID() {\n        if (!this.tag.isOID()) {\n            throw new error_1.ASN1TypeError('not an OID');\n        }\n        return (0, parse_1.parseOID)(this.value);\n    }\n    // Returns the ASN.1 object's value as a Date. Throws an error if the object\n    // is not either a UTCTime or a GeneralizedTime.\n    toDate() {\n        switch (true) {\n            case this.tag.isUTCTime():\n                return (0, parse_1.parseTime)(this.value, true);\n            case this.tag.isGeneralizedTime():\n                return (0, parse_1.parseTime)(this.value, false);\n            default:\n                throw new error_1.ASN1TypeError('not a date');\n        }\n    }\n    // Returns the ASN.1 object's value as a number[] where each number is the\n    // value of a bit in the bit string. Throws an error if the object is not a\n    // bit string.\n    toBitString() {\n        if (!this.tag.isBitString()) {\n            throw new error_1.ASN1TypeError('not a bit string');\n        }\n        return (0, parse_1.parseBitString)(this.value);\n    }\n}\nexports.ASN1Obj = ASN1Obj;\n/////////////////////////////////////////////////////////////////////////////\n// Internal stream parsing functions\nfunction parseStream(stream) {\n    // Parse tag, length, and value from stream\n    const tag = new tag_1.ASN1Tag(stream.getUint8());\n    const len = (0, length_1.decodeLength)(stream);\n    const value = stream.slice(stream.position, len);\n    const start = stream.position;\n    let subs = [];\n    // If the object is constructed, parse its children. Sometimes, children\n    // are embedded in OCTESTRING objects, so we need to check those\n    // for children as well.\n    if (tag.constructed) {\n        subs = collectSubs(stream, len);\n    }\n    else if (tag.isOctetString()) {\n        // Attempt to parse children of OCTETSTRING objects. If anything fails,\n        // assume the object is not constructed and treat as primitive.\n        try {\n            subs = collectSubs(stream, len);\n        }\n        catch (e) {\n            // Fail silently and treat as primitive\n        }\n    }\n    // If there are no children, move stream cursor to the end of the object\n    if (subs.length === 0) {\n        stream.seek(start + len);\n    }\n    return new ASN1Obj(tag, value, subs);\n}\nfunction collectSubs(stream, len) {\n    // Calculate end of object content\n    const end = stream.position + len;\n    // Make sure there are enough bytes left in the stream. This should never\n    // happen, cause it'll get caught when the stream is sliced in parseStream.\n    // Leaving as an extra check just in case.\n    /* istanbul ignore if */\n    if (end > stream.length) {\n        throw new error_1.ASN1ParseError('invalid length');\n    }\n    // Parse all children\n    const subs = [];\n    while (stream.position < end) {\n        subs.push(parseStream(stream));\n    }\n    // When we're done parsing children, we should be at the end of the object\n    if (stream.position !== end) {\n        throw new error_1.ASN1ParseError('invalid length');\n    }\n    return subs;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}