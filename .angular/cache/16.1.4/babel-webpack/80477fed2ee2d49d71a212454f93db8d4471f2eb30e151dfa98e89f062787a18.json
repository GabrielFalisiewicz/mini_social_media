{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TUFClient = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst tuf_js_1 = require(\"tuf-js\");\nconst target_1 = require(\"./target\");\nclass TUFClient {\n  constructor(options) {\n    initTufCache(options.cachePath, options.rootPath);\n    const remote = initRemoteConfig(options.cachePath, options.mirrorURL);\n    this.updater = initClient(options.cachePath, remote, options);\n  }\n  refresh() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.updater.refresh();\n    })();\n  }\n  getTarget(targetName) {\n    return (0, target_1.readTarget)(this.updater, targetName);\n  }\n}\nexports.TUFClient = TUFClient;\n// Initializes the TUF cache directory structure including the initial\n// root.json file. If the cache directory does not exist, it will be\n// created. If the targets directory does not exist, it will be created.\n// If the root.json file does not exist, it will be copied from the\n// rootPath argument.\nfunction initTufCache(cachePath, tufRootPath) {\n  const targetsPath = path_1.default.join(cachePath, 'targets');\n  const cachedRootPath = path_1.default.join(cachePath, 'root.json');\n  if (!fs_1.default.existsSync(cachePath)) {\n    fs_1.default.mkdirSync(cachePath, {\n      recursive: true\n    });\n  }\n  if (!fs_1.default.existsSync(targetsPath)) {\n    fs_1.default.mkdirSync(targetsPath);\n  }\n  if (!fs_1.default.existsSync(cachedRootPath)) {\n    fs_1.default.copyFileSync(tufRootPath, cachedRootPath);\n  }\n  return cachePath;\n}\n// Initializes the remote.json file, which contains the URL of the TUF\n// repository. If the file does not exist, it will be created. If the file\n// exists, it will be parsed and returned.\nfunction initRemoteConfig(rootDir, mirrorURL) {\n  let remoteConfig;\n  const remoteConfigPath = path_1.default.join(rootDir, 'remote.json');\n  if (fs_1.default.existsSync(remoteConfigPath)) {\n    const data = fs_1.default.readFileSync(remoteConfigPath, 'utf-8');\n    remoteConfig = JSON.parse(data);\n  }\n  if (!remoteConfig) {\n    remoteConfig = {\n      mirror: mirrorURL\n    };\n    fs_1.default.writeFileSync(remoteConfigPath, JSON.stringify(remoteConfig));\n  }\n  return remoteConfig;\n}\nfunction initClient(cachePath, remote, options) {\n  const baseURL = remote.mirror;\n  const config = {\n    fetchTimeout: options.timeout\n  };\n  // tuf-js only supports a number for fetchRetries so we have to\n  // convert the boolean and object options to a number.\n  /* istanbul ignore if */\n  if (typeof options.retry !== 'undefined') {\n    if (typeof options.retry === 'number') {\n      config.fetchRetries = options.retry;\n    } else if (typeof options.retry === 'object') {\n      config.fetchRetries = options.retry.retries;\n    } else if (options.retry === true) {\n      config.fetchRetries = 1;\n    }\n  }\n  return new tuf_js_1.Updater({\n    metadataBaseUrl: baseURL,\n    targetBaseUrl: `${baseURL}/targets`,\n    metadataDir: cachePath,\n    targetDir: path_1.default.join(cachePath, 'targets'),\n    config\n  });\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","__importDefault","mod","__esModule","Object","defineProperty","exports","value","TUFClient","fs_1","path_1","tuf_js_1","target_1","constructor","options","initTufCache","cachePath","rootPath","remote","initRemoteConfig","mirrorURL","updater","initClient","refresh","_this","getTarget","targetName","readTarget","tufRootPath","targetsPath","join","cachedRootPath","existsSync","mkdirSync","recursive","copyFileSync","rootDir","remoteConfig","remoteConfigPath","data","readFileSync","JSON","parse","mirror","writeFileSync","stringify","baseURL","config","fetchTimeout","timeout","retry","fetchRetries","retries","Updater","metadataBaseUrl","targetBaseUrl","metadataDir","targetDir"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@sigstore/tuf/dist/client.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TUFClient = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst fs_1 = __importDefault(require(\"fs\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst tuf_js_1 = require(\"tuf-js\");\nconst target_1 = require(\"./target\");\nclass TUFClient {\n    constructor(options) {\n        initTufCache(options.cachePath, options.rootPath);\n        const remote = initRemoteConfig(options.cachePath, options.mirrorURL);\n        this.updater = initClient(options.cachePath, remote, options);\n    }\n    async refresh() {\n        return this.updater.refresh();\n    }\n    getTarget(targetName) {\n        return (0, target_1.readTarget)(this.updater, targetName);\n    }\n}\nexports.TUFClient = TUFClient;\n// Initializes the TUF cache directory structure including the initial\n// root.json file. If the cache directory does not exist, it will be\n// created. If the targets directory does not exist, it will be created.\n// If the root.json file does not exist, it will be copied from the\n// rootPath argument.\nfunction initTufCache(cachePath, tufRootPath) {\n    const targetsPath = path_1.default.join(cachePath, 'targets');\n    const cachedRootPath = path_1.default.join(cachePath, 'root.json');\n    if (!fs_1.default.existsSync(cachePath)) {\n        fs_1.default.mkdirSync(cachePath, { recursive: true });\n    }\n    if (!fs_1.default.existsSync(targetsPath)) {\n        fs_1.default.mkdirSync(targetsPath);\n    }\n    if (!fs_1.default.existsSync(cachedRootPath)) {\n        fs_1.default.copyFileSync(tufRootPath, cachedRootPath);\n    }\n    return cachePath;\n}\n// Initializes the remote.json file, which contains the URL of the TUF\n// repository. If the file does not exist, it will be created. If the file\n// exists, it will be parsed and returned.\nfunction initRemoteConfig(rootDir, mirrorURL) {\n    let remoteConfig;\n    const remoteConfigPath = path_1.default.join(rootDir, 'remote.json');\n    if (fs_1.default.existsSync(remoteConfigPath)) {\n        const data = fs_1.default.readFileSync(remoteConfigPath, 'utf-8');\n        remoteConfig = JSON.parse(data);\n    }\n    if (!remoteConfig) {\n        remoteConfig = { mirror: mirrorURL };\n        fs_1.default.writeFileSync(remoteConfigPath, JSON.stringify(remoteConfig));\n    }\n    return remoteConfig;\n}\nfunction initClient(cachePath, remote, options) {\n    const baseURL = remote.mirror;\n    const config = {\n        fetchTimeout: options.timeout,\n    };\n    // tuf-js only supports a number for fetchRetries so we have to\n    // convert the boolean and object options to a number.\n    /* istanbul ignore if */\n    if (typeof options.retry !== 'undefined') {\n        if (typeof options.retry === 'number') {\n            config.fetchRetries = options.retry;\n        }\n        else if (typeof options.retry === 'object') {\n            config.fetchRetries = options.retry.retries;\n        }\n        else if (options.retry === true) {\n            config.fetchRetries = 1;\n        }\n    }\n    return new tuf_js_1.Updater({\n        metadataBaseUrl: baseURL,\n        targetBaseUrl: `${baseURL}/targets`,\n        metadataDir: cachePath,\n        targetDir: path_1.default.join(cachePath, 'targets'),\n        config,\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}