{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJsonSchemaToOptions = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nfunction parseJsonSchemaToOptions(_x, _x2) {\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\nfunction _parseJsonSchemaToOptions() {\n  _parseJsonSchemaToOptions = _asyncToGenerator(function* (registry, schema, interactive = true) {\n    const options = [];\n    function visitor(current, pointer, parentSchema) {\n      if (!parentSchema) {\n        // Ignore root.\n        return;\n      } else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n        // Ignore subitems (objects or arrays).\n        return;\n      } else if (core_1.json.isJsonArray(current)) {\n        return;\n      }\n      if (pointer.indexOf('/not/') != -1) {\n        // We don't support anyOf/not.\n        throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n      }\n      const ptr = core_1.json.schema.parseJsonPointer(pointer);\n      const name = ptr[ptr.length - 1];\n      if (ptr[ptr.length - 2] != 'properties') {\n        // Skip any non-property items.\n        return;\n      }\n      const typeSet = core_1.json.schema.getTypesOfSchema(current);\n      if (typeSet.size == 0) {\n        throw new Error('Cannot find type of schema.');\n      }\n      // We only support number, string or boolean (or array of those), so remove everything else.\n      const types = [...typeSet].filter(x => {\n        switch (x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n          case 'array':\n            // Only include arrays if they're boolean, string or number.\n            if (core_1.json.isJsonObject(current.items) && typeof current.items.type == 'string' && ['boolean', 'number', 'string'].includes(current.items.type)) {\n              return true;\n            }\n            return false;\n          default:\n            return false;\n        }\n      });\n      if (types.length == 0) {\n        // This means it's not usable on the command line. e.g. an Object.\n        return;\n      }\n      // Only keep enum values we support (booleans, numbers and strings).\n      const enumValues = (core_1.json.isJsonArray(current.enum) && current.enum || []).filter(x => {\n        switch (typeof x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n          default:\n            return false;\n        }\n      });\n      let defaultValue = undefined;\n      if (current.default !== undefined) {\n        switch (types[0]) {\n          case 'string':\n            if (typeof current.default == 'string') {\n              defaultValue = current.default;\n            }\n            break;\n          case 'number':\n            if (typeof current.default == 'number') {\n              defaultValue = current.default;\n            }\n            break;\n          case 'boolean':\n            if (typeof current.default == 'boolean') {\n              defaultValue = current.default;\n            }\n            break;\n        }\n      }\n      const type = types[0];\n      const $default = current.$default;\n      const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n      const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n      let required = core_1.json.isJsonArray(schema.required) ? schema.required.includes(name) : false;\n      if (required && interactive && current['x-prompt']) {\n        required = false;\n      }\n      const alias = core_1.json.isJsonArray(current.aliases) ? [...current.aliases].map(x => '' + x) : current.alias ? ['' + current.alias] : [];\n      const format = typeof current.format == 'string' ? current.format : undefined;\n      const visible = current.visible === undefined || current.visible === true;\n      const hidden = !!current.hidden || !visible;\n      const xUserAnalytics = current['x-user-analytics'];\n      const userAnalytics = typeof xUserAnalytics === 'string' ? xUserAnalytics : undefined;\n      // Deprecated is set only if it's true or a string.\n      const xDeprecated = current['x-deprecated'];\n      const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n      const option = {\n        name,\n        description: '' + (current.description === undefined ? '' : current.description),\n        type,\n        default: defaultValue,\n        choices: enumValues.length ? enumValues : undefined,\n        required,\n        alias,\n        format,\n        hidden,\n        userAnalytics,\n        deprecated,\n        positional\n      };\n      options.push(option);\n    }\n    const flattenedSchema = yield registry.ɵflatten(schema);\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor);\n    // Sort by positional and name.\n    return options.sort((a, b) => {\n      if (a.positional) {\n        return b.positional ? a.positional - b.positional : a.name.localeCompare(b.name);\n      } else if (b.positional) {\n        return -1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n  });\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","parseJsonSchemaToOptions","core_1","_x","_x2","_parseJsonSchemaToOptions","apply","arguments","registry","schema","interactive","options","visitor","current","pointer","parentSchema","split","length","json","isJsonArray","indexOf","Error","ptr","parseJsonPointer","name","typeSet","getTypesOfSchema","size","types","filter","x","isJsonObject","items","type","includes","enumValues","enum","defaultValue","undefined","$default","$defaultIndex","positional","required","alias","aliases","map","format","visible","hidden","xUserAnalytics","userAnalytics","xDeprecated","deprecated","option","description","choices","push","flattenedSchema","ɵflatten","visitJsonSchema","sort","a","b","localeCompare"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular/cli/src/command-builder/utilities/json-schema.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJsonSchemaToOptions = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nasync function parseJsonSchemaToOptions(registry, schema, interactive = true) {\n    const options = [];\n    function visitor(current, pointer, parentSchema) {\n        if (!parentSchema) {\n            // Ignore root.\n            return;\n        }\n        else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n            // Ignore subitems (objects or arrays).\n            return;\n        }\n        else if (core_1.json.isJsonArray(current)) {\n            return;\n        }\n        if (pointer.indexOf('/not/') != -1) {\n            // We don't support anyOf/not.\n            throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n        }\n        const ptr = core_1.json.schema.parseJsonPointer(pointer);\n        const name = ptr[ptr.length - 1];\n        if (ptr[ptr.length - 2] != 'properties') {\n            // Skip any non-property items.\n            return;\n        }\n        const typeSet = core_1.json.schema.getTypesOfSchema(current);\n        if (typeSet.size == 0) {\n            throw new Error('Cannot find type of schema.');\n        }\n        // We only support number, string or boolean (or array of those), so remove everything else.\n        const types = [...typeSet].filter((x) => {\n            switch (x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                case 'array':\n                    // Only include arrays if they're boolean, string or number.\n                    if (core_1.json.isJsonObject(current.items) &&\n                        typeof current.items.type == 'string' &&\n                        ['boolean', 'number', 'string'].includes(current.items.type)) {\n                        return true;\n                    }\n                    return false;\n                default:\n                    return false;\n            }\n        });\n        if (types.length == 0) {\n            // This means it's not usable on the command line. e.g. an Object.\n            return;\n        }\n        // Only keep enum values we support (booleans, numbers and strings).\n        const enumValues = ((core_1.json.isJsonArray(current.enum) && current.enum) || []).filter((x) => {\n            switch (typeof x) {\n                case 'boolean':\n                case 'number':\n                case 'string':\n                    return true;\n                default:\n                    return false;\n            }\n        });\n        let defaultValue = undefined;\n        if (current.default !== undefined) {\n            switch (types[0]) {\n                case 'string':\n                    if (typeof current.default == 'string') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'number':\n                    if (typeof current.default == 'number') {\n                        defaultValue = current.default;\n                    }\n                    break;\n                case 'boolean':\n                    if (typeof current.default == 'boolean') {\n                        defaultValue = current.default;\n                    }\n                    break;\n            }\n        }\n        const type = types[0];\n        const $default = current.$default;\n        const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n        const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n        let required = core_1.json.isJsonArray(schema.required) ? schema.required.includes(name) : false;\n        if (required && interactive && current['x-prompt']) {\n            required = false;\n        }\n        const alias = core_1.json.isJsonArray(current.aliases)\n            ? [...current.aliases].map((x) => '' + x)\n            : current.alias\n                ? ['' + current.alias]\n                : [];\n        const format = typeof current.format == 'string' ? current.format : undefined;\n        const visible = current.visible === undefined || current.visible === true;\n        const hidden = !!current.hidden || !visible;\n        const xUserAnalytics = current['x-user-analytics'];\n        const userAnalytics = typeof xUserAnalytics === 'string' ? xUserAnalytics : undefined;\n        // Deprecated is set only if it's true or a string.\n        const xDeprecated = current['x-deprecated'];\n        const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n        const option = {\n            name,\n            description: '' + (current.description === undefined ? '' : current.description),\n            type,\n            default: defaultValue,\n            choices: enumValues.length ? enumValues : undefined,\n            required,\n            alias,\n            format,\n            hidden,\n            userAnalytics,\n            deprecated,\n            positional,\n        };\n        options.push(option);\n    }\n    const flattenedSchema = await registry.ɵflatten(schema);\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor);\n    // Sort by positional and name.\n    return options.sort((a, b) => {\n        if (a.positional) {\n            return b.positional ? a.positional - b.positional : a.name.localeCompare(b.name);\n        }\n        else if (b.positional) {\n            return -1;\n        }\n        return a.name.localeCompare(b.name);\n    });\n}\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}