{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(require(\"brace-expansion\"));\nconst assert_valid_pattern_js_1 = require(\"./assert-valid-pattern.js\");\nconst ast_js_1 = require(\"./ast.js\");\nconst escape_js_1 = require(\"./escape.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = ext => f => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = ext => f => f.endsWith(ext);\nconst starDotExtTestNocase = ext => {\n  ext = ext.toLowerCase();\n  return f => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = ext => {\n  ext = ext.toLowerCase();\n  return f => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = f => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = f => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = f => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = f => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = f => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = typeof process === 'object' && process ? typeof process.env === 'object' && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : 'posix';\nconst path = {\n  win32: {\n    sep: '\\\\'\n  },\n  posix: {\n    sep: '/'\n  }\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => p => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return exports.minimatch;\n  }\n  const orig = exports.minimatch;\n  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern, options = {}) {\n        super(pattern, ext(def, options));\n      }\n      static defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n      }\n    },\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(type, parent, options = {}) {\n        super(type, parent, ext(def, options));\n      }\n      /* c8 ignore stop */\n      static fromGlob(pattern, options = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options));\n      }\n    },\n    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n    escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n    defaults: options => orig.defaults(ext(def, options)),\n    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n    sep: orig.sep,\n    GLOBSTAR: exports.GLOBSTAR\n  });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n  constructor(pattern, options = {}) {\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"set\", void 0);\n    _defineProperty(this, \"pattern\", void 0);\n    _defineProperty(this, \"windowsPathsNoEscape\", void 0);\n    _defineProperty(this, \"nonegate\", void 0);\n    _defineProperty(this, \"negate\", void 0);\n    _defineProperty(this, \"comment\", void 0);\n    _defineProperty(this, \"empty\", void 0);\n    _defineProperty(this, \"preserveMultipleSlashes\", void 0);\n    _defineProperty(this, \"partial\", void 0);\n    _defineProperty(this, \"globSet\", void 0);\n    _defineProperty(this, \"globParts\", void 0);\n    _defineProperty(this, \"nocase\", void 0);\n    _defineProperty(this, \"isWindows\", void 0);\n    _defineProperty(this, \"platform\", void 0);\n    _defineProperty(this, \"windowsNoMagicRoot\", void 0);\n    _defineProperty(this, \"regexp\", void 0);\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    options = options || {};\n    this.options = options;\n    this.pattern = pattern;\n    this.platform = options.platform || defaultPlatform;\n    this.isWindows = this.platform === 'win32';\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n    this.regexp = null;\n    this.negate = false;\n    this.nonegate = !!options.nonegate;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    this.nocase = !!this.options.nocase;\n    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n    this.globSet = [];\n    this.globParts = [];\n    this.set = [];\n    // make the set of regexps etc.\n    this.make();\n  }\n  hasMagic() {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true;\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true;\n      }\n    }\n    return false;\n  }\n  debug(..._) {}\n  make() {\n    const pattern = this.pattern;\n    const options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n    if (!pattern) {\n      this.empty = true;\n      return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())];\n    if (options.debug) {\n      this.debug = (...args) => console.error(...args);\n    }\n    this.debug(this.pattern, this.globSet);\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n    this.globParts = this.preprocess(rawGlobParts);\n    this.debug(this.pattern, this.globParts);\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC = s[0] === '' && s[1] === '' && (s[2] === '?' || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n        const isDrive = /^[a-z]:/i.test(s[0]);\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n        }\n      }\n      return s.map(ss => this.parse(ss));\n    });\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(s => s.indexOf(false) === -1);\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i];\n        if (p[0] === '' && p[1] === '' && this.globParts[i][2] === '?' && typeof p[3] === 'string' && /^[a-z]:$/i.test(p[3])) {\n          p[2] = '?';\n        }\n      }\n    }\n    this.debug(this.pattern, this.set);\n  }\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*';\n          }\n        }\n      }\n    }\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts);\n      globParts = this.secondPhasePreProcess(globParts);\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts);\n    } else {\n      globParts = this.adjascentGlobstarOptimize(globParts);\n    }\n    return globParts;\n  }\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts) {\n    return globParts.map(parts => {\n      let gs = -1;\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs;\n        while (parts[i + 1] === '**') {\n          i++;\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs);\n        }\n      }\n      return parts;\n    });\n  }\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set, part) => {\n        const prev = set[set.length - 1];\n        if (part === '**' && prev === '**') {\n          return set;\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop();\n            return set;\n          }\n        }\n        set.push(part);\n        return set;\n      }, []);\n      return parts.length === 0 ? [''] : parts;\n    });\n  }\n  levelTwoFileOptimize(parts) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts);\n    }\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i];\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue;\n          if (p === '.' || p === '') {\n            didSomething = true;\n            parts.splice(i, 1);\n            i--;\n          }\n        }\n        if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n          didSomething = true;\n          parts.pop();\n        }\n      }\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd = 0;\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1];\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true;\n          parts.splice(dd - 1, 2);\n          dd -= 2;\n        }\n      }\n    } while (didSomething);\n    return parts.length === 0 ? [''] : parts;\n  }\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts) {\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs = -1;\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss = gs;\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++;\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs);\n          }\n          let next = parts[gs + 1];\n          const p = parts[gs + 2];\n          const p2 = parts[gs + 3];\n          if (next !== '..') continue;\n          if (!p || p === '.' || p === '..' || !p2 || p2 === '.' || p2 === '..') {\n            continue;\n          }\n          didSomething = true;\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1);\n          const other = parts.slice(0);\n          other[gs] = '**';\n          globParts.push(other);\n          gs--;\n        }\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i];\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue;\n            if (p === '.' || p === '') {\n              didSomething = true;\n              parts.splice(i, 1);\n              i--;\n            }\n          }\n          if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n            didSomething = true;\n            parts.pop();\n          }\n        }\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd = 0;\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1];\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true;\n            const needDot = dd === 1 && parts[dd + 1] === '**';\n            const splin = needDot ? ['.'] : [];\n            parts.splice(dd - 1, 2, ...splin);\n            if (parts.length === 0) parts.push('');\n            dd -= 2;\n          }\n        }\n      }\n    } while (didSomething);\n    return globParts;\n  }\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts) {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n        if (!matched) continue;\n        globParts[i] = matched;\n        globParts[j] = [];\n      }\n    }\n    return globParts.filter(gs => gs.length);\n  }\n  partsMatch(a, b, emptyGSMatch = false) {\n    let ai = 0;\n    let bi = 0;\n    let result = [];\n    let which = '';\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai]);\n        ai++;\n        bi++;\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai]);\n        ai++;\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi]);\n        bi++;\n      } else if (a[ai] === '*' && b[bi] && (this.options.dot || !b[bi].startsWith('.')) && b[bi] !== '**') {\n        if (which === 'b') return false;\n        which = 'a';\n        result.push(a[ai]);\n        ai++;\n        bi++;\n      } else if (b[bi] === '*' && a[ai] && (this.options.dot || !a[ai].startsWith('.')) && a[ai] !== '**') {\n        if (which === 'a') return false;\n        which = 'b';\n        result.push(b[bi]);\n        ai++;\n        bi++;\n      } else {\n        return false;\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result;\n  }\n  parseNegate() {\n    if (this.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.slice(negateOffset);\n    this.negate = negate;\n  }\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file, pattern, partial = false) {\n    const options = this.options;\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n      const fileUNC = !fileDrive && file[0] === '' && file[1] === '' && file[2] === '?' && /^[a-z]:$/i.test(file[3]);\n      const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n      const patternUNC = !patternDrive && pattern[0] === '' && pattern[1] === '' && pattern[2] === '?' && typeof pattern[3] === 'string' && /^[a-z]:$/i.test(pattern[3]);\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd] = [file[fdi], pattern[pdi]];\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd;\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi);\n          } else if (fdi > pdi) {\n            file = file.slice(fdi);\n          }\n        }\n      }\n    }\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file);\n    }\n    this.debug('matchOne', this, {\n      file,\n      pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f);\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false;\n      }\n      /* c8 ignore stop */\n      if (p === exports.GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]);\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi;\n        var pr = pi + 1;\n        if (pr === pl) {\n          this.debug('** at the end');\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n          return true;\n        }\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee);\n            // found a match.\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            }\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        }\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) {\n            return true;\n          }\n        }\n        /* c8 ignore stop */\n        return false;\n      }\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit;\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = p.test(f);\n        this.debug('pattern match', p, f, hit);\n      }\n      if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?');\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return (0, exports.braceExpand)(this.pattern, this.options);\n  }\n  parse(pattern) {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    const options = this.options;\n    // shortcuts\n    if (pattern === '**') return exports.GLOBSTAR;\n    if (pattern === '') return '';\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m;\n    let fastTest = null;\n    if (m = pattern.match(starRE)) {\n      fastTest = options.dot ? starTestDot : starTest;\n    } else if (m = pattern.match(starDotExtRE)) {\n      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n    } else if (m = pattern.match(qmarksRE)) {\n      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n    } else if (m = pattern.match(starDotStarRE)) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n    } else if (m = pattern.match(dotStarRE)) {\n      fastTest = dotStarTest;\n    }\n    const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n    return fastTest ? Object.assign(re, {\n      test: fastTest\n    }) : re;\n  }\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set;\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = new Set(options.nocase ? ['i'] : []);\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      const pp = pattern.map(p => {\n        if (p instanceof RegExp) {\n          for (const f of p.flags.split('')) flags.add(f);\n        }\n        return typeof p === 'string' ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;\n      });\n      pp.forEach((p, i) => {\n        const next = pp[i + 1];\n        const prev = pp[i - 1];\n        if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n          return;\n        }\n        if (prev === undefined) {\n          if (next !== undefined && next !== exports.GLOBSTAR) {\n            pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n          } else {\n            pp[i] = twoStar;\n          }\n        } else if (next === undefined) {\n          pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n        } else if (next !== exports.GLOBSTAR) {\n          pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n          pp[i + 1] = exports.GLOBSTAR;\n        }\n      });\n      return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n    }).join('|');\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$';\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$';\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''));\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false;\n    }\n    /* c8 ignore stop */\n    return this.regexp;\n  }\n  slashSplit(p) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/');\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)];\n    } else {\n      return p.split(/\\/+/);\n    }\n  }\n  match(f, partial = this.partial) {\n    this.debug('match', f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false;\n    }\n    if (this.empty) {\n      return f === '';\n    }\n    if (f === '/' && partial) {\n      return true;\n    }\n    const options = this.options;\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/');\n    }\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f);\n    this.debug(this.pattern, 'split', ff);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    const set = this.set;\n    this.debug(this.pattern, 'set', set);\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename = ff[ff.length - 1];\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i];\n      }\n    }\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = ff;\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n      const hit = this.matchOne(file, pattern, partial);\n      if (hit) {\n        if (options.flipNegate) {\n          return true;\n        }\n        return !this.negate;\n      }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false;\n    }\n    return this.negate;\n  }\n  static defaults(def) {\n    return exports.minimatch.defaults(def).Minimatch;\n  }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = require(\"./ast.js\");\nObject.defineProperty(exports, \"AST\", {\n  enumerable: true,\n  get: function () {\n    return ast_js_2.AST;\n  }\n});\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"escape\", {\n  enumerable: true,\n  get: function () {\n    return escape_js_2.escape;\n  }\n});\nvar unescape_js_2 = require(\"./unescape.js\");\nObject.defineProperty(exports, \"unescape\", {\n  enumerable: true,\n  get: function () {\n    return unescape_js_2.unescape;\n  }\n});\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;","map":{"version":3,"names":["_defineProperty","require","default","__importDefault","mod","__esModule","Object","defineProperty","exports","value","unescape","escape","AST","Minimatch","match","makeRe","braceExpand","defaults","filter","GLOBSTAR","sep","minimatch","brace_expansion_1","assert_valid_pattern_js_1","ast_js_1","escape_js_1","unescape_js_1","p","pattern","options","assertValidPattern","nocomment","charAt","starDotExtRE","starDotExtTest","ext","f","startsWith","endsWith","starDotExtTestDot","starDotExtTestNocase","toLowerCase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","includes","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","length","starTestDot","qmarksRE","qmarksTestNocase","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","len","defaultPlatform","process","env","__MINIMATCH_TESTING_PLATFORM__","platform","path","win32","posix","Symbol","qmark","star","twoStarDot","twoStarNoDot","a","b","assign","def","keys","orig","m","constructor","type","parent","fromGlob","s","list","nobrace","test","mm","nonull","push","globMagic","regExpEscape","replace","isWindows","windowsPathsNoEscape","allowWindowsEscape","preserveMultipleSlashes","regexp","negate","nonegate","comment","empty","partial","nocase","windowsNoMagicRoot","undefined","globSet","globParts","set","make","hasMagic","magicalBraces","part","debug","_","parseNegate","Set","args","console","error","rawGlobParts","map","slashSplit","preprocess","__","isUNC","isDrive","slice","ss","parse","indexOf","i","noglobstar","j","optimizationLevel","firstPhasePreProcess","secondPhasePreProcess","levelOneOptimize","adjascentGlobstarOptimize","parts","gs","splice","reduce","prev","pop","levelTwoFileOptimize","Array","isArray","didSomething","dd","gss","next","p2","other","needDot","splin","matched","partsMatch","emptyGSMatch","ai","bi","result","which","dot","negateOffset","matchOne","file","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","fd","pd","fi","pi","fl","pl","fr","pr","swallowee","hit","Error","fastTest","re","toMMPattern","twoStar","flags","pp","RegExp","split","add","_src","forEach","join","open","close","ex","ff","filename","matchBase","flipNegate","ast_js_2","enumerable","get","escape_js_2","unescape_js_2"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/minimatch/dist/cjs/index.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(require(\"brace-expansion\"));\nconst assert_valid_pattern_js_1 = require(\"./assert-valid-pattern.js\");\nconst ast_js_1 = require(\"./ast.js\");\nconst escape_js_1 = require(\"./escape.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return exports.minimatch;\n    }\n    const orig = exports.minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: exports.GLOBSTAR,\n    });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (!matched)\n                    continue;\n                globParts[i] = matched;\n                globParts[j] = [];\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // dont' need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === exports.GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return (0, exports.braceExpand)(this.pattern, this.options);\n    }\n    parse(pattern) {\n        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return exports.GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n        return fastTest ? Object.assign(re, { test: fastTest }) : re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === exports.GLOBSTAR\n                        ? exports.GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== exports.GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n                }\n                else if (next !== exports.GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = exports.GLOBSTAR;\n                }\n            });\n            return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return exports.minimatch.defaults(def).Minimatch;\n    }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = require(\"./ast.js\");\nObject.defineProperty(exports, \"AST\", { enumerable: true, get: function () { return ast_js_2.AST; } });\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return escape_js_2.escape; } });\nvar unescape_js_2 = require(\"./unescape.js\");\nObject.defineProperty(exports, \"unescape\", { enumerable: true, get: function () { return unescape_js_2.unescape; } });\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}