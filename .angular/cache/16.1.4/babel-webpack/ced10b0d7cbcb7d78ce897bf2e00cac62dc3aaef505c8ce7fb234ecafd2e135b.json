{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toMessageSignatureBundle = exports.toDSSEBundle = exports.isVerifiableTransparencyLogEntry = exports.isCAVerificationOptions = exports.isBundleWithCertificateChain = exports.bundleToJSON = exports.bundleFromJSON = exports.SubjectAlternativeNameType = exports.PublicKeyDetails = exports.HashAlgorithm = exports.Envelope = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst protobuf_specs_1 = require(\"@sigstore/protobuf-specs\");\nconst util_1 = require(\"../../util\");\nconst validate_1 = require(\"./validate\");\n// Enums from protobuf-specs\n// TODO: Move Envelope to \"type\" export once @sigstore/sign is a thing\nvar protobuf_specs_2 = require(\"@sigstore/protobuf-specs\");\nObject.defineProperty(exports, \"Envelope\", {\n  enumerable: true,\n  get: function () {\n    return protobuf_specs_2.Envelope;\n  }\n});\nObject.defineProperty(exports, \"HashAlgorithm\", {\n  enumerable: true,\n  get: function () {\n    return protobuf_specs_2.HashAlgorithm;\n  }\n});\nObject.defineProperty(exports, \"PublicKeyDetails\", {\n  enumerable: true,\n  get: function () {\n    return protobuf_specs_2.PublicKeyDetails;\n  }\n});\nObject.defineProperty(exports, \"SubjectAlternativeNameType\", {\n  enumerable: true,\n  get: function () {\n    return protobuf_specs_2.SubjectAlternativeNameType;\n  }\n});\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst bundleFromJSON = obj => {\n  const bundle = protobuf_specs_1.Bundle.fromJSON(obj);\n  (0, validate_1.assertValidBundle)(bundle);\n  return bundle;\n};\nexports.bundleFromJSON = bundleFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst bundleToJSON = bundle => {\n  return protobuf_specs_1.Bundle.toJSON(bundle);\n};\nexports.bundleToJSON = bundleToJSON;\nconst BUNDLE_MEDIA_TYPE = 'application/vnd.dev.sigstore.bundle+json;version=0.1';\n// Type guard for narrowing a Bundle to a BundleWithCertificateChain\nfunction isBundleWithCertificateChain(bundle) {\n  return bundle.verificationMaterial.content !== undefined && bundle.verificationMaterial.content.$case === 'x509CertificateChain';\n}\nexports.isBundleWithCertificateChain = isBundleWithCertificateChain;\nfunction isCAVerificationOptions(options) {\n  return options.ctlogOptions !== undefined && (options.signers === undefined || options.signers.$case === 'certificateIdentities');\n}\nexports.isCAVerificationOptions = isCAVerificationOptions;\nfunction isVerifiableTransparencyLogEntry(entry) {\n  return entry.logId !== undefined && entry.inclusionPromise !== undefined && entry.kindVersion !== undefined;\n}\nexports.isVerifiableTransparencyLogEntry = isVerifiableTransparencyLogEntry;\n// All of the following functions are used to construct a ValidBundle\n// from various types of input. When this code moves into the\n// @sigstore/sign package, these functions will be exported from there.\nfunction toDSSEBundle({\n  envelope,\n  signature,\n  tlogEntry,\n  timestamp\n}) {\n  return {\n    mediaType: BUNDLE_MEDIA_TYPE,\n    content: {\n      $case: 'dsseEnvelope',\n      dsseEnvelope: envelope\n    },\n    verificationMaterial: toVerificationMaterial({\n      signature,\n      tlogEntry,\n      timestamp\n    })\n  };\n}\nexports.toDSSEBundle = toDSSEBundle;\nfunction toMessageSignatureBundle({\n  digest,\n  signature,\n  tlogEntry,\n  timestamp\n}) {\n  return {\n    mediaType: BUNDLE_MEDIA_TYPE,\n    content: {\n      $case: 'messageSignature',\n      messageSignature: {\n        messageDigest: {\n          algorithm: protobuf_specs_1.HashAlgorithm.SHA2_256,\n          digest: digest\n        },\n        signature: signature.signature\n      }\n    },\n    verificationMaterial: toVerificationMaterial({\n      signature,\n      tlogEntry,\n      timestamp\n    })\n  };\n}\nexports.toMessageSignatureBundle = toMessageSignatureBundle;\nfunction toTransparencyLogEntry(entry) {\n  const b64SET = entry.verification?.signedEntryTimestamp || '';\n  const set = Buffer.from(b64SET, 'base64');\n  const logID = Buffer.from(entry.logID, 'hex');\n  const proof = entry.verification?.inclusionProof ? toInclusionProof(entry.verification.inclusionProof) : undefined;\n  // Parse entry body so we can extract the kind and version.\n  const bodyJSON = util_1.encoding.base64Decode(entry.body);\n  const entryBody = JSON.parse(bodyJSON);\n  return {\n    inclusionPromise: {\n      signedEntryTimestamp: set\n    },\n    logIndex: entry.logIndex.toString(),\n    logId: {\n      keyId: logID\n    },\n    integratedTime: entry.integratedTime.toString(),\n    kindVersion: {\n      kind: entryBody.kind,\n      version: entryBody.apiVersion\n    },\n    inclusionProof: proof,\n    canonicalizedBody: Buffer.from(entry.body, 'base64')\n  };\n}\nfunction toInclusionProof(proof) {\n  return {\n    logIndex: proof.logIndex.toString(),\n    rootHash: Buffer.from(proof.rootHash, 'hex'),\n    treeSize: proof.treeSize.toString(),\n    checkpoint: {\n      envelope: proof.checkpoint\n    },\n    hashes: proof.hashes.map(h => Buffer.from(h, 'hex'))\n  };\n}\nfunction toVerificationMaterial({\n  signature,\n  tlogEntry,\n  timestamp\n}) {\n  return {\n    content: signature.certificates ? toVerificationMaterialx509CertificateChain(signature.certificates) : toVerificationMaterialPublicKey(signature.key.id || ''),\n    tlogEntries: tlogEntry ? [toTransparencyLogEntry(tlogEntry)] : [],\n    timestampVerificationData: timestamp ? toTimestampVerificationData(timestamp) : undefined\n  };\n}\nfunction toVerificationMaterialx509CertificateChain(certificates) {\n  return {\n    $case: 'x509CertificateChain',\n    x509CertificateChain: {\n      certificates: certificates.map(c => ({\n        rawBytes: util_1.pem.toDER(c)\n      }))\n    }\n  };\n}\nfunction toVerificationMaterialPublicKey(hint) {\n  return {\n    $case: 'publicKey',\n    publicKey: {\n      hint\n    }\n  };\n}\nfunction toTimestampVerificationData(timestamp) {\n  return {\n    rfc3161Timestamps: [{\n      signedTimestamp: timestamp\n    }]\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","toMessageSignatureBundle","toDSSEBundle","isVerifiableTransparencyLogEntry","isCAVerificationOptions","isBundleWithCertificateChain","bundleToJSON","bundleFromJSON","SubjectAlternativeNameType","PublicKeyDetails","HashAlgorithm","Envelope","protobuf_specs_1","require","util_1","validate_1","protobuf_specs_2","enumerable","get","obj","bundle","Bundle","fromJSON","assertValidBundle","toJSON","BUNDLE_MEDIA_TYPE","verificationMaterial","content","undefined","$case","options","ctlogOptions","signers","entry","logId","inclusionPromise","kindVersion","envelope","signature","tlogEntry","timestamp","mediaType","dsseEnvelope","toVerificationMaterial","digest","messageSignature","messageDigest","algorithm","SHA2_256","toTransparencyLogEntry","b64SET","verification","signedEntryTimestamp","set","Buffer","from","logID","proof","inclusionProof","toInclusionProof","bodyJSON","encoding","base64Decode","body","entryBody","JSON","parse","logIndex","toString","keyId","integratedTime","kind","version","apiVersion","canonicalizedBody","rootHash","treeSize","checkpoint","hashes","map","h","certificates","toVerificationMaterialx509CertificateChain","toVerificationMaterialPublicKey","key","id","tlogEntries","timestampVerificationData","toTimestampVerificationData","x509CertificateChain","c","rawBytes","pem","toDER","hint","publicKey","rfc3161Timestamps","signedTimestamp"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/types/sigstore/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toMessageSignatureBundle = exports.toDSSEBundle = exports.isVerifiableTransparencyLogEntry = exports.isCAVerificationOptions = exports.isBundleWithCertificateChain = exports.bundleToJSON = exports.bundleFromJSON = exports.SubjectAlternativeNameType = exports.PublicKeyDetails = exports.HashAlgorithm = exports.Envelope = void 0;\n/*\nCopyright 2023 The Sigstore Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nconst protobuf_specs_1 = require(\"@sigstore/protobuf-specs\");\nconst util_1 = require(\"../../util\");\nconst validate_1 = require(\"./validate\");\n// Enums from protobuf-specs\n// TODO: Move Envelope to \"type\" export once @sigstore/sign is a thing\nvar protobuf_specs_2 = require(\"@sigstore/protobuf-specs\");\nObject.defineProperty(exports, \"Envelope\", { enumerable: true, get: function () { return protobuf_specs_2.Envelope; } });\nObject.defineProperty(exports, \"HashAlgorithm\", { enumerable: true, get: function () { return protobuf_specs_2.HashAlgorithm; } });\nObject.defineProperty(exports, \"PublicKeyDetails\", { enumerable: true, get: function () { return protobuf_specs_2.PublicKeyDetails; } });\nObject.defineProperty(exports, \"SubjectAlternativeNameType\", { enumerable: true, get: function () { return protobuf_specs_2.SubjectAlternativeNameType; } });\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst bundleFromJSON = (obj) => {\n    const bundle = protobuf_specs_1.Bundle.fromJSON(obj);\n    (0, validate_1.assertValidBundle)(bundle);\n    return bundle;\n};\nexports.bundleFromJSON = bundleFromJSON;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst bundleToJSON = (bundle) => {\n    return protobuf_specs_1.Bundle.toJSON(bundle);\n};\nexports.bundleToJSON = bundleToJSON;\nconst BUNDLE_MEDIA_TYPE = 'application/vnd.dev.sigstore.bundle+json;version=0.1';\n// Type guard for narrowing a Bundle to a BundleWithCertificateChain\nfunction isBundleWithCertificateChain(bundle) {\n    return (bundle.verificationMaterial.content !== undefined &&\n        bundle.verificationMaterial.content.$case === 'x509CertificateChain');\n}\nexports.isBundleWithCertificateChain = isBundleWithCertificateChain;\nfunction isCAVerificationOptions(options) {\n    return (options.ctlogOptions !== undefined &&\n        (options.signers === undefined ||\n            options.signers.$case === 'certificateIdentities'));\n}\nexports.isCAVerificationOptions = isCAVerificationOptions;\nfunction isVerifiableTransparencyLogEntry(entry) {\n    return (entry.logId !== undefined &&\n        entry.inclusionPromise !== undefined &&\n        entry.kindVersion !== undefined);\n}\nexports.isVerifiableTransparencyLogEntry = isVerifiableTransparencyLogEntry;\n// All of the following functions are used to construct a ValidBundle\n// from various types of input. When this code moves into the\n// @sigstore/sign package, these functions will be exported from there.\nfunction toDSSEBundle({ envelope, signature, tlogEntry, timestamp, }) {\n    return {\n        mediaType: BUNDLE_MEDIA_TYPE,\n        content: { $case: 'dsseEnvelope', dsseEnvelope: envelope },\n        verificationMaterial: toVerificationMaterial({\n            signature,\n            tlogEntry,\n            timestamp,\n        }),\n    };\n}\nexports.toDSSEBundle = toDSSEBundle;\nfunction toMessageSignatureBundle({ digest, signature, tlogEntry, timestamp, }) {\n    return {\n        mediaType: BUNDLE_MEDIA_TYPE,\n        content: {\n            $case: 'messageSignature',\n            messageSignature: {\n                messageDigest: {\n                    algorithm: protobuf_specs_1.HashAlgorithm.SHA2_256,\n                    digest: digest,\n                },\n                signature: signature.signature,\n            },\n        },\n        verificationMaterial: toVerificationMaterial({\n            signature,\n            tlogEntry,\n            timestamp,\n        }),\n    };\n}\nexports.toMessageSignatureBundle = toMessageSignatureBundle;\nfunction toTransparencyLogEntry(entry) {\n    const b64SET = entry.verification?.signedEntryTimestamp || '';\n    const set = Buffer.from(b64SET, 'base64');\n    const logID = Buffer.from(entry.logID, 'hex');\n    const proof = entry.verification?.inclusionProof\n        ? toInclusionProof(entry.verification.inclusionProof)\n        : undefined;\n    // Parse entry body so we can extract the kind and version.\n    const bodyJSON = util_1.encoding.base64Decode(entry.body);\n    const entryBody = JSON.parse(bodyJSON);\n    return {\n        inclusionPromise: {\n            signedEntryTimestamp: set,\n        },\n        logIndex: entry.logIndex.toString(),\n        logId: {\n            keyId: logID,\n        },\n        integratedTime: entry.integratedTime.toString(),\n        kindVersion: {\n            kind: entryBody.kind,\n            version: entryBody.apiVersion,\n        },\n        inclusionProof: proof,\n        canonicalizedBody: Buffer.from(entry.body, 'base64'),\n    };\n}\nfunction toInclusionProof(proof) {\n    return {\n        logIndex: proof.logIndex.toString(),\n        rootHash: Buffer.from(proof.rootHash, 'hex'),\n        treeSize: proof.treeSize.toString(),\n        checkpoint: {\n            envelope: proof.checkpoint,\n        },\n        hashes: proof.hashes.map((h) => Buffer.from(h, 'hex')),\n    };\n}\nfunction toVerificationMaterial({ signature, tlogEntry, timestamp, }) {\n    return {\n        content: signature.certificates\n            ? toVerificationMaterialx509CertificateChain(signature.certificates)\n            : toVerificationMaterialPublicKey(signature.key.id || ''),\n        tlogEntries: tlogEntry ? [toTransparencyLogEntry(tlogEntry)] : [],\n        timestampVerificationData: timestamp\n            ? toTimestampVerificationData(timestamp)\n            : undefined,\n    };\n}\nfunction toVerificationMaterialx509CertificateChain(certificates) {\n    return {\n        $case: 'x509CertificateChain',\n        x509CertificateChain: {\n            certificates: certificates.map((c) => ({\n                rawBytes: util_1.pem.toDER(c),\n            })),\n        },\n    };\n}\nfunction toVerificationMaterialPublicKey(hint) {\n    return { $case: 'publicKey', publicKey: { hint } };\n}\nfunction toTimestampVerificationData(timestamp) {\n    return {\n        rfc3161Timestamps: [{ signedTimestamp: timestamp }],\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}