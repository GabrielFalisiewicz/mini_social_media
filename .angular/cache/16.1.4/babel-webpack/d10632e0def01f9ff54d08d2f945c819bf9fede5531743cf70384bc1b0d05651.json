{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst EE = require('events').EventEmitter;\nconst Minimatch = require('minimatch').Minimatch;\nclass Walker extends EE {\n  constructor(opts) {\n    opts = opts || {};\n    super(opts);\n    // set to true if this.path is a symlink, whether follow is true or not\n    this.isSymbolicLink = opts.isSymbolicLink;\n    this.path = opts.path || process.cwd();\n    this.basename = path.basename(this.path);\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore'];\n    this.ignoreRules = {};\n    this.parent = opts.parent || null;\n    this.includeEmpty = !!opts.includeEmpty;\n    this.root = this.parent ? this.parent.root : this.path;\n    this.follow = !!opts.follow;\n    this.result = this.parent ? this.parent.result : new Set();\n    this.entries = null;\n    this.sawError = false;\n  }\n  sort(a, b) {\n    return a.localeCompare(b, 'en');\n  }\n  emit(ev, data) {\n    let ret = false;\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true;\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data).map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort);\n        this.result = data;\n      }\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data);\n      } else {\n        ret = super.emit(ev, data);\n      }\n    }\n    return ret;\n  }\n  start() {\n    fs.readdir(this.path, (er, entries) => er ? this.emit('error', er) : this.onReaddir(entries));\n    return this;\n  }\n  isIgnoreFile(e) {\n    return e !== '.' && e !== '..' && this.ignoreFiles.indexOf(e) !== -1;\n  }\n  onReaddir(entries) {\n    this.entries = entries;\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.slice(this.root.length + 1));\n      }\n      this.emit('done', this.result);\n    } else {\n      const hasIg = this.entries.some(e => this.isIgnoreFile(e));\n      if (hasIg) {\n        this.addIgnoreFiles();\n      } else {\n        this.filterEntries();\n      }\n    }\n  }\n  addIgnoreFiles() {\n    const newIg = this.entries.filter(e => this.isIgnoreFile(e));\n    let igCount = newIg.length;\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries();\n      }\n    };\n    newIg.forEach(e => this.addIgnoreFile(e, then));\n  }\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    fs.readFile(ig, 'utf8', (er, data) => er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then));\n  }\n  onReadIgnoreFile(file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true\n    };\n    const rules = data.split(/\\r?\\n/).filter(line => !/^#|^$/.test(line.trim())).map(rule => {\n      return new Minimatch(rule.trim(), mmopt);\n    });\n    this.ignoreRules[file] = rules;\n    then();\n  }\n  filterEntries() {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry);\n      const passDir = this.filterEntry(entry, true);\n      return passFile || passDir ? [entry, passFile, passDir] : false;\n    }).filter(e => e);\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length;\n    if (entryCount === 0) {\n      this.emit('done', this.result);\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result);\n        }\n      };\n      filtered.forEach(filt => {\n        const entry = filt[0];\n        const file = filt[1];\n        const dir = filt[2];\n        this.stat({\n          entry,\n          file,\n          dir\n        }, then);\n      });\n    }\n  }\n  onstat({\n    st,\n    entry,\n    file,\n    dir,\n    isSymbolicLink\n  }, then) {\n    const abs = this.path + '/' + entry;\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.slice(this.root.length + 1));\n      }\n      then();\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, {\n          isSymbolicLink\n        }, then);\n      } else {\n        then();\n      }\n    }\n  }\n  stat({\n    entry,\n    file,\n    dir\n  }, then) {\n    const abs = this.path + '/' + entry;\n    fs.lstat(abs, (lstatErr, lstatResult) => {\n      if (lstatErr) {\n        this.emit('error', lstatErr);\n      } else {\n        const isSymbolicLink = lstatResult.isSymbolicLink();\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (statErr, statResult) => {\n            if (statErr) {\n              this.emit('error', statErr);\n            } else {\n              this.onstat({\n                st: statResult,\n                entry,\n                file,\n                dir,\n                isSymbolicLink\n              }, then);\n            }\n          });\n        } else {\n          this.onstat({\n            st: lstatResult,\n            entry,\n            file,\n            dir,\n            isSymbolicLink\n          }, then);\n        }\n      }\n    });\n  }\n  walkerOpt(entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts\n    };\n  }\n  walker(entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start();\n  }\n  filterEntry(entry, partial) {\n    let included = true;\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + '/' + entry;\n      included = this.parent.filterEntry(pt, partial);\n    }\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) || rule.match(entry) || !!partial && (rule.match('/' + entry + '/') || rule.match(entry + '/')) || !!partial && rule.negate && (rule.match('/' + entry, true) || rule.match(entry, true));\n            if (match) {\n              included = rule.negate;\n            }\n          }\n        });\n      }\n    });\n    return included;\n  }\n}\nclass WalkerSync extends Walker {\n  start() {\n    this.onReaddir(fs.readdirSync(this.path));\n    return this;\n  }\n  addIgnoreFile(file, then) {\n    const ig = path.resolve(this.path, file);\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then);\n  }\n  stat({\n    entry,\n    file,\n    dir\n  }, then) {\n    const abs = this.path + '/' + entry;\n    let st = fs.lstatSync(abs);\n    const isSymbolicLink = st.isSymbolicLink();\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs);\n    }\n\n    // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n    this.onstat({\n      st,\n      entry,\n      file,\n      dir,\n      isSymbolicLink\n    }, then);\n  }\n  walker(entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start();\n    then();\n  }\n}\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start();\n  });\n  return callback ? p.then(res => callback(null, res), callback) : p;\n};\nconst walkSync = opts => new WalkerSync(opts).start().result;\nmodule.exports = walk;\nwalk.sync = walkSync;\nwalk.Walker = Walker;\nwalk.WalkerSync = WalkerSync;","map":{"version":3,"names":["fs","require","path","EE","EventEmitter","Minimatch","Walker","constructor","opts","isSymbolicLink","process","cwd","basename","ignoreFiles","ignoreRules","parent","includeEmpty","root","follow","result","Set","entries","sawError","sort","a","b","localeCompare","emit","ev","data","ret","Array","from","map","e","test","start","readdir","er","onReaddir","isIgnoreFile","indexOf","length","add","slice","hasIg","some","addIgnoreFiles","filterEntries","newIg","filter","igCount","then","_","forEach","addIgnoreFile","file","ig","resolve","readFile","onReadIgnoreFile","mmopt","matchBase","dot","flipNegate","nocase","rules","split","line","trim","rule","filtered","entry","passFile","filterEntry","passDir","entryCount","filt","dir","stat","onstat","st","abs","isDirectory","walker","lstat","lstatErr","lstatResult","statErr","statResult","walkerOpt","on","partial","included","pt","f","negate","match","WalkerSync","readdirSync","readFileSync","lstatSync","statSync","walk","callback","p","Promise","reject","res","walkSync","module","exports","sync"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/ignore-walk/lib/index.js"],"sourcesContent":["'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst EE = require('events').EventEmitter\nconst Minimatch = require('minimatch').Minimatch\n\nclass Walker extends EE {\n  constructor (opts) {\n    opts = opts || {}\n    super(opts)\n    // set to true if this.path is a symlink, whether follow is true or not\n    this.isSymbolicLink = opts.isSymbolicLink\n    this.path = opts.path || process.cwd()\n    this.basename = path.basename(this.path)\n    this.ignoreFiles = opts.ignoreFiles || ['.ignore']\n    this.ignoreRules = {}\n    this.parent = opts.parent || null\n    this.includeEmpty = !!opts.includeEmpty\n    this.root = this.parent ? this.parent.root : this.path\n    this.follow = !!opts.follow\n    this.result = this.parent ? this.parent.result : new Set()\n    this.entries = null\n    this.sawError = false\n  }\n\n  sort (a, b) {\n    return a.localeCompare(b, 'en')\n  }\n\n  emit (ev, data) {\n    let ret = false\n    if (!(this.sawError && ev === 'error')) {\n      if (ev === 'error') {\n        this.sawError = true\n      } else if (ev === 'done' && !this.parent) {\n        data = Array.from(data)\n          .map(e => /^@/.test(e) ? `./${e}` : e).sort(this.sort)\n        this.result = data\n      }\n\n      if (ev === 'error' && this.parent) {\n        ret = this.parent.emit('error', data)\n      } else {\n        ret = super.emit(ev, data)\n      }\n    }\n    return ret\n  }\n\n  start () {\n    fs.readdir(this.path, (er, entries) =>\n      er ? this.emit('error', er) : this.onReaddir(entries))\n    return this\n  }\n\n  isIgnoreFile (e) {\n    return e !== '.' &&\n      e !== '..' &&\n      this.ignoreFiles.indexOf(e) !== -1\n  }\n\n  onReaddir (entries) {\n    this.entries = entries\n    if (entries.length === 0) {\n      if (this.includeEmpty) {\n        this.result.add(this.path.slice(this.root.length + 1))\n      }\n      this.emit('done', this.result)\n    } else {\n      const hasIg = this.entries.some(e =>\n        this.isIgnoreFile(e))\n\n      if (hasIg) {\n        this.addIgnoreFiles()\n      } else {\n        this.filterEntries()\n      }\n    }\n  }\n\n  addIgnoreFiles () {\n    const newIg = this.entries\n      .filter(e => this.isIgnoreFile(e))\n\n    let igCount = newIg.length\n    const then = _ => {\n      if (--igCount === 0) {\n        this.filterEntries()\n      }\n    }\n\n    newIg.forEach(e => this.addIgnoreFile(e, then))\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    fs.readFile(ig, 'utf8', (er, data) =>\n      er ? this.emit('error', er) : this.onReadIgnoreFile(file, data, then))\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    const mmopt = {\n      matchBase: true,\n      dot: true,\n      flipNegate: true,\n      nocase: true,\n    }\n    const rules = data.split(/\\r?\\n/)\n      .filter(line => !/^#|^$/.test(line.trim()))\n      .map(rule => {\n        return new Minimatch(rule.trim(), mmopt)\n      })\n\n    this.ignoreRules[file] = rules\n\n    then()\n  }\n\n  filterEntries () {\n    // at this point we either have ignore rules, or just inheriting\n    // this exclusion is at the point where we know the list of\n    // entries in the dir, but don't know what they are.  since\n    // some of them *might* be directories, we have to run the\n    // match in dir-mode as well, so that we'll pick up partials\n    // of files that will be included later.  Anything included\n    // at this point will be checked again later once we know\n    // what it is.\n    const filtered = this.entries.map(entry => {\n      // at this point, we don't know if it's a dir or not.\n      const passFile = this.filterEntry(entry)\n      const passDir = this.filterEntry(entry, true)\n      return (passFile || passDir) ? [entry, passFile, passDir] : false\n    }).filter(e => e)\n\n    // now we stat them all\n    // if it's a dir, and passes as a dir, then recurse\n    // if it's not a dir, but passes as a file, add to set\n    let entryCount = filtered.length\n    if (entryCount === 0) {\n      this.emit('done', this.result)\n    } else {\n      const then = _ => {\n        if (--entryCount === 0) {\n          this.emit('done', this.result)\n        }\n      }\n      filtered.forEach(filt => {\n        const entry = filt[0]\n        const file = filt[1]\n        const dir = filt[2]\n        this.stat({ entry, file, dir }, then)\n      })\n    }\n  }\n\n  onstat ({ st, entry, file, dir, isSymbolicLink }, then) {\n    const abs = this.path + '/' + entry\n    if (!st.isDirectory()) {\n      if (file) {\n        this.result.add(abs.slice(this.root.length + 1))\n      }\n      then()\n    } else {\n      // is a directory\n      if (dir) {\n        this.walker(entry, { isSymbolicLink }, then)\n      } else {\n        then()\n      }\n    }\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    fs.lstat(abs, (lstatErr, lstatResult) => {\n      if (lstatErr) {\n        this.emit('error', lstatErr)\n      } else {\n        const isSymbolicLink = lstatResult.isSymbolicLink()\n        if (this.follow && isSymbolicLink) {\n          fs.stat(abs, (statErr, statResult) => {\n            if (statErr) {\n              this.emit('error', statErr)\n            } else {\n              this.onstat({ st: statResult, entry, file, dir, isSymbolicLink }, then)\n            }\n          })\n        } else {\n          this.onstat({ st: lstatResult, entry, file, dir, isSymbolicLink }, then)\n        }\n      }\n    })\n  }\n\n  walkerOpt (entry, opts) {\n    return {\n      path: this.path + '/' + entry,\n      parent: this,\n      ignoreFiles: this.ignoreFiles,\n      follow: this.follow,\n      includeEmpty: this.includeEmpty,\n      ...opts,\n    }\n  }\n\n  walker (entry, opts, then) {\n    new Walker(this.walkerOpt(entry, opts)).on('done', then).start()\n  }\n\n  filterEntry (entry, partial) {\n    let included = true\n\n    // this = /a/b/c\n    // entry = d\n    // parent /a/b sees c/d\n    if (this.parent && this.parent.filterEntry) {\n      var pt = this.basename + '/' + entry\n      included = this.parent.filterEntry(pt, partial)\n    }\n\n    this.ignoreFiles.forEach(f => {\n      if (this.ignoreRules[f]) {\n        this.ignoreRules[f].forEach(rule => {\n          // negation means inclusion\n          // so if it's negated, and already included, no need to check\n          // likewise if it's neither negated nor included\n          if (rule.negate !== included) {\n            // first, match against /foo/bar\n            // then, against foo/bar\n            // then, in the case of partials, match with a /\n            const match = rule.match('/' + entry) ||\n              rule.match(entry) ||\n              (!!partial && (\n                rule.match('/' + entry + '/') ||\n                rule.match(entry + '/'))) ||\n              (!!partial && rule.negate && (\n                rule.match('/' + entry, true) ||\n                rule.match(entry, true)))\n\n            if (match) {\n              included = rule.negate\n            }\n          }\n        })\n      }\n    })\n\n    return included\n  }\n}\n\nclass WalkerSync extends Walker {\n  start () {\n    this.onReaddir(fs.readdirSync(this.path))\n    return this\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    this.onReadIgnoreFile(file, fs.readFileSync(ig, 'utf8'), then)\n  }\n\n  stat ({ entry, file, dir }, then) {\n    const abs = this.path + '/' + entry\n    let st = fs.lstatSync(abs)\n    const isSymbolicLink = st.isSymbolicLink()\n    if (this.follow && isSymbolicLink) {\n      st = fs.statSync(abs)\n    }\n\n    // console.error('STAT SYNC', {st, entry, file, dir, isSymbolicLink, then})\n    this.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n  }\n\n  walker (entry, opts, then) {\n    new WalkerSync(this.walkerOpt(entry, opts)).start()\n    then()\n  }\n}\n\nconst walk = (opts, callback) => {\n  const p = new Promise((resolve, reject) => {\n    new Walker(opts).on('done', resolve).on('error', reject).start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = opts => new WalkerSync(opts).start().result\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}