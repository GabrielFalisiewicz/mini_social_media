{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignedCertificateTimestamp = void 0;\nconst util_1 = require(\"../util\");\nconst stream_1 = require(\"../util/stream\");\nclass SignedCertificateTimestamp {\n  constructor(options) {\n    this.version = options.version;\n    this.logID = options.logID;\n    this.timestamp = options.timestamp;\n    this.extensions = options.extensions;\n    this.hashAlgorithm = options.hashAlgorithm;\n    this.signatureAlgorithm = options.signatureAlgorithm;\n    this.signature = options.signature;\n  }\n  get datetime() {\n    return new Date(Number(this.timestamp.readBigInt64BE()));\n  }\n  // Returns the hash algorithm used to generate the SCT's signature.\n  // https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.4.1\n  get algorithm() {\n    switch (this.hashAlgorithm) {\n      case 0:\n        return 'none';\n      case 1:\n        return 'md5';\n      case 2:\n        return 'sha1';\n      case 3:\n        return 'sha224';\n      case 4:\n        return 'sha256';\n      case 5:\n        return 'sha384';\n      case 6:\n        return 'sha512';\n      default:\n        return 'unknown';\n    }\n  }\n  verify(preCert, logs) {\n    // Find key for the log reponsible for this signature\n    const log = logs.find(log => log.logId?.keyId.equals(this.logID));\n    if (!log?.publicKey?.rawBytes) {\n      throw new Error(`No key found for log: ${this.logID.toString('base64')}`);\n    }\n    const publicKey = util_1.crypto.createPublicKey(log.publicKey.rawBytes);\n    // Assemble the digitally-signed struct (the data over which the signature\n    // was generated).\n    // https://www.rfc-editor.org/rfc/rfc6962#section-3.2\n    const stream = new stream_1.ByteStream();\n    stream.appendChar(this.version);\n    stream.appendChar(0x00); // SignatureType = certificate_timestamp(0)\n    stream.appendView(this.timestamp);\n    stream.appendUint16(0x01); // LogEntryType = precert_entry(1)\n    stream.appendView(preCert);\n    stream.appendUint16(this.extensions.byteLength);\n    if (this.extensions.byteLength > 0) {\n      stream.appendView(this.extensions);\n    }\n    return util_1.crypto.verifyBlob(stream.buffer, publicKey, this.signature, this.algorithm);\n  }\n  // Parses a SignedCertificateTimestamp from a buffer. SCTs are encoded using\n  // TLS encoding which means the fields and lengths of most fields are\n  // specified as part of the SCT and TLS specs.\n  // https://www.rfc-editor.org/rfc/rfc6962#section-3.2\n  // https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.4.1\n  static parse(buf) {\n    const stream = new stream_1.ByteStream(buf);\n    // Version - enum { v1(0), (255) }\n    const version = stream.getUint8();\n    // Log ID  - struct { opaque key_id[32]; }\n    const logID = stream.getBlock(32);\n    // Timestamp - uint64\n    const timestamp = stream.getBlock(8);\n    // Extensions - opaque extensions<0..2^16-1>;\n    const extenstionLength = stream.getUint16();\n    const extensions = stream.getBlock(extenstionLength);\n    // Hash algo - enum { sha256(4), . . . (255) }\n    const hashAlgorithm = stream.getUint8();\n    // Signature algo - enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }\n    const signatureAlgorithm = stream.getUint8();\n    // Signature  - opaque signature<0..2^16-1>;\n    const sigLength = stream.getUint16();\n    const signature = stream.getBlock(sigLength);\n    // Check that we read the entire buffer\n    if (stream.position !== buf.length) {\n      throw new Error('SCT buffer length mismatch');\n    }\n    return new SignedCertificateTimestamp({\n      version,\n      logID,\n      timestamp,\n      extensions,\n      hashAlgorithm,\n      signatureAlgorithm,\n      signature\n    });\n  }\n}\nexports.SignedCertificateTimestamp = SignedCertificateTimestamp;","map":{"version":3,"names":["Object","defineProperty","exports","value","SignedCertificateTimestamp","util_1","require","stream_1","constructor","options","version","logID","timestamp","extensions","hashAlgorithm","signatureAlgorithm","signature","datetime","Date","Number","readBigInt64BE","algorithm","verify","preCert","logs","log","find","logId","keyId","equals","publicKey","rawBytes","Error","toString","crypto","createPublicKey","stream","ByteStream","appendChar","appendView","appendUint16","byteLength","verifyBlob","buffer","parse","buf","getUint8","getBlock","extenstionLength","getUint16","sigLength","position","length"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/x509/sct.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SignedCertificateTimestamp = void 0;\nconst util_1 = require(\"../util\");\nconst stream_1 = require(\"../util/stream\");\nclass SignedCertificateTimestamp {\n    constructor(options) {\n        this.version = options.version;\n        this.logID = options.logID;\n        this.timestamp = options.timestamp;\n        this.extensions = options.extensions;\n        this.hashAlgorithm = options.hashAlgorithm;\n        this.signatureAlgorithm = options.signatureAlgorithm;\n        this.signature = options.signature;\n    }\n    get datetime() {\n        return new Date(Number(this.timestamp.readBigInt64BE()));\n    }\n    // Returns the hash algorithm used to generate the SCT's signature.\n    // https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.4.1\n    get algorithm() {\n        switch (this.hashAlgorithm) {\n            case 0:\n                return 'none';\n            case 1:\n                return 'md5';\n            case 2:\n                return 'sha1';\n            case 3:\n                return 'sha224';\n            case 4:\n                return 'sha256';\n            case 5:\n                return 'sha384';\n            case 6:\n                return 'sha512';\n            default:\n                return 'unknown';\n        }\n    }\n    verify(preCert, logs) {\n        // Find key for the log reponsible for this signature\n        const log = logs.find((log) => log.logId?.keyId.equals(this.logID));\n        if (!log?.publicKey?.rawBytes) {\n            throw new Error(`No key found for log: ${this.logID.toString('base64')}`);\n        }\n        const publicKey = util_1.crypto.createPublicKey(log.publicKey.rawBytes);\n        // Assemble the digitally-signed struct (the data over which the signature\n        // was generated).\n        // https://www.rfc-editor.org/rfc/rfc6962#section-3.2\n        const stream = new stream_1.ByteStream();\n        stream.appendChar(this.version);\n        stream.appendChar(0x00); // SignatureType = certificate_timestamp(0)\n        stream.appendView(this.timestamp);\n        stream.appendUint16(0x01); // LogEntryType = precert_entry(1)\n        stream.appendView(preCert);\n        stream.appendUint16(this.extensions.byteLength);\n        if (this.extensions.byteLength > 0) {\n            stream.appendView(this.extensions);\n        }\n        return util_1.crypto.verifyBlob(stream.buffer, publicKey, this.signature, this.algorithm);\n    }\n    // Parses a SignedCertificateTimestamp from a buffer. SCTs are encoded using\n    // TLS encoding which means the fields and lengths of most fields are\n    // specified as part of the SCT and TLS specs.\n    // https://www.rfc-editor.org/rfc/rfc6962#section-3.2\n    // https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.4.1\n    static parse(buf) {\n        const stream = new stream_1.ByteStream(buf);\n        // Version - enum { v1(0), (255) }\n        const version = stream.getUint8();\n        // Log ID  - struct { opaque key_id[32]; }\n        const logID = stream.getBlock(32);\n        // Timestamp - uint64\n        const timestamp = stream.getBlock(8);\n        // Extensions - opaque extensions<0..2^16-1>;\n        const extenstionLength = stream.getUint16();\n        const extensions = stream.getBlock(extenstionLength);\n        // Hash algo - enum { sha256(4), . . . (255) }\n        const hashAlgorithm = stream.getUint8();\n        // Signature algo - enum { anonymous(0), rsa(1), dsa(2), ecdsa(3), (255) }\n        const signatureAlgorithm = stream.getUint8();\n        // Signature  - opaque signature<0..2^16-1>;\n        const sigLength = stream.getUint16();\n        const signature = stream.getBlock(sigLength);\n        // Check that we read the entire buffer\n        if (stream.position !== buf.length) {\n            throw new Error('SCT buffer length mismatch');\n        }\n        return new SignedCertificateTimestamp({\n            version,\n            logID,\n            timestamp,\n            extensions,\n            hashAlgorithm,\n            signatureAlgorithm,\n            signature,\n        });\n    }\n}\nexports.SignedCertificateTimestamp = SignedCertificateTimestamp;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}