{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classPrivateMethodInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldSet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nlet _Symbol$asyncIterator, _Symbol$iterator;\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = require(\"lru-cache\");\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst actualFS = __importStar(require(\"fs\"));\nconst fs_1 = require(\"fs\");\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = require(\"fs/promises\");\nconst minipass_1 = require(\"minipass\");\nconst defaultFS = {\n  lstatSync: fs_1.lstatSync,\n  readdir: fs_1.readdir,\n  readdirSync: fs_1.readdirSync,\n  readlinkSync: fs_1.readlinkSync,\n  realpathSync,\n  promises: {\n    lstat: promises_1.lstat,\n    readdir: promises_1.readdir,\n    readlink: promises_1.readlink,\n    realpath: promises_1.realpath\n  }\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = fsOption => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {\n  ...defaultFS,\n  ...fsOption,\n  promises: {\n    ...defaultFS.promises,\n    ...(fsOption.promises || {})\n  }\n};\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = rootPath => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 16;\n// set after a successful lstat()\nconst LSTAT_CALLED = 32;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 64;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 128;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 256;\n// set if we know realpath() will fail\nconst ENOREALPATH = 512;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 1023;\nconst entToType = s => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = s => {\n  const c = normalizeCache.get(s);\n  if (c) return c;\n  const n = s.normalize('NFKD');\n  normalizeCache.set(s, n);\n  return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = s => {\n  const c = normalizeNocaseCache.get(s);\n  if (c) return c;\n  const n = normalize(s.toLowerCase());\n  normalizeNocaseCache.set(s, n);\n  return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache_1.LRUCache {\n  constructor() {\n    super({\n      max: 256\n    });\n  }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache_1.LRUCache {\n  constructor(maxSize = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1\n    });\n  }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nvar _fs = /*#__PURE__*/new WeakMap();\nvar _dev = /*#__PURE__*/new WeakMap();\nvar _mode = /*#__PURE__*/new WeakMap();\nvar _nlink = /*#__PURE__*/new WeakMap();\nvar _uid = /*#__PURE__*/new WeakMap();\nvar _gid = /*#__PURE__*/new WeakMap();\nvar _rdev = /*#__PURE__*/new WeakMap();\nvar _blksize = /*#__PURE__*/new WeakMap();\nvar _ino = /*#__PURE__*/new WeakMap();\nvar _size = /*#__PURE__*/new WeakMap();\nvar _blocks = /*#__PURE__*/new WeakMap();\nvar _atimeMs = /*#__PURE__*/new WeakMap();\nvar _mtimeMs = /*#__PURE__*/new WeakMap();\nvar _ctimeMs = /*#__PURE__*/new WeakMap();\nvar _birthtimeMs = /*#__PURE__*/new WeakMap();\nvar _atime = /*#__PURE__*/new WeakMap();\nvar _mtime = /*#__PURE__*/new WeakMap();\nvar _ctime = /*#__PURE__*/new WeakMap();\nvar _birthtime = /*#__PURE__*/new WeakMap();\nvar _matchName = /*#__PURE__*/new WeakMap();\nvar _depth = /*#__PURE__*/new WeakMap();\nvar _fullpath = /*#__PURE__*/new WeakMap();\nvar _fullpathPosix = /*#__PURE__*/new WeakMap();\nvar _relative = /*#__PURE__*/new WeakMap();\nvar _relativePosix = /*#__PURE__*/new WeakMap();\nvar _type = /*#__PURE__*/new WeakMap();\nvar _children = /*#__PURE__*/new WeakMap();\nvar _linkTarget = /*#__PURE__*/new WeakMap();\nvar _realpath = /*#__PURE__*/new WeakMap();\nvar _resolveParts = /*#__PURE__*/new WeakSet();\nvar _readdirSuccess = /*#__PURE__*/new WeakSet();\nvar _markENOENT = /*#__PURE__*/new WeakSet();\nvar _markChildrenENOENT = /*#__PURE__*/new WeakSet();\nvar _markENOREALPATH = /*#__PURE__*/new WeakSet();\nvar _markENOTDIR = /*#__PURE__*/new WeakSet();\nvar _readdirFail = /*#__PURE__*/new WeakSet();\nvar _lstatFail = /*#__PURE__*/new WeakSet();\nvar _readlinkFail = /*#__PURE__*/new WeakSet();\nvar _readdirAddChild = /*#__PURE__*/new WeakSet();\nvar _readdirAddNewChild = /*#__PURE__*/new WeakSet();\nvar _readdirMaybePromoteChild = /*#__PURE__*/new WeakSet();\nvar _readdirPromoteChild = /*#__PURE__*/new WeakSet();\nvar _applyStat = /*#__PURE__*/new WeakSet();\nvar _onReaddirCB = /*#__PURE__*/new WeakMap();\nvar _readdirCBInFlight = /*#__PURE__*/new WeakMap();\nvar _callOnReaddirCB = /*#__PURE__*/new WeakSet();\nvar _asyncReaddirInFlight = /*#__PURE__*/new WeakMap();\nclass PathBase {\n  get dev() {\n    return _classPrivateFieldGet(this, _dev);\n  }\n  get mode() {\n    return _classPrivateFieldGet(this, _mode);\n  }\n  get nlink() {\n    return _classPrivateFieldGet(this, _nlink);\n  }\n  get uid() {\n    return _classPrivateFieldGet(this, _uid);\n  }\n  get gid() {\n    return _classPrivateFieldGet(this, _gid);\n  }\n  get rdev() {\n    return _classPrivateFieldGet(this, _rdev);\n  }\n  get blksize() {\n    return _classPrivateFieldGet(this, _blksize);\n  }\n  get ino() {\n    return _classPrivateFieldGet(this, _ino);\n  }\n  get size() {\n    return _classPrivateFieldGet(this, _size);\n  }\n  get blocks() {\n    return _classPrivateFieldGet(this, _blocks);\n  }\n  get atimeMs() {\n    return _classPrivateFieldGet(this, _atimeMs);\n  }\n  get mtimeMs() {\n    return _classPrivateFieldGet(this, _mtimeMs);\n  }\n  get ctimeMs() {\n    return _classPrivateFieldGet(this, _ctimeMs);\n  }\n  get birthtimeMs() {\n    return _classPrivateFieldGet(this, _birthtimeMs);\n  }\n  get atime() {\n    return _classPrivateFieldGet(this, _atime);\n  }\n  get mtime() {\n    return _classPrivateFieldGet(this, _mtime);\n  }\n  get ctime() {\n    return _classPrivateFieldGet(this, _ctime);\n  }\n  get birthtime() {\n    return _classPrivateFieldGet(this, _birthtime);\n  }\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['path'] refers to the path of the directory\n   * that was passed to readdir.  So, somewhat counterintuitively, this\n   * property refers to the *parent* path, not the path object itself.\n   * For root entries, it's the path to the entry itself.\n   */\n  get path() {\n    return (this.parent || this).fullpath();\n  }\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(_name, _type2 = UNKNOWN, root, roots, nocase, _children2, opts) {\n    _classPrivateMethodInitSpec(this, _callOnReaddirCB);\n    _classPrivateMethodInitSpec(this, _applyStat);\n    _classPrivateMethodInitSpec(this, _readdirPromoteChild);\n    _classPrivateMethodInitSpec(this, _readdirMaybePromoteChild);\n    _classPrivateMethodInitSpec(this, _readdirAddNewChild);\n    _classPrivateMethodInitSpec(this, _readdirAddChild);\n    _classPrivateMethodInitSpec(this, _readlinkFail);\n    _classPrivateMethodInitSpec(this, _lstatFail);\n    _classPrivateMethodInitSpec(this, _readdirFail);\n    // save the information when we know the entry is not a dir\n    _classPrivateMethodInitSpec(this, _markENOTDIR);\n    _classPrivateMethodInitSpec(this, _markENOREALPATH);\n    _classPrivateMethodInitSpec(this, _markChildrenENOENT);\n    _classPrivateMethodInitSpec(this, _markENOENT);\n    _classPrivateMethodInitSpec(this, _readdirSuccess);\n    _classPrivateMethodInitSpec(this, _resolveParts);\n    /**\n     * the basename of this path\n     *\n     * **Important**: *always* test the path name against any test string\n     * usingthe {@link isNamed} method, and not by directly comparing this\n     * string. Otherwise, unicode path strings that the system sees as identical\n     * will not be properly treated as the same path, leading to incorrect\n     * behavior and possible security issues.\n     */\n    _defineProperty(this, \"name\", void 0);\n    /**\n     * the Path entry corresponding to the path root.\n     *\n     * @internal\n     */\n    _defineProperty(this, \"root\", void 0);\n    /**\n     * All roots found within the current PathScurry family\n     *\n     * @internal\n     */\n    _defineProperty(this, \"roots\", void 0);\n    /**\n     * a reference to the parent path, or undefined in the case of root entries\n     *\n     * @internal\n     */\n    _defineProperty(this, \"parent\", void 0);\n    /**\n     * boolean indicating whether paths are compared case-insensitively\n     * @internal\n     */\n    _defineProperty(this, \"nocase\", void 0);\n    // potential default fs override\n    _classPrivateFieldInitSpec(this, _fs, {\n      writable: true,\n      value: void 0\n    });\n    // Stats fields\n    _classPrivateFieldInitSpec(this, _dev, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _mode, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _nlink, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _uid, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _gid, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _rdev, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _blksize, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _ino, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _size, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _blocks, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _atimeMs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _mtimeMs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _ctimeMs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _birthtimeMs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _atime, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _mtime, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _ctime, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _birthtime, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _matchName, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _depth, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fullpath, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fullpathPosix, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _relative, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _relativePosix, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _children, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _linkTarget, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _realpath, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _onReaddirCB, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _readdirCBInFlight, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(this, _asyncReaddirInFlight, {\n      writable: true,\n      value: void 0\n    });\n    this.name = _name;\n    _classPrivateFieldSet(this, _matchName, nocase ? normalizeNocase(_name) : normalize(_name));\n    _classPrivateFieldSet(this, _type, _type2 & TYPEMASK);\n    this.nocase = nocase;\n    this.roots = roots;\n    this.root = root || this;\n    _classPrivateFieldSet(this, _children, _children2);\n    _classPrivateFieldSet(this, _fullpath, opts.fullpath);\n    _classPrivateFieldSet(this, _relative, opts.relative);\n    _classPrivateFieldSet(this, _relativePosix, opts.relativePosix);\n    this.parent = opts.parent;\n    if (this.parent) {\n      _classPrivateFieldSet(this, _fs, _classPrivateFieldGet(this.parent, _fs));\n    } else {\n      _classPrivateFieldSet(this, _fs, fsFromOption(opts.fs));\n    }\n  }\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth() {\n    if (_classPrivateFieldGet(this, _depth) !== undefined) return _classPrivateFieldGet(this, _depth);\n    if (!this.parent) return _classPrivateFieldSet(this, _depth, 0);\n    return _classPrivateFieldSet(this, _depth, this.parent.depth() + 1);\n  }\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return _classPrivateFieldGet(this, _children);\n  }\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path) {\n    var _this$getRoot;\n    if (!path) {\n      return this;\n    }\n    const rootPath = this.getRootString(path);\n    const dir = path.substring(rootPath.length);\n    const dirParts = dir.split(this.splitSep);\n    const result = rootPath ? _classPrivateMethodGet(_this$getRoot = this.getRoot(rootPath), _resolveParts, _resolveParts2).call(_this$getRoot, dirParts) : _classPrivateMethodGet(this, _resolveParts, _resolveParts2).call(this, dirParts);\n    return result;\n  }\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children() {\n    const cached = _classPrivateFieldGet(this, _children).get(this);\n    if (cached) {\n      return cached;\n    }\n    const children = Object.assign([], {\n      provisional: 0\n    });\n    _classPrivateFieldGet(this, _children).set(this, children);\n    _classPrivateFieldSet(this, _type, _classPrivateFieldGet(this, _type) & ~READDIR_CALLED);\n    return children;\n  }\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart, opts) {\n    if (pathPart === '' || pathPart === '.') {\n      return this;\n    }\n    if (pathPart === '..') {\n      return this.parent || this;\n    }\n    // find the child\n    const children = this.children();\n    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n    for (const p of children) {\n      if (_classPrivateFieldGet(p, _matchName) === name) {\n        return p;\n      }\n    }\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : '';\n    const fullpath = _classPrivateFieldGet(this, _fullpath) ? _classPrivateFieldGet(this, _fullpath) + s + pathPart : undefined;\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath\n    });\n    if (!this.canReaddir()) {\n      _classPrivateFieldSet(pchild, _type, _classPrivateFieldGet(pchild, _type) | ENOENT);\n    }\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild);\n    return pchild;\n  }\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative() {\n    if (_classPrivateFieldGet(this, _relative) !== undefined) {\n      return _classPrivateFieldGet(this, _relative);\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return _classPrivateFieldSet(this, _relative, this.name);\n    }\n    const pv = p.relative();\n    return pv + (!pv || !p.parent ? '' : this.sep) + name;\n  }\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix() {\n    if (this.sep === '/') return this.relative();\n    if (_classPrivateFieldGet(this, _relativePosix) !== undefined) return _classPrivateFieldGet(this, _relativePosix);\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return _classPrivateFieldSet(this, _relativePosix, this.fullpathPosix());\n    }\n    const pv = p.relativePosix();\n    return pv + (!pv || !p.parent ? '' : '/') + name;\n  }\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath() {\n    if (_classPrivateFieldGet(this, _fullpath) !== undefined) {\n      return _classPrivateFieldGet(this, _fullpath);\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return _classPrivateFieldSet(this, _fullpath, this.name);\n    }\n    const pv = p.fullpath();\n    const fp = pv + (!p.parent ? '' : this.sep) + name;\n    return _classPrivateFieldSet(this, _fullpath, fp);\n  }\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix() {\n    if (_classPrivateFieldGet(this, _fullpathPosix) !== undefined) return _classPrivateFieldGet(this, _fullpathPosix);\n    if (this.sep === '/') return _classPrivateFieldSet(this, _fullpathPosix, this.fullpath());\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/');\n      if (/^[a-z]:\\//i.test(p)) {\n        return _classPrivateFieldSet(this, _fullpathPosix, `//?/${p}`);\n      } else {\n        return _classPrivateFieldSet(this, _fullpathPosix, p);\n      }\n    }\n    const p = this.parent;\n    const pfpp = p.fullpathPosix();\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n    return _classPrivateFieldSet(this, _fullpathPosix, fpp);\n  }\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown() {\n    return (_classPrivateFieldGet(this, _type) & IFMT) === UNKNOWN;\n  }\n  isType(type) {\n    return this[`is${type}`]();\n  }\n  getType() {\n    return this.isUnknown() ? 'Unknown' : this.isDirectory() ? 'Directory' : this.isFile() ? 'File' : this.isSymbolicLink() ? 'SymbolicLink' : this.isFIFO() ? 'FIFO' : this.isCharacterDevice() ? 'CharacterDevice' : this.isBlockDevice() ? 'BlockDevice' : /* c8 ignore start */this.isSocket() ? 'Socket' : 'Unknown';\n    /* c8 ignore stop */\n  }\n  /**\n   * Is the Path a regular file?\n   */\n  isFile() {\n    return (_classPrivateFieldGet(this, _type) & IFMT) === IFREG;\n  }\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory() {\n    return (_classPrivateFieldGet(this, _type) & IFMT) === IFDIR;\n  }\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice() {\n    return (_classPrivateFieldGet(this, _type) & IFMT) === IFCHR;\n  }\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice() {\n    return (_classPrivateFieldGet(this, _type) & IFMT) === IFBLK;\n  }\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO() {\n    return (_classPrivateFieldGet(this, _type) & IFMT) === IFIFO;\n  }\n  /**\n   * Is the path a socket?\n   */\n  isSocket() {\n    return (_classPrivateFieldGet(this, _type) & IFMT) === IFSOCK;\n  }\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink() {\n    return (_classPrivateFieldGet(this, _type) & IFLNK) === IFLNK;\n  }\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached() {\n    return _classPrivateFieldGet(this, _type) & LSTAT_CALLED ? this : undefined;\n  }\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached() {\n    return _classPrivateFieldGet(this, _linkTarget);\n  }\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached() {\n    return _classPrivateFieldGet(this, _realpath);\n  }\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached() {\n    const children = this.children();\n    return children.slice(0, children.provisional);\n  }\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink() {\n    if (_classPrivateFieldGet(this, _linkTarget)) return true;\n    if (!this.parent) return false;\n    // cases where it cannot possibly succeed\n    const ifmt = _classPrivateFieldGet(this, _type) & IFMT;\n    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || _classPrivateFieldGet(this, _type) & ENOREADLINK || _classPrivateFieldGet(this, _type) & ENOENT);\n  }\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir() {\n    return !!(_classPrivateFieldGet(this, _type) & READDIR_CALLED);\n  }\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT() {\n    return !!(_classPrivateFieldGet(this, _type) & ENOENT);\n  }\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n) {\n    return !this.nocase ? _classPrivateFieldGet(this, _matchName) === normalize(n) : _classPrivateFieldGet(this, _matchName) === normalizeNocase(n);\n  }\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  readlink() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const target = _classPrivateFieldGet(_this, _linkTarget);\n      if (target) {\n        return target;\n      }\n      if (!_this.canReadlink()) {\n        return undefined;\n      }\n      /* c8 ignore start */\n      // already covered by the canReadlink test, here for ts grumples\n      if (!_this.parent) {\n        return undefined;\n      }\n      /* c8 ignore stop */\n      try {\n        const read = yield _classPrivateFieldGet(_this, _fs).promises.readlink(_this.fullpath());\n        const linkTarget = _this.parent.resolve(read);\n        if (linkTarget) {\n          return _classPrivateFieldSet(_this, _linkTarget, linkTarget);\n        }\n      } catch (er) {\n        _classPrivateMethodGet(_this, _readlinkFail, _readlinkFail2).call(_this, er.code);\n        return undefined;\n      }\n    })();\n  }\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync() {\n    const target = _classPrivateFieldGet(this, _linkTarget);\n    if (target) {\n      return target;\n    }\n    if (!this.canReadlink()) {\n      return undefined;\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined;\n    }\n    /* c8 ignore stop */\n    try {\n      const read = _classPrivateFieldGet(this, _fs).readlinkSync(this.fullpath());\n      const linkTarget = this.parent.resolve(read);\n      if (linkTarget) {\n        return _classPrivateFieldSet(this, _linkTarget, linkTarget);\n      }\n    } catch (er) {\n      _classPrivateMethodGet(this, _readlinkFail, _readlinkFail2).call(this, er.code);\n      return undefined;\n    }\n  }\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  lstat() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if ((_classPrivateFieldGet(_this2, _type) & ENOENT) === 0) {\n        try {\n          _classPrivateMethodGet(_this2, _applyStat, _applyStat2).call(_this2, yield _classPrivateFieldGet(_this2, _fs).promises.lstat(_this2.fullpath()));\n          return _this2;\n        } catch (er) {\n          _classPrivateMethodGet(_this2, _lstatFail, _lstatFail2).call(_this2, er.code);\n        }\n      }\n    })();\n  }\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync() {\n    if ((_classPrivateFieldGet(this, _type) & ENOENT) === 0) {\n      try {\n        _classPrivateMethodGet(this, _applyStat, _applyStat2).call(this, _classPrivateFieldGet(this, _fs).lstatSync(this.fullpath()));\n        return this;\n      } catch (er) {\n        _classPrivateMethodGet(this, _lstatFail, _lstatFail2).call(this, er.code);\n      }\n    }\n  }\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(cb, allowZalgo = false) {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, []);else queueMicrotask(() => cb(null, []));\n      return;\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional);\n      if (allowZalgo) cb(null, c);else queueMicrotask(() => cb(null, c));\n      return;\n    }\n    // don't have to worry about zalgo at this point.\n    _classPrivateFieldGet(this, _onReaddirCB).push(cb);\n    if (_classPrivateFieldGet(this, _readdirCBInFlight)) {\n      return;\n    }\n    _classPrivateFieldSet(this, _readdirCBInFlight, true);\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    _classPrivateFieldGet(this, _fs).readdir(fullpath, {\n      withFileTypes: true\n    }, (er, entries) => {\n      if (er) {\n        _classPrivateMethodGet(this, _readdirFail, _readdirFail2).call(this, er.code);\n        children.provisional = 0;\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          _classPrivateMethodGet(this, _readdirAddChild, _readdirAddChild2).call(this, e, children);\n        }\n        _classPrivateMethodGet(this, _readdirSuccess, _readdirSuccess2).call(this, children);\n      }\n      _classPrivateMethodGet(this, _callOnReaddirCB, _callOnReaddirCB2).call(this, children.slice(0, children.provisional));\n      return;\n    });\n  }\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  readdir() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.canReaddir()) {\n        return [];\n      }\n      const children = _this3.children();\n      if (_this3.calledReaddir()) {\n        return children.slice(0, children.provisional);\n      }\n      // else read the directory, fill up children\n      // de-provisionalize any provisional children.\n      const fullpath = _this3.fullpath();\n      if (_classPrivateFieldGet(_this3, _asyncReaddirInFlight)) {\n        yield _classPrivateFieldGet(_this3, _asyncReaddirInFlight);\n      } else {\n        /* c8 ignore start */\n        let resolve = () => {};\n        /* c8 ignore stop */\n        _classPrivateFieldSet(_this3, _asyncReaddirInFlight, new Promise(res => resolve = res));\n        try {\n          for (const e of yield _classPrivateFieldGet(_this3, _fs).promises.readdir(fullpath, {\n            withFileTypes: true\n          })) {\n            _classPrivateMethodGet(_this3, _readdirAddChild, _readdirAddChild2).call(_this3, e, children);\n          }\n          _classPrivateMethodGet(_this3, _readdirSuccess, _readdirSuccess2).call(_this3, children);\n        } catch (er) {\n          _classPrivateMethodGet(_this3, _readdirFail, _readdirFail2).call(_this3, er.code);\n          children.provisional = 0;\n        }\n        _classPrivateFieldSet(_this3, _asyncReaddirInFlight, undefined);\n        resolve();\n      }\n      return children.slice(0, children.provisional);\n    })();\n  }\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync() {\n    if (!this.canReaddir()) {\n      return [];\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional);\n    }\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    try {\n      for (const e of _classPrivateFieldGet(this, _fs).readdirSync(fullpath, {\n        withFileTypes: true\n      })) {\n        _classPrivateMethodGet(this, _readdirAddChild, _readdirAddChild2).call(this, e, children);\n      }\n      _classPrivateMethodGet(this, _readdirSuccess, _readdirSuccess2).call(this, children);\n    } catch (er) {\n      _classPrivateMethodGet(this, _readdirFail, _readdirFail2).call(this, er.code);\n      children.provisional = 0;\n    }\n    return children.slice(0, children.provisional);\n  }\n  canReaddir() {\n    if (_classPrivateFieldGet(this, _type) & ENOCHILD) return false;\n    const ifmt = IFMT & _classPrivateFieldGet(this, _type);\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false;\n    }\n    /* c8 ignore stop */\n    return true;\n  }\n  shouldWalk(dirs, walkFilter) {\n    return (_classPrivateFieldGet(this, _type) & IFDIR) === IFDIR && !(_classPrivateFieldGet(this, _type) & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));\n  }\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  realpath() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (_classPrivateFieldGet(_this4, _realpath)) return _classPrivateFieldGet(_this4, _realpath);\n      if ((ENOREALPATH | ENOREADLINK | ENOENT) & _classPrivateFieldGet(_this4, _type)) return undefined;\n      try {\n        const rp = yield _classPrivateFieldGet(_this4, _fs).promises.realpath(_this4.fullpath());\n        return _classPrivateFieldSet(_this4, _realpath, _this4.resolve(rp));\n      } catch (_) {\n        _classPrivateMethodGet(_this4, _markENOREALPATH, _markENOREALPATH2).call(_this4);\n      }\n    })();\n  }\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync() {\n    if (_classPrivateFieldGet(this, _realpath)) return _classPrivateFieldGet(this, _realpath);\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & _classPrivateFieldGet(this, _type)) return undefined;\n    try {\n      const rp = _classPrivateFieldGet(this, _fs).realpathSync(this.fullpath());\n      return _classPrivateFieldSet(this, _realpath, this.resolve(rp));\n    } catch (_) {\n      _classPrivateMethodGet(this, _markENOREALPATH, _markENOREALPATH2).call(this);\n    }\n  }\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd) {\n    if (oldCwd === this) return;\n    const changed = new Set([]);\n    let rp = [];\n    let p = this;\n    while (p && p.parent) {\n      changed.add(p);\n      _classPrivateFieldSet(p, _relative, rp.join(this.sep));\n      _classPrivateFieldSet(p, _relativePosix, rp.join('/'));\n      p = p.parent;\n      rp.push('..');\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd;\n    while (p && p.parent && !changed.has(p)) {\n      _classPrivateFieldSet(p, _relative, undefined);\n      _classPrivateFieldSet(p, _relativePosix, undefined);\n      p = p.parent;\n    }\n  }\n}\nfunction _resolveParts2(dirParts) {\n  let p = this;\n  for (const part of dirParts) {\n    p = p.child(part);\n  }\n  return p;\n}\nfunction _readdirSuccess2(children) {\n  // succeeded, mark readdir called bit\n  _classPrivateFieldSet(this, _type, _classPrivateFieldGet(this, _type) | READDIR_CALLED);\n  // mark all remaining provisional children as ENOENT\n  for (let p = children.provisional; p < children.length; p++) {\n    var _children$p;\n    _classPrivateMethodGet(_children$p = children[p], _markENOENT, _markENOENT2).call(_children$p);\n  }\n}\nfunction _markENOENT2() {\n  // mark as UNKNOWN and ENOENT\n  if (_classPrivateFieldGet(this, _type) & ENOENT) return;\n  _classPrivateFieldSet(this, _type, (_classPrivateFieldGet(this, _type) | ENOENT) & IFMT_UNKNOWN);\n  _classPrivateMethodGet(this, _markChildrenENOENT, _markChildrenENOENT2).call(this);\n}\nfunction _markChildrenENOENT2() {\n  // all children are provisional and do not exist\n  const children = this.children();\n  children.provisional = 0;\n  for (const p of children) {\n    _classPrivateMethodGet(p, _markENOENT, _markENOENT2).call(p);\n  }\n}\nfunction _markENOREALPATH2() {\n  _classPrivateFieldSet(this, _type, _classPrivateFieldGet(this, _type) | ENOREALPATH);\n  _classPrivateMethodGet(this, _markENOTDIR, _markENOTDIR2).call(this);\n}\nfunction _markENOTDIR2() {\n  // entry is not a directory, so any children can't exist.\n  // this *should* be impossible, since any children created\n  // after it's been marked ENOTDIR should be marked ENOENT,\n  // so it won't even get to this point.\n  /* c8 ignore start */\n  if (_classPrivateFieldGet(this, _type) & ENOTDIR) return;\n  /* c8 ignore stop */\n  let t = _classPrivateFieldGet(this, _type);\n  // this could happen if we stat a dir, then delete it,\n  // then try to read it or one of its children.\n  if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN;\n  _classPrivateFieldSet(this, _type, t | ENOTDIR);\n  _classPrivateMethodGet(this, _markChildrenENOENT, _markChildrenENOENT2).call(this);\n}\nfunction _readdirFail2(code = '') {\n  // markENOTDIR and markENOENT also set provisional=0\n  if (code === 'ENOTDIR' || code === 'EPERM') {\n    _classPrivateMethodGet(this, _markENOTDIR, _markENOTDIR2).call(this);\n  } else if (code === 'ENOENT') {\n    _classPrivateMethodGet(this, _markENOENT, _markENOENT2).call(this);\n  } else {\n    this.children().provisional = 0;\n  }\n}\nfunction _lstatFail2(code = '') {\n  // Windows just raises ENOENT in this case, disable for win CI\n  /* c8 ignore start */\n  if (code === 'ENOTDIR') {\n    // already know it has a parent by this point\n    const p = this.parent;\n    _classPrivateMethodGet(p, _markENOTDIR, _markENOTDIR2).call(p);\n  } else if (code === 'ENOENT') {\n    /* c8 ignore stop */\n    _classPrivateMethodGet(this, _markENOENT, _markENOENT2).call(this);\n  }\n}\nfunction _readlinkFail2(code = '') {\n  let ter = _classPrivateFieldGet(this, _type);\n  ter |= ENOREADLINK;\n  if (code === 'ENOENT') ter |= ENOENT;\n  // windows gets a weird error when you try to readlink a file\n  if (code === 'EINVAL' || code === 'UNKNOWN') {\n    // exists, but not a symlink, we don't know WHAT it is, so remove\n    // all IFMT bits.\n    ter &= IFMT_UNKNOWN;\n  }\n  _classPrivateFieldSet(this, _type, ter);\n  // windows just gets ENOENT in this case.  We do cover the case,\n  // just disabled because it's impossible on Windows CI\n  /* c8 ignore start */\n  if (code === 'ENOTDIR' && this.parent) {\n    var _this$parent;\n    _classPrivateMethodGet(_this$parent = this.parent, _markENOTDIR, _markENOTDIR2).call(_this$parent);\n  }\n  /* c8 ignore stop */\n}\nfunction _readdirAddChild2(e, c) {\n  return _classPrivateMethodGet(this, _readdirMaybePromoteChild, _readdirMaybePromoteChild2).call(this, e, c) || _classPrivateMethodGet(this, _readdirAddNewChild, _readdirAddNewChild2).call(this, e, c);\n}\nfunction _readdirAddNewChild2(e, c) {\n  // alloc new entry at head, so it's never provisional\n  const type = entToType(e);\n  const child = this.newChild(e.name, type, {\n    parent: this\n  });\n  const ifmt = _classPrivateFieldGet(child, _type) & IFMT;\n  if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n    _classPrivateFieldSet(child, _type, _classPrivateFieldGet(child, _type) | ENOTDIR);\n  }\n  c.unshift(child);\n  c.provisional++;\n  return child;\n}\nfunction _readdirMaybePromoteChild2(e, c) {\n  for (let p = c.provisional; p < c.length; p++) {\n    const pchild = c[p];\n    const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n    if (name !== _classPrivateFieldGet(pchild, _matchName)) {\n      continue;\n    }\n    return _classPrivateMethodGet(this, _readdirPromoteChild, _readdirPromoteChild2).call(this, e, pchild, p, c);\n  }\n}\nfunction _readdirPromoteChild2(e, p, index, c) {\n  const v = p.name;\n  // retain any other flags, but set ifmt from dirent\n  _classPrivateFieldSet(p, _type, _classPrivateFieldGet(p, _type) & IFMT_UNKNOWN | entToType(e));\n  // case sensitivity fixing when we learn the true name.\n  if (v !== e.name) p.name = e.name;\n  // just advance provisional index (potentially off the list),\n  // otherwise we have to splice/pop it out and re-insert at head\n  if (index !== c.provisional) {\n    if (index === c.length - 1) c.pop();else c.splice(index, 1);\n    c.unshift(p);\n  }\n  c.provisional++;\n  return p;\n}\nfunction _applyStat2(st) {\n  const {\n    atime,\n    atimeMs,\n    birthtime,\n    birthtimeMs,\n    blksize,\n    blocks,\n    ctime,\n    ctimeMs,\n    dev,\n    gid,\n    ino,\n    mode,\n    mtime,\n    mtimeMs,\n    nlink,\n    rdev,\n    size,\n    uid\n  } = st;\n  _classPrivateFieldSet(this, _atime, atime);\n  _classPrivateFieldSet(this, _atimeMs, atimeMs);\n  _classPrivateFieldSet(this, _birthtime, birthtime);\n  _classPrivateFieldSet(this, _birthtimeMs, birthtimeMs);\n  _classPrivateFieldSet(this, _blksize, blksize);\n  _classPrivateFieldSet(this, _blocks, blocks);\n  _classPrivateFieldSet(this, _ctime, ctime);\n  _classPrivateFieldSet(this, _ctimeMs, ctimeMs);\n  _classPrivateFieldSet(this, _dev, dev);\n  _classPrivateFieldSet(this, _gid, gid);\n  _classPrivateFieldSet(this, _ino, ino);\n  _classPrivateFieldSet(this, _mode, mode);\n  _classPrivateFieldSet(this, _mtime, mtime);\n  _classPrivateFieldSet(this, _mtimeMs, mtimeMs);\n  _classPrivateFieldSet(this, _nlink, nlink);\n  _classPrivateFieldSet(this, _rdev, rdev);\n  _classPrivateFieldSet(this, _size, size);\n  _classPrivateFieldSet(this, _uid, uid);\n  const ifmt = entToType(st);\n  // retain any other flags, but set the ifmt\n  _classPrivateFieldSet(this, _type, _classPrivateFieldGet(this, _type) & IFMT_UNKNOWN | ifmt | LSTAT_CALLED);\n  if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n    _classPrivateFieldSet(this, _type, _classPrivateFieldGet(this, _type) | ENOTDIR);\n  }\n}\nfunction _callOnReaddirCB2(children) {\n  _classPrivateFieldSet(this, _readdirCBInFlight, false);\n  const cbs = _classPrivateFieldGet(this, _onReaddirCB).slice();\n  _classPrivateFieldGet(this, _onReaddirCB).length = 0;\n  cbs.forEach(cb => cb(null, children));\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    super(name, type, root, roots, nocase, children, opts);\n    /**\n     * Separator for generating path strings.\n     */\n    _defineProperty(this, \"sep\", '\\\\');\n    /**\n     * Separator for parsing path strings.\n     */\n    _defineProperty(this, \"splitSep\", eitherSep);\n  }\n  /**\n   * @internal\n   */\n  newChild(name, type = UNKNOWN, opts = {}) {\n    return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return path_1.win32.parse(path).root;\n  }\n  /**\n   * @internal\n   */\n  getRoot(rootPath) {\n    rootPath = uncToDrive(rootPath.toUpperCase());\n    if (rootPath === this.root.name) {\n      return this.root;\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return this.roots[rootPath] = root;\n      }\n    }\n    // otherwise, have to create a new one.\n    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;\n  }\n  /**\n   * @internal\n   */\n  sameRoot(rootPath, compare = this.root.name) {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath.toUpperCase().replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n    return rootPath === compare;\n  }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    super(name, type, root, roots, nocase, children, opts);\n    /**\n     * separator for parsing path strings\n     */\n    _defineProperty(this, \"splitSep\", '/');\n    /**\n     * separator for generating path strings\n     */\n    _defineProperty(this, \"sep\", '/');\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return path.startsWith('/') ? '/' : '';\n  }\n  /**\n   * @internal\n   */\n  getRoot(_rootPath) {\n    return this.root;\n  }\n  /**\n   * @internal\n   */\n  newChild(name, type = UNKNOWN, opts = {}) {\n    return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nvar _resolveCache = /*#__PURE__*/new WeakMap();\nvar _resolvePosixCache = /*#__PURE__*/new WeakMap();\nvar _children3 = /*#__PURE__*/new WeakMap();\nvar _fs2 = /*#__PURE__*/new WeakMap();\n_Symbol$asyncIterator = Symbol.asyncIterator;\n_Symbol$iterator = Symbol.iterator;\nclass PathScurryBase {\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(cwd = process.cwd(), pathImpl, sep, {\n    nocase,\n    childrenCacheSize = 16 * 1024,\n    fs = defaultFS\n  } = {}) {\n    /**\n     * The root Path entry for the current working directory of this Scurry\n     */\n    _defineProperty(this, \"root\", void 0);\n    /**\n     * The string path for the root of this Scurry's current working directory\n     */\n    _defineProperty(this, \"rootPath\", void 0);\n    /**\n     * A collection of all roots encountered, referenced by rootPath\n     */\n    _defineProperty(this, \"roots\", void 0);\n    /**\n     * The Path entry corresponding to this PathScurry's current working directory.\n     */\n    _defineProperty(this, \"cwd\", void 0);\n    _classPrivateFieldInitSpec(this, _resolveCache, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _resolvePosixCache, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _children3, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     * Perform path comparisons case-insensitively.\n     *\n     * Defaults true on Darwin and Windows systems, false elsewhere.\n     */\n    _defineProperty(this, \"nocase\", void 0);\n    _classPrivateFieldInitSpec(this, _fs2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _fs2, fsFromOption(fs));\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = (0, url_1.fileURLToPath)(cwd);\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd);\n    this.roots = Object.create(null);\n    this.rootPath = this.parseRootPath(cwdPath);\n    _classPrivateFieldSet(this, _resolveCache, new ResolveCache());\n    _classPrivateFieldSet(this, _resolvePosixCache, new ResolveCache());\n    _classPrivateFieldSet(this, _children3, new ChildrenCache(childrenCacheSize));\n    const split = cwdPath.substring(this.rootPath.length).split(sep);\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop();\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase;\n    this.root = this.newRoot(_classPrivateFieldGet(this, _fs2));\n    this.roots[this.rootPath] = this.root;\n    let prev = this.root;\n    let len = split.length - 1;\n    const joinSep = pathImpl.sep;\n    let abs = this.rootPath;\n    let sawFirst = false;\n    for (const part of split) {\n      const l = len--;\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: abs += (sawFirst ? '' : joinSep) + part\n      });\n      sawFirst = true;\n    }\n    this.cwd = prev;\n  }\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path = this.cwd) {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path);\n    }\n    return path.depth();\n  }\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return _classPrivateFieldGet(this, _children3);\n  }\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths) {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = _classPrivateFieldGet(this, _resolveCache).get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpath();\n    _classPrivateFieldGet(this, _resolveCache).set(r, result);\n    return result;\n  }\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths) {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = _classPrivateFieldGet(this, _resolvePosixCache).get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpathPosix();\n    _classPrivateFieldGet(this, _resolvePosixCache).set(r, result);\n    return result;\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relative();\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relativePosix();\n  }\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.name;\n  }\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return (entry.parent || entry).fullpath();\n  }\n  readdir(entry = this.cwd, opts = {\n    withFileTypes: true\n  }) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this5.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        opts = entry;\n        entry = _this5.cwd;\n      }\n      const {\n        withFileTypes\n      } = opts;\n      if (!entry.canReaddir()) {\n        return [];\n      } else {\n        const p = yield entry.readdir();\n        return withFileTypes ? p : p.map(e => e.name);\n      }\n    })();\n  }\n  readdirSync(entry = this.cwd, opts = {\n    withFileTypes: true\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true\n    } = opts;\n    if (!entry.canReaddir()) {\n      return [];\n    } else if (withFileTypes) {\n      return entry.readdirSync();\n    } else {\n      return entry.readdirSync().map(e => e.name);\n    }\n  }\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  lstat(entry = this.cwd) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this6.cwd.resolve(entry);\n      }\n      return entry.lstat();\n    })();\n  }\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.lstatSync();\n  }\n  readlink(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this7.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        withFileTypes = entry.withFileTypes;\n        entry = _this7.cwd;\n      }\n      const e = yield entry.readlink();\n      return withFileTypes ? e : e?.fullpath();\n    })();\n  }\n  readlinkSync(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.readlinkSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  realpath(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this8.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        withFileTypes = entry.withFileTypes;\n        entry = _this8.cwd;\n      }\n      const e = yield entry.realpath();\n      return withFileTypes ? e : e?.fullpath();\n    })();\n  }\n  realpathSync(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.realpathSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  walk(entry = this.cwd, opts = {}) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof entry === 'string') {\n        entry = _this9.cwd.resolve(entry);\n      } else if (!(entry instanceof PathBase)) {\n        opts = entry;\n        entry = _this9.cwd;\n      }\n      const {\n        withFileTypes = true,\n        follow = false,\n        filter,\n        walkFilter\n      } = opts;\n      const results = [];\n      if (!filter || filter(entry)) {\n        results.push(withFileTypes ? entry : entry.fullpath());\n      }\n      const dirs = new Set();\n      const walk = (dir, cb) => {\n        dirs.add(dir);\n        dir.readdirCB((er, entries) => {\n          /* c8 ignore start */\n          if (er) {\n            return cb(er);\n          }\n          /* c8 ignore stop */\n          let len = entries.length;\n          if (!len) return cb();\n          const next = () => {\n            if (--len === 0) {\n              cb();\n            }\n          };\n          for (const e of entries) {\n            if (!filter || filter(e)) {\n              results.push(withFileTypes ? e : e.fullpath());\n            }\n            if (follow && e.isSymbolicLink()) {\n              e.realpath().then(r => r?.isUnknown() ? r.lstat() : r).then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n            } else {\n              if (e.shouldWalk(dirs, walkFilter)) {\n                walk(e, next);\n              } else {\n                next();\n              }\n            }\n          }\n        }, true); // zalgooooooo\n      };\n\n      const start = entry;\n      return new Promise((res, rej) => {\n        walk(start, er => {\n          /* c8 ignore start */\n          if (er) return rej(er);\n          /* c8 ignore stop */\n          res(results);\n        });\n      });\n    })();\n  }\n  walkSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = [];\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set([entry]);\n    for (const dir of dirs) {\n      const entries = dir.readdirSync();\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath());\n        }\n        let r = e;\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue;\n          if (r.isUnknown()) r.lstatSync();\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r);\n        }\n      }\n    }\n    return results;\n  }\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [_Symbol$asyncIterator]() {\n    return this.iterate();\n  }\n  iterate(entry = this.cwd, options = {}) {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      options = entry;\n      entry = this.cwd;\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]();\n  }\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [_Symbol$iterator]() {\n    return this.iterateSync();\n  }\n  *iterateSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath();\n    }\n    const dirs = new Set([entry]);\n    for (const dir of dirs) {\n      const entries = dir.readdirSync();\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath();\n        }\n        let r = e;\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue;\n          if (r.isUnknown()) r.lstatSync();\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r);\n        }\n      }\n    }\n  }\n  stream(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set();\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const onReaddir = (er, entries, didRealpaths = false) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er);\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises = [];\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(e.realpath().then(r => r?.isUnknown() ? r.lstat() : r));\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() => onReaddir(null, entries, true));\n              return;\n            }\n          }\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true;\n              }\n            }\n          }\n          processing--;\n          for (const e of entries) {\n            const r = e.realpathCached() || e;\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r);\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process);\n          } else if (!sync) {\n            process();\n          }\n        };\n        // zalgo containment\n        let sync = true;\n        dir.readdirCB(onReaddir, true);\n        sync = false;\n      }\n    };\n    process();\n    return results;\n  }\n  streamSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    const dirs = new Set();\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const entries = dir.readdirSync();\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true;\n            }\n          }\n        }\n        processing--;\n        for (const e of entries) {\n          let r = e;\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue;\n            if (r.isUnknown()) r.lstatSync();\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r);\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process);\n    };\n    process();\n    return results;\n  }\n  chdir(path = this.cwd) {\n    const oldCwd = this.cwd;\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n    this.cwd[setAsCwd](oldCwd);\n  }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, path_1.win32, '\\\\', {\n      ...opts,\n      nocase\n    });\n    /**\n     * separator for generating path strings\n     */\n    _defineProperty(this, \"sep\", '\\\\');\n    this.nocase = nocase;\n    for (let p = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase;\n    }\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(dir) {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return path_1.win32.parse(dir).root.toUpperCase();\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p);\n  }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = false\n    } = opts;\n    super(cwd, path_1.posix, '/', {\n      ...opts,\n      nocase\n    });\n    /**\n     * separator for generating path strings\n     */\n    _defineProperty(this, \"sep\", '/');\n    this.nocase = nocase;\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(_dir) {\n    return '/';\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/');\n  }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, {\n      ...opts,\n      nocase\n    });\n  }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexports.PathScurry = process.platform === 'win32' ? PathScurryWin32 : process.platform === 'darwin' ? PathScurryDarwin : PathScurryPosix;","map":{"version":3,"names":["_asyncToGenerator","require","default","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_defineProperty","_classPrivateMethodGet","_classPrivateFieldSet","_classPrivateFieldGet","_Symbol$asyncIterator","_Symbol$iterator","__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","PathScurry","Path","PathScurryDarwin","PathScurryPosix","PathScurryWin32","PathScurryBase","PathPosix","PathWin32","PathBase","ChildrenCache","ResolveCache","lru_cache_1","path_1","url_1","actualFS","fs_1","realpathSync","native","promises_1","minipass_1","defaultFS","lstatSync","readdir","readdirSync","readlinkSync","promises","lstat","readlink","realpath","fsFromOption","fsOption","uncDriveRegexp","uncToDrive","rootPath","replace","eitherSep","UNKNOWN","IFIFO","IFCHR","IFDIR","IFBLK","IFREG","IFLNK","IFSOCK","IFMT","IFMT_UNKNOWN","READDIR_CALLED","LSTAT_CALLED","ENOTDIR","ENOENT","ENOREADLINK","ENOREALPATH","ENOCHILD","TYPEMASK","entToType","s","isFile","isDirectory","isSymbolicLink","isCharacterDevice","isBlockDevice","isSocket","isFIFO","normalizeCache","Map","normalize","c","n","set","normalizeNocaseCache","normalizeNocase","toLowerCase","LRUCache","constructor","max","maxSize","sizeCalculation","a","length","setAsCwd","Symbol","_fs","WeakMap","_dev","_mode","_nlink","_uid","_gid","_rdev","_blksize","_ino","_size","_blocks","_atimeMs","_mtimeMs","_ctimeMs","_birthtimeMs","_atime","_mtime","_ctime","_birthtime","_matchName","_depth","_fullpath","_fullpathPosix","_relative","_relativePosix","_type","_children","_linkTarget","_realpath","_resolveParts","WeakSet","_readdirSuccess","_markENOENT","_markChildrenENOENT","_markENOREALPATH","_markENOTDIR","_readdirFail","_lstatFail","_readlinkFail","_readdirAddChild","_readdirAddNewChild","_readdirMaybePromoteChild","_readdirPromoteChild","_applyStat","_onReaddirCB","_readdirCBInFlight","_callOnReaddirCB","_asyncReaddirInFlight","dev","mode","nlink","uid","gid","rdev","blksize","ino","size","blocks","atimeMs","mtimeMs","ctimeMs","birthtimeMs","atime","mtime","ctime","birthtime","path","parent","fullpath","name","type","root","roots","nocase","children","opts","relative","relativePosix","fs","depth","childrenCache","resolve","_this$getRoot","getRootString","dir","substring","dirParts","split","splitSep","getRoot","_resolveParts2","cached","assign","provisional","child","pathPart","p","sep","pchild","newChild","canReaddir","push","pv","fullpathPosix","fp","test","pfpp","fpp","isUnknown","isType","getType","lstatCached","readlinkCached","realpathCached","readdirCached","slice","canReadlink","ifmt","calledReaddir","isENOENT","isNamed","_this","target","read","linkTarget","er","_readlinkFail2","code","_this2","_applyStat2","_lstatFail2","readdirCB","cb","allowZalgo","queueMicrotask","withFileTypes","entries","_readdirFail2","e","_readdirAddChild2","_readdirSuccess2","_callOnReaddirCB2","_this3","Promise","res","shouldWalk","dirs","walkFilter","has","_this4","rp","_","_markENOREALPATH2","oldCwd","changed","Set","add","join","part","_children$p","_markENOENT2","_markChildrenENOENT2","_markENOTDIR2","t","ter","_this$parent","_readdirMaybePromoteChild2","_readdirAddNewChild2","unshift","_readdirPromoteChild2","index","pop","splice","st","cbs","forEach","win32","parse","toUpperCase","compare","sameRoot","startsWith","_rootPath","_resolveCache","_resolvePosixCache","_children3","_fs2","asyncIterator","iterator","cwd","process","pathImpl","childrenCacheSize","URL","fileURLToPath","cwdPath","parseRootPath","TypeError","newRoot","prev","len","joinSep","abs","sawFirst","l","Array","fill","paths","r","i","isAbsolute","resolvePosix","entry","basename","dirname","_this5","map","_this6","_this7","_this8","walk","_this9","follow","filter","results","next","then","start","rej","walkSync","iterate","options","stream","iterateSync","Minipass","objectMode","write","queue","processing","paused","shift","end","onReaddir","didRealpaths","emit","all","flowing","once","sync","streamSync","chdir","posix","_dir","platform"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/path-scurry/dist/cjs/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = require(\"lru-cache\");\nconst path_1 = require(\"path\");\nconst url_1 = require(\"url\");\nconst actualFS = __importStar(require(\"fs\"));\nconst fs_1 = require(\"fs\");\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = require(\"fs/promises\");\nconst minipass_1 = require(\"minipass\");\nconst defaultFS = {\n    lstatSync: fs_1.lstatSync,\n    readdir: fs_1.readdir,\n    readdirSync: fs_1.readdirSync,\n    readlinkSync: fs_1.readlinkSync,\n    realpathSync,\n    promises: {\n        lstat: promises_1.lstat,\n        readdir: promises_1.readdir,\n        readlink: promises_1.readlink,\n        realpath: promises_1.realpath,\n    },\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS\n    ? defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n            ...defaultFS.promises,\n            ...(fsOption.promises || {}),\n        },\n    };\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = (rootPath) => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 16;\n// set after a successful lstat()\nconst LSTAT_CALLED = 32;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 64;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 128;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 256;\n// set if we know realpath() will fail\nconst ENOREALPATH = 512;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 1023;\nconst entToType = (s) => s.isFile()\n    ? IFREG\n    : s.isDirectory()\n        ? IFDIR\n        : s.isSymbolicLink()\n            ? IFLNK\n            : s.isCharacterDevice()\n                ? IFCHR\n                : s.isBlockDevice()\n                    ? IFBLK\n                    : s.isSocket()\n                        ? IFSOCK\n                        : s.isFIFO()\n                            ? IFIFO\n                            : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = (s) => {\n    const c = normalizeCache.get(s);\n    if (c)\n        return c;\n    const n = s.normalize('NFKD');\n    normalizeCache.set(s, n);\n    return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = (s) => {\n    const c = normalizeNocaseCache.get(s);\n    if (c)\n        return c;\n    const n = normalize(s.toLowerCase());\n    normalizeNocaseCache.set(s, n);\n    return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache_1.LRUCache {\n    constructor() {\n        super({ max: 256 });\n    }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache_1.LRUCache {\n    constructor(maxSize = 16 * 1024) {\n        super({\n            maxSize,\n            // parent + children\n            sizeCalculation: a => a.length + 1,\n        });\n    }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nclass PathBase {\n    /**\n     * the basename of this path\n     *\n     * **Important**: *always* test the path name against any test string\n     * usingthe {@link isNamed} method, and not by directly comparing this\n     * string. Otherwise, unicode path strings that the system sees as identical\n     * will not be properly treated as the same path, leading to incorrect\n     * behavior and possible security issues.\n     */\n    name;\n    /**\n     * the Path entry corresponding to the path root.\n     *\n     * @internal\n     */\n    root;\n    /**\n     * All roots found within the current PathScurry family\n     *\n     * @internal\n     */\n    roots;\n    /**\n     * a reference to the parent path, or undefined in the case of root entries\n     *\n     * @internal\n     */\n    parent;\n    /**\n     * boolean indicating whether paths are compared case-insensitively\n     * @internal\n     */\n    nocase;\n    // potential default fs override\n    #fs;\n    // Stats fields\n    #dev;\n    get dev() {\n        return this.#dev;\n    }\n    #mode;\n    get mode() {\n        return this.#mode;\n    }\n    #nlink;\n    get nlink() {\n        return this.#nlink;\n    }\n    #uid;\n    get uid() {\n        return this.#uid;\n    }\n    #gid;\n    get gid() {\n        return this.#gid;\n    }\n    #rdev;\n    get rdev() {\n        return this.#rdev;\n    }\n    #blksize;\n    get blksize() {\n        return this.#blksize;\n    }\n    #ino;\n    get ino() {\n        return this.#ino;\n    }\n    #size;\n    get size() {\n        return this.#size;\n    }\n    #blocks;\n    get blocks() {\n        return this.#blocks;\n    }\n    #atimeMs;\n    get atimeMs() {\n        return this.#atimeMs;\n    }\n    #mtimeMs;\n    get mtimeMs() {\n        return this.#mtimeMs;\n    }\n    #ctimeMs;\n    get ctimeMs() {\n        return this.#ctimeMs;\n    }\n    #birthtimeMs;\n    get birthtimeMs() {\n        return this.#birthtimeMs;\n    }\n    #atime;\n    get atime() {\n        return this.#atime;\n    }\n    #mtime;\n    get mtime() {\n        return this.#mtime;\n    }\n    #ctime;\n    get ctime() {\n        return this.#ctime;\n    }\n    #birthtime;\n    get birthtime() {\n        return this.#birthtime;\n    }\n    #matchName;\n    #depth;\n    #fullpath;\n    #fullpathPosix;\n    #relative;\n    #relativePosix;\n    #type;\n    #children;\n    #linkTarget;\n    #realpath;\n    /**\n     * This property is for compatibility with the Dirent class as of\n     * Node v20, where Dirent['path'] refers to the path of the directory\n     * that was passed to readdir.  So, somewhat counterintuitively, this\n     * property refers to the *parent* path, not the path object itself.\n     * For root entries, it's the path to the entry itself.\n     */\n    get path() {\n        return (this.parent || this).fullpath();\n    }\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        this.name = name;\n        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n        this.#type = type & TYPEMASK;\n        this.nocase = nocase;\n        this.roots = roots;\n        this.root = root || this;\n        this.#children = children;\n        this.#fullpath = opts.fullpath;\n        this.#relative = opts.relative;\n        this.#relativePosix = opts.relativePosix;\n        this.parent = opts.parent;\n        if (this.parent) {\n            this.#fs = this.parent.#fs;\n        }\n        else {\n            this.#fs = fsFromOption(opts.fs);\n        }\n    }\n    /**\n     * Returns the depth of the Path object from its root.\n     *\n     * For example, a path at `/foo/bar` would have a depth of 2.\n     */\n    depth() {\n        if (this.#depth !== undefined)\n            return this.#depth;\n        if (!this.parent)\n            return (this.#depth = 0);\n        return (this.#depth = this.parent.depth() + 1);\n    }\n    /**\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Get the Path object referenced by the string path, resolved from this Path\n     */\n    resolve(path) {\n        if (!path) {\n            return this;\n        }\n        const rootPath = this.getRootString(path);\n        const dir = path.substring(rootPath.length);\n        const dirParts = dir.split(this.splitSep);\n        const result = rootPath\n            ? this.getRoot(rootPath).#resolveParts(dirParts)\n            : this.#resolveParts(dirParts);\n        return result;\n    }\n    #resolveParts(dirParts) {\n        let p = this;\n        for (const part of dirParts) {\n            p = p.child(part);\n        }\n        return p;\n    }\n    /**\n     * Returns the cached children Path objects, if still available.  If they\n     * have fallen out of the cache, then returns an empty array, and resets the\n     * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n     * lookup.\n     *\n     * @internal\n     */\n    children() {\n        const cached = this.#children.get(this);\n        if (cached) {\n            return cached;\n        }\n        const children = Object.assign([], { provisional: 0 });\n        this.#children.set(this, children);\n        this.#type &= ~READDIR_CALLED;\n        return children;\n    }\n    /**\n     * Resolves a path portion and returns or creates the child Path.\n     *\n     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n     * `'..'`.\n     *\n     * This should not be called directly.  If `pathPart` contains any path\n     * separators, it will lead to unsafe undefined behavior.\n     *\n     * Use `Path.resolve()` instead.\n     *\n     * @internal\n     */\n    child(pathPart, opts) {\n        if (pathPart === '' || pathPart === '.') {\n            return this;\n        }\n        if (pathPart === '..') {\n            return this.parent || this;\n        }\n        // find the child\n        const children = this.children();\n        const name = this.nocase\n            ? normalizeNocase(pathPart)\n            : normalize(pathPart);\n        for (const p of children) {\n            if (p.#matchName === name) {\n                return p;\n            }\n        }\n        // didn't find it, create provisional child, since it might not\n        // actually exist.  If we know the parent isn't a dir, then\n        // in fact it CAN'T exist.\n        const s = this.parent ? this.sep : '';\n        const fullpath = this.#fullpath\n            ? this.#fullpath + s + pathPart\n            : undefined;\n        const pchild = this.newChild(pathPart, UNKNOWN, {\n            ...opts,\n            parent: this,\n            fullpath,\n        });\n        if (!this.canReaddir()) {\n            pchild.#type |= ENOENT;\n        }\n        // don't have to update provisional, because if we have real children,\n        // then provisional is set to children.length, otherwise a lower number\n        children.push(pchild);\n        return pchild;\n    }\n    /**\n     * The relative path from the cwd. If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpath()\n     */\n    relative() {\n        if (this.#relative !== undefined) {\n            return this.#relative;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relative = this.name);\n        }\n        const pv = p.relative();\n        return pv + (!pv || !p.parent ? '' : this.sep) + name;\n    }\n    /**\n     * The relative path from the cwd, using / as the path separator.\n     * If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpathPosix()\n     * On posix systems, this is identical to relative().\n     */\n    relativePosix() {\n        if (this.sep === '/')\n            return this.relative();\n        if (this.#relativePosix !== undefined)\n            return this.#relativePosix;\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relativePosix = this.fullpathPosix());\n        }\n        const pv = p.relativePosix();\n        return pv + (!pv || !p.parent ? '' : '/') + name;\n    }\n    /**\n     * The fully resolved path string for this Path entry\n     */\n    fullpath() {\n        if (this.#fullpath !== undefined) {\n            return this.#fullpath;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#fullpath = this.name);\n        }\n        const pv = p.fullpath();\n        const fp = pv + (!p.parent ? '' : this.sep) + name;\n        return (this.#fullpath = fp);\n    }\n    /**\n     * On platforms other than windows, this is identical to fullpath.\n     *\n     * On windows, this is overridden to return the forward-slash form of the\n     * full UNC path.\n     */\n    fullpathPosix() {\n        if (this.#fullpathPosix !== undefined)\n            return this.#fullpathPosix;\n        if (this.sep === '/')\n            return (this.#fullpathPosix = this.fullpath());\n        if (!this.parent) {\n            const p = this.fullpath().replace(/\\\\/g, '/');\n            if (/^[a-z]:\\//i.test(p)) {\n                return (this.#fullpathPosix = `//?/${p}`);\n            }\n            else {\n                return (this.#fullpathPosix = p);\n            }\n        }\n        const p = this.parent;\n        const pfpp = p.fullpathPosix();\n        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n        return (this.#fullpathPosix = fpp);\n    }\n    /**\n     * Is the Path of an unknown type?\n     *\n     * Note that we might know *something* about it if there has been a previous\n     * filesystem operation, for example that it does not exist, or is not a\n     * link, or whether it has child entries.\n     */\n    isUnknown() {\n        return (this.#type & IFMT) === UNKNOWN;\n    }\n    isType(type) {\n        return this[`is${type}`]();\n    }\n    getType() {\n        return this.isUnknown()\n            ? 'Unknown'\n            : this.isDirectory()\n                ? 'Directory'\n                : this.isFile()\n                    ? 'File'\n                    : this.isSymbolicLink()\n                        ? 'SymbolicLink'\n                        : this.isFIFO()\n                            ? 'FIFO'\n                            : this.isCharacterDevice()\n                                ? 'CharacterDevice'\n                                : this.isBlockDevice()\n                                    ? 'BlockDevice'\n                                    : /* c8 ignore start */ this.isSocket()\n                                        ? 'Socket'\n                                        : 'Unknown';\n        /* c8 ignore stop */\n    }\n    /**\n     * Is the Path a regular file?\n     */\n    isFile() {\n        return (this.#type & IFMT) === IFREG;\n    }\n    /**\n     * Is the Path a directory?\n     */\n    isDirectory() {\n        return (this.#type & IFMT) === IFDIR;\n    }\n    /**\n     * Is the path a character device?\n     */\n    isCharacterDevice() {\n        return (this.#type & IFMT) === IFCHR;\n    }\n    /**\n     * Is the path a block device?\n     */\n    isBlockDevice() {\n        return (this.#type & IFMT) === IFBLK;\n    }\n    /**\n     * Is the path a FIFO pipe?\n     */\n    isFIFO() {\n        return (this.#type & IFMT) === IFIFO;\n    }\n    /**\n     * Is the path a socket?\n     */\n    isSocket() {\n        return (this.#type & IFMT) === IFSOCK;\n    }\n    /**\n     * Is the path a symbolic link?\n     */\n    isSymbolicLink() {\n        return (this.#type & IFLNK) === IFLNK;\n    }\n    /**\n     * Return the entry if it has been subject of a successful lstat, or\n     * undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* simply\n     * mean that we haven't called lstat on it.\n     */\n    lstatCached() {\n        return this.#type & LSTAT_CALLED ? this : undefined;\n    }\n    /**\n     * Return the cached link target if the entry has been the subject of a\n     * successful readlink, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readlink() has been called at some point.\n     */\n    readlinkCached() {\n        return this.#linkTarget;\n    }\n    /**\n     * Returns the cached realpath target if the entry has been the subject\n     * of a successful realpath, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * realpath() has been called at some point.\n     */\n    realpathCached() {\n        return this.#realpath;\n    }\n    /**\n     * Returns the cached child Path entries array if the entry has been the\n     * subject of a successful readdir(), or [] otherwise.\n     *\n     * Does not read the filesystem, so an empty array *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readdir() has been called recently enough to still be valid.\n     */\n    readdirCached() {\n        const children = this.children();\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n     * any indication that readlink will definitely fail.\n     *\n     * Returns false if the path is known to not be a symlink, if a previous\n     * readlink failed, or if the entry does not exist.\n     */\n    canReadlink() {\n        if (this.#linkTarget)\n            return true;\n        if (!this.parent)\n            return false;\n        // cases where it cannot possibly succeed\n        const ifmt = this.#type & IFMT;\n        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n            this.#type & ENOREADLINK ||\n            this.#type & ENOENT);\n    }\n    /**\n     * Return true if readdir has previously been successfully called on this\n     * path, indicating that cachedReaddir() is likely valid.\n     */\n    calledReaddir() {\n        return !!(this.#type & READDIR_CALLED);\n    }\n    /**\n     * Returns true if the path is known to not exist. That is, a previous lstat\n     * or readdir failed to verify its existence when that would have been\n     * expected, or a parent entry was marked either enoent or enotdir.\n     */\n    isENOENT() {\n        return !!(this.#type & ENOENT);\n    }\n    /**\n     * Return true if the path is a match for the given path name.  This handles\n     * case sensitivity and unicode normalization.\n     *\n     * Note: even on case-sensitive systems, it is **not** safe to test the\n     * equality of the `.name` property to determine whether a given pathname\n     * matches, due to unicode normalization mismatches.\n     *\n     * Always use this method instead of testing the `path.name` property\n     * directly.\n     */\n    isNamed(n) {\n        return !this.nocase\n            ? this.#matchName === normalize(n)\n            : this.#matchName === normalizeNocase(n);\n    }\n    /**\n     * Return the Path object corresponding to the target of a symbolic link.\n     *\n     * If the Path is not a symbolic link, or if the readlink call fails for any\n     * reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     */\n    async readlink() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = await this.#fs.promises.readlink(this.fullpath());\n            const linkTarget = this.parent.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    /**\n     * Synchronous {@link PathBase.readlink}\n     */\n    readlinkSync() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = this.#fs.readlinkSync(this.fullpath());\n            const linkTarget = this.parent.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    #readdirSuccess(children) {\n        // succeeded, mark readdir called bit\n        this.#type |= READDIR_CALLED;\n        // mark all remaining provisional children as ENOENT\n        for (let p = children.provisional; p < children.length; p++) {\n            children[p].#markENOENT();\n        }\n    }\n    #markENOENT() {\n        // mark as UNKNOWN and ENOENT\n        if (this.#type & ENOENT)\n            return;\n        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n        this.#markChildrenENOENT();\n    }\n    #markChildrenENOENT() {\n        // all children are provisional and do not exist\n        const children = this.children();\n        children.provisional = 0;\n        for (const p of children) {\n            p.#markENOENT();\n        }\n    }\n    #markENOREALPATH() {\n        this.#type |= ENOREALPATH;\n        this.#markENOTDIR();\n    }\n    // save the information when we know the entry is not a dir\n    #markENOTDIR() {\n        // entry is not a directory, so any children can't exist.\n        // this *should* be impossible, since any children created\n        // after it's been marked ENOTDIR should be marked ENOENT,\n        // so it won't even get to this point.\n        /* c8 ignore start */\n        if (this.#type & ENOTDIR)\n            return;\n        /* c8 ignore stop */\n        let t = this.#type;\n        // this could happen if we stat a dir, then delete it,\n        // then try to read it or one of its children.\n        if ((t & IFMT) === IFDIR)\n            t &= IFMT_UNKNOWN;\n        this.#type = t | ENOTDIR;\n        this.#markChildrenENOENT();\n    }\n    #readdirFail(code = '') {\n        // markENOTDIR and markENOENT also set provisional=0\n        if (code === 'ENOTDIR' || code === 'EPERM') {\n            this.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            this.#markENOENT();\n        }\n        else {\n            this.children().provisional = 0;\n        }\n    }\n    #lstatFail(code = '') {\n        // Windows just raises ENOENT in this case, disable for win CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR') {\n            // already know it has a parent by this point\n            const p = this.parent;\n            p.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            /* c8 ignore stop */\n            this.#markENOENT();\n        }\n    }\n    #readlinkFail(code = '') {\n        let ter = this.#type;\n        ter |= ENOREADLINK;\n        if (code === 'ENOENT')\n            ter |= ENOENT;\n        // windows gets a weird error when you try to readlink a file\n        if (code === 'EINVAL' || code === 'UNKNOWN') {\n            // exists, but not a symlink, we don't know WHAT it is, so remove\n            // all IFMT bits.\n            ter &= IFMT_UNKNOWN;\n        }\n        this.#type = ter;\n        // windows just gets ENOENT in this case.  We do cover the case,\n        // just disabled because it's impossible on Windows CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR' && this.parent) {\n            this.parent.#markENOTDIR();\n        }\n        /* c8 ignore stop */\n    }\n    #readdirAddChild(e, c) {\n        return (this.#readdirMaybePromoteChild(e, c) ||\n            this.#readdirAddNewChild(e, c));\n    }\n    #readdirAddNewChild(e, c) {\n        // alloc new entry at head, so it's never provisional\n        const type = entToType(e);\n        const child = this.newChild(e.name, type, { parent: this });\n        const ifmt = child.#type & IFMT;\n        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n            child.#type |= ENOTDIR;\n        }\n        c.unshift(child);\n        c.provisional++;\n        return child;\n    }\n    #readdirMaybePromoteChild(e, c) {\n        for (let p = c.provisional; p < c.length; p++) {\n            const pchild = c[p];\n            const name = this.nocase\n                ? normalizeNocase(e.name)\n                : normalize(e.name);\n            if (name !== pchild.#matchName) {\n                continue;\n            }\n            return this.#readdirPromoteChild(e, pchild, p, c);\n        }\n    }\n    #readdirPromoteChild(e, p, index, c) {\n        const v = p.name;\n        // retain any other flags, but set ifmt from dirent\n        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);\n        // case sensitivity fixing when we learn the true name.\n        if (v !== e.name)\n            p.name = e.name;\n        // just advance provisional index (potentially off the list),\n        // otherwise we have to splice/pop it out and re-insert at head\n        if (index !== c.provisional) {\n            if (index === c.length - 1)\n                c.pop();\n            else\n                c.splice(index, 1);\n            c.unshift(p);\n        }\n        c.provisional++;\n        return p;\n    }\n    /**\n     * Call lstat() on this Path, and update all known information that can be\n     * determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    /**\n     * synchronous {@link PathBase.lstat}\n     */\n    lstatSync() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    #applyStat(st) {\n        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;\n        this.#atime = atime;\n        this.#atimeMs = atimeMs;\n        this.#birthtime = birthtime;\n        this.#birthtimeMs = birthtimeMs;\n        this.#blksize = blksize;\n        this.#blocks = blocks;\n        this.#ctime = ctime;\n        this.#ctimeMs = ctimeMs;\n        this.#dev = dev;\n        this.#gid = gid;\n        this.#ino = ino;\n        this.#mode = mode;\n        this.#mtime = mtime;\n        this.#mtimeMs = mtimeMs;\n        this.#nlink = nlink;\n        this.#rdev = rdev;\n        this.#size = size;\n        this.#uid = uid;\n        const ifmt = entToType(st);\n        // retain any other flags, but set the ifmt\n        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;\n        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n            this.#type |= ENOTDIR;\n        }\n    }\n    #onReaddirCB = [];\n    #readdirCBInFlight = false;\n    #callOnReaddirCB(children) {\n        this.#readdirCBInFlight = false;\n        const cbs = this.#onReaddirCB.slice();\n        this.#onReaddirCB.length = 0;\n        cbs.forEach(cb => cb(null, children));\n    }\n    /**\n     * Standard node-style callback interface to get list of directory entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     *\n     * @param cb The callback called with (er, entries).  Note that the `er`\n     * param is somewhat extraneous, as all readdir() errors are handled and\n     * simply result in an empty set of entries being returned.\n     * @param allowZalgo Boolean indicating that immediately known results should\n     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n     * zalgo at your peril, the dark pony lord is devious and unforgiving.\n     */\n    readdirCB(cb, allowZalgo = false) {\n        if (!this.canReaddir()) {\n            if (allowZalgo)\n                cb(null, []);\n            else\n                queueMicrotask(() => cb(null, []));\n            return;\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            const c = children.slice(0, children.provisional);\n            if (allowZalgo)\n                cb(null, c);\n            else\n                queueMicrotask(() => cb(null, c));\n            return;\n        }\n        // don't have to worry about zalgo at this point.\n        this.#onReaddirCB.push(cb);\n        if (this.#readdirCBInFlight) {\n            return;\n        }\n        this.#readdirCBInFlight = true;\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n            if (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            else {\n                // if we didn't get an error, we always get entries.\n                //@ts-ignore\n                for (const e of entries) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            this.#callOnReaddirCB(children.slice(0, children.provisional));\n            return;\n        });\n    }\n    #asyncReaddirInFlight;\n    /**\n     * Return an array of known child entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async readdir() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        if (this.#asyncReaddirInFlight) {\n            await this.#asyncReaddirInFlight;\n        }\n        else {\n            /* c8 ignore start */\n            let resolve = () => { };\n            /* c8 ignore stop */\n            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));\n            try {\n                for (const e of await this.#fs.promises.readdir(fullpath, {\n                    withFileTypes: true,\n                })) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            catch (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            this.#asyncReaddirInFlight = undefined;\n            resolve();\n        }\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * synchronous {@link PathBase.readdir}\n     */\n    readdirSync() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        try {\n            for (const e of this.#fs.readdirSync(fullpath, {\n                withFileTypes: true,\n            })) {\n                this.#readdirAddChild(e, children);\n            }\n            this.#readdirSuccess(children);\n        }\n        catch (er) {\n            this.#readdirFail(er.code);\n            children.provisional = 0;\n        }\n        return children.slice(0, children.provisional);\n    }\n    canReaddir() {\n        if (this.#type & ENOCHILD)\n            return false;\n        const ifmt = IFMT & this.#type;\n        // we always set ENOTDIR when setting IFMT, so should be impossible\n        /* c8 ignore start */\n        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n            return false;\n        }\n        /* c8 ignore stop */\n        return true;\n    }\n    shouldWalk(dirs, walkFilter) {\n        return ((this.#type & IFDIR) === IFDIR &&\n            !(this.#type & ENOCHILD) &&\n            !dirs.has(this) &&\n            (!walkFilter || walkFilter(this)));\n    }\n    /**\n     * Return the Path object corresponding to path as resolved\n     * by realpath(3).\n     *\n     * If the realpath call fails for any reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     * On success, returns a Path object.\n     */\n    async realpath() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = await this.#fs.promises.realpath(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Synchronous {@link realpath}\n     */\n    realpathSync() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = this.#fs.realpathSync(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Internal method to mark this Path object as the scurry cwd,\n     * called by {@link PathScurry#chdir}\n     *\n     * @internal\n     */\n    [setAsCwd](oldCwd) {\n        if (oldCwd === this)\n            return;\n        const changed = new Set([]);\n        let rp = [];\n        let p = this;\n        while (p && p.parent) {\n            changed.add(p);\n            p.#relative = rp.join(this.sep);\n            p.#relativePosix = rp.join('/');\n            p = p.parent;\n            rp.push('..');\n        }\n        // now un-memoize parents of old cwd\n        p = oldCwd;\n        while (p && p.parent && !changed.has(p)) {\n            p.#relative = undefined;\n            p.#relativePosix = undefined;\n            p = p.parent;\n        }\n    }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n    /**\n     * Separator for generating path strings.\n     */\n    sep = '\\\\';\n    /**\n     * Separator for parsing path strings.\n     */\n    splitSep = eitherSep;\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return path_1.win32.parse(path).root;\n    }\n    /**\n     * @internal\n     */\n    getRoot(rootPath) {\n        rootPath = uncToDrive(rootPath.toUpperCase());\n        if (rootPath === this.root.name) {\n            return this.root;\n        }\n        // ok, not that one, check if it matches another we know about\n        for (const [compare, root] of Object.entries(this.roots)) {\n            if (this.sameRoot(rootPath, compare)) {\n                return (this.roots[rootPath] = root);\n            }\n        }\n        // otherwise, have to create a new one.\n        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);\n    }\n    /**\n     * @internal\n     */\n    sameRoot(rootPath, compare = this.root.name) {\n        // windows can (rarely) have case-sensitive filesystem, but\n        // UNC and drive letters are always case-insensitive, and canonically\n        // represented uppercase.\n        rootPath = rootPath\n            .toUpperCase()\n            .replace(/\\//g, '\\\\')\n            .replace(uncDriveRegexp, '$1\\\\');\n        return rootPath === compare;\n    }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n    /**\n     * separator for parsing path strings\n     */\n    splitSep = '/';\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return path.startsWith('/') ? '/' : '';\n    }\n    /**\n     * @internal\n     */\n    getRoot(_rootPath) {\n        return this.root;\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nclass PathScurryBase {\n    /**\n     * The root Path entry for the current working directory of this Scurry\n     */\n    root;\n    /**\n     * The string path for the root of this Scurry's current working directory\n     */\n    rootPath;\n    /**\n     * A collection of all roots encountered, referenced by rootPath\n     */\n    roots;\n    /**\n     * The Path entry corresponding to this PathScurry's current working directory.\n     */\n    cwd;\n    #resolveCache;\n    #resolvePosixCache;\n    #children;\n    /**\n     * Perform path comparisons case-insensitively.\n     *\n     * Defaults true on Darwin and Windows systems, false elsewhere.\n     */\n    nocase;\n    #fs;\n    /**\n     * This class should not be instantiated directly.\n     *\n     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n     *\n     * @internal\n     */\n    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {\n        this.#fs = fsFromOption(fs);\n        if (cwd instanceof URL || cwd.startsWith('file://')) {\n            cwd = (0, url_1.fileURLToPath)(cwd);\n        }\n        // resolve and split root, and then add to the store.\n        // this is the only time we call path.resolve()\n        const cwdPath = pathImpl.resolve(cwd);\n        this.roots = Object.create(null);\n        this.rootPath = this.parseRootPath(cwdPath);\n        this.#resolveCache = new ResolveCache();\n        this.#resolvePosixCache = new ResolveCache();\n        this.#children = new ChildrenCache(childrenCacheSize);\n        const split = cwdPath.substring(this.rootPath.length).split(sep);\n        // resolve('/') leaves '', splits to [''], we don't want that.\n        if (split.length === 1 && !split[0]) {\n            split.pop();\n        }\n        /* c8 ignore start */\n        if (nocase === undefined) {\n            throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n        }\n        /* c8 ignore stop */\n        this.nocase = nocase;\n        this.root = this.newRoot(this.#fs);\n        this.roots[this.rootPath] = this.root;\n        let prev = this.root;\n        let len = split.length - 1;\n        const joinSep = pathImpl.sep;\n        let abs = this.rootPath;\n        let sawFirst = false;\n        for (const part of split) {\n            const l = len--;\n            prev = prev.child(part, {\n                relative: new Array(l).fill('..').join(joinSep),\n                relativePosix: new Array(l).fill('..').join('/'),\n                fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n            });\n            sawFirst = true;\n        }\n        this.cwd = prev;\n    }\n    /**\n     * Get the depth of a provided path, string, or the cwd\n     */\n    depth(path = this.cwd) {\n        if (typeof path === 'string') {\n            path = this.cwd.resolve(path);\n        }\n        return path.depth();\n    }\n    /**\n     * Return the cache of child entries.  Exposed so subclasses can create\n     * child Path objects in a platform-specific way.\n     *\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolve(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolveCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpath();\n        this.#resolveCache.set(r, result);\n        return result;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string, returning\n     * the posix path.  Identical to .resolve() on posix systems, but on\n     * windows will return a forward-slash separated UNC path.\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolvePosix(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolvePosixCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpathPosix();\n        this.#resolvePosixCache.set(r, result);\n        return result;\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or entry\n     */\n    relative(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relative();\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or\n     * entry, using / as the path delimiter, even on Windows.\n     */\n    relativePosix(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relativePosix();\n    }\n    /**\n     * Return the basename for the provided string or Path object\n     */\n    basename(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.name;\n    }\n    /**\n     * Return the dirname for the provided string or Path object\n     */\n    dirname(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return (entry.parent || entry).fullpath();\n    }\n    async readdir(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else {\n            const p = await entry.readdir();\n            return withFileTypes ? p : p.map(e => e.name);\n        }\n    }\n    readdirSync(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else if (withFileTypes) {\n            return entry.readdirSync();\n        }\n        else {\n            return entry.readdirSync().map(e => e.name);\n        }\n    }\n    /**\n     * Call lstat() on the string or Path object, and update all known\n     * information that can be determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstat();\n    }\n    /**\n     * synchronous {@link PathScurryBase.lstat}\n     */\n    lstatSync(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstatSync();\n    }\n    async readlink(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.readlink();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    readlinkSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.readlinkSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async realpath(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.realpath();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    realpathSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.realpathSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async walk(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const walk = (dir, cb) => {\n            dirs.add(dir);\n            dir.readdirCB((er, entries) => {\n                /* c8 ignore start */\n                if (er) {\n                    return cb(er);\n                }\n                /* c8 ignore stop */\n                let len = entries.length;\n                if (!len)\n                    return cb();\n                const next = () => {\n                    if (--len === 0) {\n                        cb();\n                    }\n                };\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        results.push(withFileTypes ? e : e.fullpath());\n                    }\n                    if (follow && e.isSymbolicLink()) {\n                        e.realpath()\n                            .then(r => (r?.isUnknown() ? r.lstat() : r))\n                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n                    }\n                    else {\n                        if (e.shouldWalk(dirs, walkFilter)) {\n                            walk(e, next);\n                        }\n                        else {\n                            next();\n                        }\n                    }\n                }\n            }, true); // zalgooooooo\n        };\n        const start = entry;\n        return new Promise((res, rej) => {\n            walk(start, er => {\n                /* c8 ignore start */\n                if (er)\n                    return rej(er);\n                /* c8 ignore stop */\n                res(results);\n            });\n        });\n    }\n    walkSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    results.push(withFileTypes ? e : e.fullpath());\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Support for `for await`\n     *\n     * Alias for {@link PathScurryBase.iterate}\n     *\n     * Note: As of Node 19, this is very slow, compared to other methods of\n     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n     */\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate(entry = this.cwd, options = {}) {\n        // iterating async over the stream is significantly more performant,\n        // especially in the warm-cache scenario, because it buffers up directory\n        // entries in the background instead of waiting for a yield for each one.\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            options = entry;\n            entry = this.cwd;\n        }\n        return this.stream(entry, options)[Symbol.asyncIterator]();\n    }\n    /**\n     * Iterating over a PathScurry performs a synchronous walk.\n     *\n     * Alias for {@link PathScurryBase.iterateSync}\n     */\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    *iterateSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        if (!filter || filter(entry)) {\n            yield withFileTypes ? entry : entry.fullpath();\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    yield withFileTypes ? e : e.fullpath();\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n    }\n    stream(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass_1.Minipass({ objectMode: true });\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const onReaddir = (er, entries, didRealpaths = false) => {\n                    /* c8 ignore start */\n                    if (er)\n                        return results.emit('error', er);\n                    /* c8 ignore stop */\n                    if (follow && !didRealpaths) {\n                        const promises = [];\n                        for (const e of entries) {\n                            if (e.isSymbolicLink()) {\n                                promises.push(e\n                                    .realpath()\n                                    .then((r) => r?.isUnknown() ? r.lstat() : r));\n                            }\n                        }\n                        if (promises.length) {\n                            Promise.all(promises).then(() => onReaddir(null, entries, true));\n                            return;\n                        }\n                    }\n                    for (const e of entries) {\n                        if (e && (!filter || filter(e))) {\n                            if (!results.write(withFileTypes ? e : e.fullpath())) {\n                                paused = true;\n                            }\n                        }\n                    }\n                    processing--;\n                    for (const e of entries) {\n                        const r = e.realpathCached() || e;\n                        if (r.shouldWalk(dirs, walkFilter)) {\n                            queue.push(r);\n                        }\n                    }\n                    if (paused && !results.flowing) {\n                        results.once('drain', process);\n                    }\n                    else if (!sync) {\n                        process();\n                    }\n                };\n                // zalgo containment\n                let sync = true;\n                dir.readdirCB(onReaddir, true);\n                sync = false;\n            }\n        };\n        process();\n        return results;\n    }\n    streamSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass_1.Minipass({ objectMode: true });\n        const dirs = new Set();\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const entries = dir.readdirSync();\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        if (!results.write(withFileTypes ? e : e.fullpath())) {\n                            paused = true;\n                        }\n                    }\n                }\n                processing--;\n                for (const e of entries) {\n                    let r = e;\n                    if (e.isSymbolicLink()) {\n                        if (!(follow && (r = e.realpathSync())))\n                            continue;\n                        if (r.isUnknown())\n                            r.lstatSync();\n                    }\n                    if (r.shouldWalk(dirs, walkFilter)) {\n                        queue.push(r);\n                    }\n                }\n            }\n            if (paused && !results.flowing)\n                results.once('drain', process);\n        };\n        process();\n        return results;\n    }\n    chdir(path = this.cwd) {\n        const oldCwd = this.cwd;\n        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n        this.cwd[setAsCwd](oldCwd);\n    }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '\\\\';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, path_1.win32, '\\\\', { ...opts, nocase });\n        this.nocase = nocase;\n        for (let p = this.cwd; p; p = p.parent) {\n            p.nocase = this.nocase;\n        }\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(dir) {\n        // if the path starts with a single separator, it's not a UNC, and we'll\n        // just get separator as the root, and driveFromUNC will return \\\n        // In that case, mount \\ on the root from the cwd.\n        return path_1.win32.parse(dir).root.toUpperCase();\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return (p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p));\n    }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = false } = opts;\n        super(cwd, path_1.posix, '/', { ...opts, nocase });\n        this.nocase = nocase;\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(_dir) {\n        return '/';\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return p.startsWith('/');\n    }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, { ...opts, nocase });\n    }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexports.PathScurry = process.platform === 'win32'\n    ? PathScurryWin32\n    : process.platform === 'darwin'\n        ? PathScurryDarwin\n        : PathScurryPosix;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}