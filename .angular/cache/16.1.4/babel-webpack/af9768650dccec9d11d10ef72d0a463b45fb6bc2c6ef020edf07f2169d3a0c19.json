{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classPrivateMethodInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nconst minipass_1 = require(\"minipass\");\nconst ignore_js_1 = require(\"./ignore.js\");\nconst processor_js_1 = require(\"./processor.js\");\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nvar _onResume = /*#__PURE__*/new WeakMap();\nvar _ignore = /*#__PURE__*/new WeakMap();\nvar _sep = /*#__PURE__*/new WeakMap();\nvar _ignored = /*#__PURE__*/new WeakSet();\nvar _childrenIgnored = /*#__PURE__*/new WeakSet();\nclass GlobUtil {\n  constructor(patterns, _path, opts) {\n    _classPrivateMethodInitSpec(this, _childrenIgnored);\n    _classPrivateMethodInitSpec(this, _ignored);\n    _defineProperty(this, \"path\", void 0);\n    _defineProperty(this, \"patterns\", void 0);\n    _defineProperty(this, \"opts\", void 0);\n    _defineProperty(this, \"seen\", new Set());\n    _defineProperty(this, \"paused\", false);\n    _defineProperty(this, \"aborted\", false);\n    _classPrivateFieldInitSpec(this, _onResume, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _ignore, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _sep, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"signal\", void 0);\n    _defineProperty(this, \"maxDepth\", void 0);\n    this.patterns = patterns;\n    this.path = _path;\n    this.opts = opts;\n    _classPrivateFieldSet(this, _sep, !opts.posix && opts.platform === 'win32' ? '\\\\' : '/');\n    if (opts.ignore) {\n      _classPrivateFieldSet(this, _ignore, makeIgnore(opts.ignore, opts));\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity;\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal;\n      this.signal.addEventListener('abort', () => {\n        _classPrivateFieldGet(this, _onResume).length = 0;\n      });\n    }\n  }\n  // backpressure mechanism\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return;\n    /* c8 ignore stop */\n    this.paused = false;\n    let fn = undefined;\n    while (!this.paused && (fn = _classPrivateFieldGet(this, _onResume).shift())) {\n      fn();\n    }\n  }\n  onResume(fn) {\n    if (this.signal?.aborted) return;\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn();\n    } else {\n      /* c8 ignore stop */\n      _classPrivateFieldGet(this, _onResume).push(fn);\n    }\n  }\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  matchCheck(e, ifDir) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (ifDir && _this.opts.nodir) return undefined;\n      let rpc;\n      if (_this.opts.realpath) {\n        rpc = e.realpathCached() || (yield e.realpath());\n        if (!rpc) return undefined;\n        e = rpc;\n      }\n      const needStat = e.isUnknown() || _this.opts.stat;\n      return _this.matchCheckTest(needStat ? yield e.lstat() : e, ifDir);\n    })();\n  }\n  matchCheckTest(e, ifDir) {\n    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !_classPrivateMethodGet(this, _ignored, _ignored2).call(this, e) ? e : undefined;\n  }\n  matchCheckSync(e, ifDir) {\n    if (ifDir && this.opts.nodir) return undefined;\n    let rpc;\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync();\n      if (!rpc) return undefined;\n      e = rpc;\n    }\n    const needStat = e.isUnknown() || this.opts.stat;\n    return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);\n  }\n  matchFinish(e, absolute) {\n    if (_classPrivateMethodGet(this, _ignored, _ignored2).call(this, e)) return;\n    const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n    this.seen.add(e);\n    const mark = this.opts.mark && e.isDirectory() ? _classPrivateFieldGet(this, _sep) : '';\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e);\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n      this.matchEmit(abs + mark);\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative();\n      const pre = this.opts.dotRelative && !rel.startsWith('..' + _classPrivateFieldGet(this, _sep)) ? '.' + _classPrivateFieldGet(this, _sep) : '';\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n    }\n  }\n  match(e, absolute, ifDir) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const p = yield _this2.matchCheck(e, ifDir);\n      if (p) _this2.matchFinish(p, absolute);\n    })();\n  }\n  matchSync(e, absolute, ifDir) {\n    const p = this.matchCheckSync(e, ifDir);\n    if (p) this.matchFinish(p, absolute);\n  }\n  walkCB(target, patterns, cb) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb();\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);\n  }\n  walkCB2(target, patterns, processor, cb) {\n    if (_classPrivateMethodGet(this, _childrenIgnored, _childrenIgnored2).call(this, target)) return cb();\n    if (this.signal?.aborted) cb();\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n      return;\n    }\n    processor.processPatterns(target, patterns);\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (_classPrivateMethodGet(this, _ignored, _ignored2).call(this, m)) continue;\n      tasks++;\n      this.match(m, absolute, ifDir).then(() => next());\n    }\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue;\n      }\n      tasks++;\n      const childrenCached = t.readdirCached();\n      if (t.calledReaddir()) this.walkCB3(t, childrenCached, processor, next);else {\n        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n      }\n    }\n    next();\n  }\n  walkCB3(target, entries, processor, cb) {\n    processor = processor.filterEntries(target, entries);\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (_classPrivateMethodGet(this, _ignored, _ignored2).call(this, m)) continue;\n      tasks++;\n      this.match(m, absolute, ifDir).then(() => next());\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++;\n      this.walkCB2(target, patterns, processor.child(), next);\n    }\n    next();\n  }\n  walkCBSync(target, patterns, cb) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb();\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);\n  }\n  walkCB2Sync(target, patterns, processor, cb) {\n    if (_classPrivateMethodGet(this, _childrenIgnored, _childrenIgnored2).call(this, target)) return cb();\n    if (this.signal?.aborted) cb();\n    if (this.paused) {\n      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n      return;\n    }\n    processor.processPatterns(target, patterns);\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (_classPrivateMethodGet(this, _ignored, _ignored2).call(this, m)) continue;\n      this.matchSync(m, absolute, ifDir);\n    }\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue;\n      }\n      tasks++;\n      const children = t.readdirSync();\n      this.walkCB3Sync(t, children, processor, next);\n    }\n    next();\n  }\n  walkCB3Sync(target, entries, processor, cb) {\n    processor = processor.filterEntries(target, entries);\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (_classPrivateMethodGet(this, _ignored, _ignored2).call(this, m)) continue;\n      this.matchSync(m, absolute, ifDir);\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++;\n      this.walkCB2Sync(target, patterns, processor.child(), next);\n    }\n    next();\n  }\n}\nfunction _ignored2(path) {\n  return this.seen.has(path) || !!_classPrivateFieldGet(this, _ignore)?.ignored?.(path);\n}\nfunction _childrenIgnored2(path) {\n  return !!_classPrivateFieldGet(this, _ignore)?.childrenIgnored?.(path);\n}\nexports.GlobUtil = GlobUtil;\nclass GlobWalker extends GlobUtil {\n  constructor(patterns, path, opts) {\n    super(patterns, path, opts);\n    _defineProperty(this, \"matches\", void 0);\n    this.matches = new Set();\n  }\n  matchEmit(e) {\n    this.matches.add(e);\n  }\n  walk() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (_this3.signal?.aborted) throw _this3.signal.reason;\n      if (_this3.path.isUnknown()) {\n        yield _this3.path.lstat();\n      }\n      yield new Promise((res, rej) => {\n        _this3.walkCB(_this3.path, _this3.patterns, () => {\n          if (_this3.signal?.aborted) {\n            rej(_this3.signal.reason);\n          } else {\n            res(_this3.matches);\n          }\n        });\n      });\n      return _this3.matches;\n    })();\n  }\n  walkSync() {\n    if (this.signal?.aborted) throw this.signal.reason;\n    if (this.path.isUnknown()) {\n      this.path.lstatSync();\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason;\n    });\n    return this.matches;\n  }\n}\nexports.GlobWalker = GlobWalker;\nclass GlobStream extends GlobUtil {\n  constructor(patterns, path, opts) {\n    super(patterns, path, opts);\n    _defineProperty(this, \"results\", void 0);\n    this.results = new minipass_1.Minipass({\n      signal: this.signal,\n      objectMode: true\n    });\n    this.results.on('drain', () => this.resume());\n    this.results.on('resume', () => this.resume());\n  }\n  matchEmit(e) {\n    this.results.write(e);\n    if (!this.results.flowing) this.pause();\n  }\n  stream() {\n    const target = this.path;\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end());\n      });\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end());\n    }\n    return this.results;\n  }\n  streamSync() {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync();\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end());\n    return this.results;\n  }\n}\nexports.GlobStream = GlobStream;","map":{"version":3,"names":["_asyncToGenerator","require","default","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_defineProperty","_classPrivateMethodGet","_classPrivateFieldGet","_classPrivateFieldSet","Object","defineProperty","exports","value","GlobStream","GlobWalker","GlobUtil","minipass_1","ignore_js_1","processor_js_1","makeIgnore","ignore","opts","Ignore","Array","isArray","_onResume","WeakMap","_ignore","_sep","_ignored","WeakSet","_childrenIgnored","constructor","patterns","path","Set","writable","posix","platform","maxDepth","Infinity","signal","addEventListener","length","pause","paused","resume","aborted","fn","undefined","shift","onResume","push","matchCheck","e","ifDir","_this","nodir","rpc","realpath","realpathCached","needStat","isUnknown","stat","matchCheckTest","lstat","depth","canReaddir","isDirectory","_ignored2","call","matchCheckSync","realpathSync","lstatSync","matchFinish","absolute","abs","seen","add","mark","withFileTypes","matchEmit","fullpathPosix","fullpath","rel","relativePosix","relative","pre","dotRelative","startsWith","match","_this2","p","matchSync","walkCB","target","cb","walkCB2","Processor","processor","_childrenIgnored2","processPatterns","tasks","next","m","matches","entries","then","t","subwalkTargets","childrenCached","readdirCached","calledReaddir","walkCB3","readdirCB","_","filterEntries","subwalks","child","walkCBSync","walkCB2Sync","children","readdirSync","walkCB3Sync","has","ignored","childrenIgnored","walk","_this3","reason","Promise","res","rej","walkSync","results","Minipass","objectMode","on","write","flowing","stream","end","streamSync"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/glob/dist/cjs/src/walker.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nconst minipass_1 = require(\"minipass\");\nconst ignore_js_1 = require(\"./ignore.js\");\nconst processor_js_1 = require(\"./processor.js\");\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string'\n    ? new ignore_js_1.Ignore([ignore], opts)\n    : Array.isArray(ignore)\n        ? new ignore_js_1.Ignore(ignore, opts)\n        : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n    path;\n    patterns;\n    opts;\n    seen = new Set();\n    paused = false;\n    aborted = false;\n    #onResume = [];\n    #ignore;\n    #sep;\n    signal;\n    maxDepth;\n    constructor(patterns, path, opts) {\n        this.patterns = patterns;\n        this.path = path;\n        this.opts = opts;\n        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n        if (opts.ignore) {\n            this.#ignore = makeIgnore(opts.ignore, opts);\n        }\n        // ignore, always set with maxDepth, but it's optional on the\n        // GlobOptions type\n        /* c8 ignore start */\n        this.maxDepth = opts.maxDepth || Infinity;\n        /* c8 ignore stop */\n        if (opts.signal) {\n            this.signal = opts.signal;\n            this.signal.addEventListener('abort', () => {\n                this.#onResume.length = 0;\n            });\n        }\n    }\n    #ignored(path) {\n        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n    }\n    #childrenIgnored(path) {\n        return !!this.#ignore?.childrenIgnored?.(path);\n    }\n    // backpressure mechanism\n    pause() {\n        this.paused = true;\n    }\n    resume() {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore stop */\n        this.paused = false;\n        let fn = undefined;\n        while (!this.paused && (fn = this.#onResume.shift())) {\n            fn();\n        }\n    }\n    onResume(fn) {\n        if (this.signal?.aborted)\n            return;\n        /* c8 ignore start */\n        if (!this.paused) {\n            fn();\n        }\n        else {\n            /* c8 ignore stop */\n            this.#onResume.push(fn);\n        }\n    }\n    // do the requisite realpath/stat checking, and return the path\n    // to add or undefined to filter it out.\n    async matchCheck(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || (await e.realpath());\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);\n    }\n    matchCheckTest(e, ifDir) {\n        return e &&\n            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n            (!ifDir || e.canReaddir()) &&\n            (!this.opts.nodir || !e.isDirectory()) &&\n            !this.#ignored(e)\n            ? e\n            : undefined;\n    }\n    matchCheckSync(e, ifDir) {\n        if (ifDir && this.opts.nodir)\n            return undefined;\n        let rpc;\n        if (this.opts.realpath) {\n            rpc = e.realpathCached() || e.realpathSync();\n            if (!rpc)\n                return undefined;\n            e = rpc;\n        }\n        const needStat = e.isUnknown() || this.opts.stat;\n        return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);\n    }\n    matchFinish(e, absolute) {\n        if (this.#ignored(e))\n            return;\n        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n        this.seen.add(e);\n        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n        // ok, we have what we need!\n        if (this.opts.withFileTypes) {\n            this.matchEmit(e);\n        }\n        else if (abs) {\n            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n            this.matchEmit(abs + mark);\n        }\n        else {\n            const rel = this.opts.posix ? e.relativePosix() : e.relative();\n            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep)\n                ? '.' + this.#sep\n                : '';\n            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n        }\n    }\n    async match(e, absolute, ifDir) {\n        const p = await this.matchCheck(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    matchSync(e, absolute, ifDir) {\n        const p = this.matchCheckSync(e, ifDir);\n        if (p)\n            this.matchFinish(p, absolute);\n    }\n    walkCB(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const childrenCached = t.readdirCached();\n            if (t.calledReaddir())\n                this.walkCB3(t, childrenCached, processor, next);\n            else {\n                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n            }\n        }\n        next();\n    }\n    walkCB3(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            tasks++;\n            this.match(m, absolute, ifDir).then(() => next());\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n    walkCBSync(target, patterns, cb) {\n        /* c8 ignore start */\n        if (this.signal?.aborted)\n            cb();\n        /* c8 ignore stop */\n        this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);\n    }\n    walkCB2Sync(target, patterns, processor, cb) {\n        if (this.#childrenIgnored(target))\n            return cb();\n        if (this.signal?.aborted)\n            cb();\n        if (this.paused) {\n            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n            return;\n        }\n        processor.processPatterns(target, patterns);\n        // done processing.  all of the above is sync, can be abstracted out.\n        // subwalks is a map of paths to the entry filters they need\n        // matches is a map of paths to [absolute, ifDir] tuples.\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const t of processor.subwalkTargets()) {\n            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n                continue;\n            }\n            tasks++;\n            const children = t.readdirSync();\n            this.walkCB3Sync(t, children, processor, next);\n        }\n        next();\n    }\n    walkCB3Sync(target, entries, processor, cb) {\n        processor = processor.filterEntries(target, entries);\n        let tasks = 1;\n        const next = () => {\n            if (--tasks === 0)\n                cb();\n        };\n        for (const [m, absolute, ifDir] of processor.matches.entries()) {\n            if (this.#ignored(m))\n                continue;\n            this.matchSync(m, absolute, ifDir);\n        }\n        for (const [target, patterns] of processor.subwalks.entries()) {\n            tasks++;\n            this.walkCB2Sync(target, patterns, processor.child(), next);\n        }\n        next();\n    }\n}\nexports.GlobUtil = GlobUtil;\nclass GlobWalker extends GlobUtil {\n    matches;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.matches = new Set();\n    }\n    matchEmit(e) {\n        this.matches.add(e);\n    }\n    async walk() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            await this.path.lstat();\n        }\n        await new Promise((res, rej) => {\n            this.walkCB(this.path, this.patterns, () => {\n                if (this.signal?.aborted) {\n                    rej(this.signal.reason);\n                }\n                else {\n                    res(this.matches);\n                }\n            });\n        });\n        return this.matches;\n    }\n    walkSync() {\n        if (this.signal?.aborted)\n            throw this.signal.reason;\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        // nothing for the callback to do, because this never pauses\n        this.walkCBSync(this.path, this.patterns, () => {\n            if (this.signal?.aborted)\n                throw this.signal.reason;\n        });\n        return this.matches;\n    }\n}\nexports.GlobWalker = GlobWalker;\nclass GlobStream extends GlobUtil {\n    results;\n    constructor(patterns, path, opts) {\n        super(patterns, path, opts);\n        this.results = new minipass_1.Minipass({\n            signal: this.signal,\n            objectMode: true,\n        });\n        this.results.on('drain', () => this.resume());\n        this.results.on('resume', () => this.resume());\n    }\n    matchEmit(e) {\n        this.results.write(e);\n        if (!this.results.flowing)\n            this.pause();\n    }\n    stream() {\n        const target = this.path;\n        if (target.isUnknown()) {\n            target.lstat().then(() => {\n                this.walkCB(target, this.patterns, () => this.results.end());\n            });\n        }\n        else {\n            this.walkCB(target, this.patterns, () => this.results.end());\n        }\n        return this.results;\n    }\n    streamSync() {\n        if (this.path.isUnknown()) {\n            this.path.lstatSync();\n        }\n        this.walkCBSync(this.path, this.patterns, () => this.results.end());\n        return this.results;\n    }\n}\nexports.GlobStream = GlobStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}