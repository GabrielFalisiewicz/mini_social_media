{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst api_1 = require(\"./api\");\nclass ChannelAlreadyExistException extends core_1.BaseException {\n  constructor(name) {\n    super(`Channel ${JSON.stringify(name)} already exist.`);\n  }\n}\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\nfunction createJobHandler(fn, options = {}) {\n  const handler = (argument, context) => {\n    const description = context.description;\n    const inboundBus = context.inboundBus;\n    const inputChannel = new rxjs_1.Subject();\n    let subscription;\n    const teardownLogics = [];\n    let tearingDown = false;\n    return new rxjs_1.Observable(subject => {\n      function complete() {\n        if (subscription) {\n          subscription.unsubscribe();\n        }\n        subject.next({\n          kind: api_1.JobOutboundMessageKind.End,\n          description\n        });\n        subject.complete();\n        inputChannel.complete();\n      }\n      // Handle input.\n      const inboundSub = inboundBus.subscribe(message => {\n        switch (message.kind) {\n          case api_1.JobInboundMessageKind.Ping:\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.Pong,\n              description,\n              id: message.id\n            });\n            break;\n          case api_1.JobInboundMessageKind.Stop:\n            // Run teardown logic then complete.\n            tearingDown = true;\n            if (teardownLogics.length) {\n              Promise.all(teardownLogics.map(fn => fn())).then(() => complete(), () => complete());\n            } else {\n              complete();\n            }\n            break;\n          case api_1.JobInboundMessageKind.Input:\n            if (!tearingDown) {\n              inputChannel.next(message.value);\n            }\n            break;\n        }\n      });\n      // Execute the function with the additional context.\n      const channels = new Map();\n      const newContext = {\n        ...context,\n        input: inputChannel.asObservable(),\n        addTeardown(teardown) {\n          teardownLogics.push(teardown);\n        },\n        createChannel(name) {\n          if (channels.has(name)) {\n            throw new ChannelAlreadyExistException(name);\n          }\n          const channelSubject = new rxjs_1.Subject();\n          const channelSub = channelSubject.subscribe(message => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelMessage,\n              description,\n              name,\n              message\n            });\n          }, error => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelError,\n              description,\n              name,\n              error\n            });\n            // This can be reopened.\n            channels.delete(name);\n          }, () => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelComplete,\n              description,\n              name\n            });\n            // This can be reopened.\n            channels.delete(name);\n          });\n          channels.set(name, channelSubject);\n          if (subscription) {\n            subscription.add(channelSub);\n          }\n          return channelSubject;\n        }\n      };\n      subject.next({\n        kind: api_1.JobOutboundMessageKind.Start,\n        description\n      });\n      let result = fn(argument, newContext);\n      // If the result is a promise, simply wait for it to complete before reporting the result.\n      if ((0, core_1.isPromise)(result)) {\n        result = (0, rxjs_1.from)(result);\n      } else if (!(0, rxjs_1.isObservable)(result)) {\n        result = (0, rxjs_1.of)(result);\n      }\n      subscription = result.subscribe(value => subject.next({\n        kind: api_1.JobOutboundMessageKind.Output,\n        description,\n        value\n      }), error => subject.error(error), () => complete());\n      subscription.add(inboundSub);\n      return subscription;\n    });\n  };\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\nfunction createJobFactory(loader, options = {}) {\n  const handler = (argument, context) => {\n    return (0, rxjs_1.from)(loader()).pipe((0, rxjs_1.switchMap)(fn => fn(argument, context)));\n  };\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\nfunction createLoggerJob(job, logger) {\n  const handler = (argument, context) => {\n    context.inboundBus.pipe((0, rxjs_1.tap)(message => logger.info(`Input: ${JSON.stringify(message)}`))).subscribe();\n    return job(argument, context).pipe((0, rxjs_1.tap)(message => logger.info(`Message: ${JSON.stringify(message)}`), error => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n  };\n  return Object.assign(handler, job);\n}\nexports.createLoggerJob = createLoggerJob;","map":{"version":3,"names":["Object","defineProperty","exports","value","createLoggerJob","createJobFactory","createJobHandler","ChannelAlreadyExistException","core_1","require","rxjs_1","api_1","BaseException","constructor","name","JSON","stringify","fn","options","handler","argument","context","description","inboundBus","inputChannel","Subject","subscription","teardownLogics","tearingDown","Observable","subject","complete","unsubscribe","next","kind","JobOutboundMessageKind","End","inboundSub","subscribe","message","JobInboundMessageKind","Ping","Pong","id","Stop","length","Promise","all","map","then","Input","channels","Map","newContext","input","asObservable","addTeardown","teardown","push","createChannel","has","channelSubject","channelSub","ChannelMessage","error","ChannelError","delete","ChannelComplete","set","add","Start","result","isPromise","from","isObservable","of","Output","assign","jobDescription","loader","pipe","switchMap","job","logger","tap","info","warn"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular-devkit/architect/src/jobs/create-job-handler.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst api_1 = require(\"./api\");\nclass ChannelAlreadyExistException extends core_1.BaseException {\n    constructor(name) {\n        super(`Channel ${JSON.stringify(name)} already exist.`);\n    }\n}\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\nfunction createJobHandler(fn, options = {}) {\n    const handler = (argument, context) => {\n        const description = context.description;\n        const inboundBus = context.inboundBus;\n        const inputChannel = new rxjs_1.Subject();\n        let subscription;\n        const teardownLogics = [];\n        let tearingDown = false;\n        return new rxjs_1.Observable((subject) => {\n            function complete() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                }\n                subject.next({ kind: api_1.JobOutboundMessageKind.End, description });\n                subject.complete();\n                inputChannel.complete();\n            }\n            // Handle input.\n            const inboundSub = inboundBus.subscribe((message) => {\n                switch (message.kind) {\n                    case api_1.JobInboundMessageKind.Ping:\n                        subject.next({ kind: api_1.JobOutboundMessageKind.Pong, description, id: message.id });\n                        break;\n                    case api_1.JobInboundMessageKind.Stop:\n                        // Run teardown logic then complete.\n                        tearingDown = true;\n                        if (teardownLogics.length) {\n                            Promise.all(teardownLogics.map((fn) => fn())).then(() => complete(), () => complete());\n                        }\n                        else {\n                            complete();\n                        }\n                        break;\n                    case api_1.JobInboundMessageKind.Input:\n                        if (!tearingDown) {\n                            inputChannel.next(message.value);\n                        }\n                        break;\n                }\n            });\n            // Execute the function with the additional context.\n            const channels = new Map();\n            const newContext = {\n                ...context,\n                input: inputChannel.asObservable(),\n                addTeardown(teardown) {\n                    teardownLogics.push(teardown);\n                },\n                createChannel(name) {\n                    if (channels.has(name)) {\n                        throw new ChannelAlreadyExistException(name);\n                    }\n                    const channelSubject = new rxjs_1.Subject();\n                    const channelSub = channelSubject.subscribe((message) => {\n                        subject.next({\n                            kind: api_1.JobOutboundMessageKind.ChannelMessage,\n                            description,\n                            name,\n                            message,\n                        });\n                    }, (error) => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelError, description, name, error });\n                        // This can be reopened.\n                        channels.delete(name);\n                    }, () => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelComplete, description, name });\n                        // This can be reopened.\n                        channels.delete(name);\n                    });\n                    channels.set(name, channelSubject);\n                    if (subscription) {\n                        subscription.add(channelSub);\n                    }\n                    return channelSubject;\n                },\n            };\n            subject.next({ kind: api_1.JobOutboundMessageKind.Start, description });\n            let result = fn(argument, newContext);\n            // If the result is a promise, simply wait for it to complete before reporting the result.\n            if ((0, core_1.isPromise)(result)) {\n                result = (0, rxjs_1.from)(result);\n            }\n            else if (!(0, rxjs_1.isObservable)(result)) {\n                result = (0, rxjs_1.of)(result);\n            }\n            subscription = result.subscribe((value) => subject.next({ kind: api_1.JobOutboundMessageKind.Output, description, value }), (error) => subject.error(error), () => complete());\n            subscription.add(inboundSub);\n            return subscription;\n        });\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\nfunction createJobFactory(loader, options = {}) {\n    const handler = (argument, context) => {\n        return (0, rxjs_1.from)(loader()).pipe((0, rxjs_1.switchMap)((fn) => fn(argument, context)));\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\nfunction createLoggerJob(job, logger) {\n    const handler = (argument, context) => {\n        context.inboundBus\n            .pipe((0, rxjs_1.tap)((message) => logger.info(`Input: ${JSON.stringify(message)}`)))\n            .subscribe();\n        return job(argument, context).pipe((0, rxjs_1.tap)((message) => logger.info(`Message: ${JSON.stringify(message)}`), (error) => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n    };\n    return Object.assign(handler, job);\n}\nexports.createLoggerJob = createLoggerJob;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}