{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Verifier = void 0;\nconst ca = __importStar(require(\"./ca/verify\"));\nconst error_1 = require(\"./error\");\nconst tlog = __importStar(require(\"./tlog/verify\"));\nconst sigstore = __importStar(require(\"./types/sigstore\"));\nconst util_1 = require(\"./util\");\nclass Verifier {\n  constructor(trustedRoot, keySelector) {\n    this.trustedRoot = trustedRoot;\n    this.keySelector = keySelector || (() => undefined);\n  }\n  // Verifies the bundle signature, the bundle's certificate chain (if present)\n  // and the bundle's transparency log entries.\n  verify(bundle, options, data) {\n    this.verifyArtifactSignature(bundle, data);\n    if (sigstore.isBundleWithCertificateChain(bundle)) {\n      this.verifySigningCertificate(bundle, options);\n    }\n    if (options.tlogOptions.disable === false) {\n      this.verifyTLogEntries(bundle, options);\n    }\n  }\n  // Performs bundle signature verification. Determines the type of the bundle\n  // content and delegates to the appropriate signature verification function.\n  verifyArtifactSignature(bundle, data) {\n    const publicKey = this.getPublicKey(bundle);\n    switch (bundle.content?.$case) {\n      case 'messageSignature':\n        if (!data) {\n          throw new error_1.VerificationError('no data provided for message signature verification');\n        }\n        verifyMessageSignature(data, bundle.content.messageSignature, publicKey);\n        break;\n      case 'dsseEnvelope':\n        verifyDSSESignature(bundle.content.dsseEnvelope, publicKey);\n        break;\n    }\n  }\n  // Performs verification of the bundle's certificate chain. The bundle must\n  // contain a certificate chain and the options must contain the required\n  // options for CA verification.\n  // TODO: We've temporarily removed the requirement that the options contain\n  // the list of trusted signer identities. This will be added back in a future\n  // release.\n  verifySigningCertificate(bundle, options) {\n    if (!sigstore.isCAVerificationOptions(options)) {\n      throw new error_1.VerificationError('no trusted certificates provided for verification');\n    }\n    ca.verifySigningCertificate(bundle, this.trustedRoot, options);\n  }\n  // Performs verification of the bundle's transparency log entries. The bundle\n  // must contain a list of transparency log entries.\n  verifyTLogEntries(bundle, options) {\n    tlog.verifyTLogEntries(bundle, this.trustedRoot, options.tlogOptions);\n  }\n  // Returns the public key which will be used to verify the bundle signature.\n  // The public key is selected based on the verification material in the bundle\n  // and the options provided.\n  getPublicKey(bundle) {\n    // Select the key which will be used to verify the signature\n    switch (bundle.verificationMaterial?.content?.$case) {\n      // If the bundle contains a certificate chain, the public key is the\n      // first certificate in the chain (the signing certificate)\n      case 'x509CertificateChain':\n        return getPublicKeyFromCertificateChain(bundle.verificationMaterial.content.x509CertificateChain);\n      // If the bundle contains a public key hint, the public key is selected\n      // from the list of trusted keys in the options\n      case 'publicKey':\n        return getPublicKeyFromHint(bundle.verificationMaterial.content.publicKey, this.keySelector);\n    }\n  }\n}\nexports.Verifier = Verifier;\n// Retrieves the public key from the first certificate in the certificate chain\nfunction getPublicKeyFromCertificateChain(certificateChain) {\n  const cert = util_1.pem.fromDER(certificateChain.certificates[0].rawBytes);\n  return util_1.crypto.createPublicKey(cert);\n}\n// Retrieves the public key through the key selector callback, passing the\n// public key hint from the bundle\nfunction getPublicKeyFromHint(publicKeyID, keySelector) {\n  const key = keySelector(publicKeyID.hint);\n  if (!key) {\n    throw new error_1.VerificationError('no public key found for signature verification');\n  }\n  try {\n    return util_1.crypto.createPublicKey(key);\n  } catch (e) {\n    throw new error_1.VerificationError('invalid public key');\n  }\n}\n// Performs signature verification for bundle containing a message signature.\n// Verifies that the digest and signature found in the bundle match the\n// provided data.\nfunction verifyMessageSignature(data, messageSignature, publicKey) {\n  // Extract signature for message\n  const {\n    signature,\n    messageDigest\n  } = messageSignature;\n  const calculatedDigest = util_1.crypto.hash(data);\n  if (!calculatedDigest.equals(messageDigest.digest)) {\n    throw new error_1.VerificationError('message digest verification failed');\n  }\n  if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {\n    throw new error_1.VerificationError('artifact signature verification failed');\n  }\n}\n// Performs signature verification for bundle containing a DSSE envelope.\n// Calculates the PAE for the DSSE envelope and verifies it against the\n// signature in the envelope.\nfunction verifyDSSESignature(envelope, publicKey) {\n  // Construct payload over which the signature was originally created\n  const {\n    payloadType,\n    payload\n  } = envelope;\n  const data = util_1.dsse.preAuthEncoding(payloadType, payload);\n  // Only support a single signature in DSSE\n  const signature = envelope.signatures[0].sig;\n  if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {\n    throw new error_1.VerificationError('artifact signature verification failed');\n  }\n}","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","exports","Verifier","ca","require","error_1","tlog","sigstore","util_1","constructor","trustedRoot","keySelector","verify","bundle","options","data","verifyArtifactSignature","isBundleWithCertificateChain","verifySigningCertificate","tlogOptions","disable","verifyTLogEntries","publicKey","getPublicKey","content","$case","VerificationError","verifyMessageSignature","messageSignature","verifyDSSESignature","dsseEnvelope","isCAVerificationOptions","verificationMaterial","getPublicKeyFromCertificateChain","x509CertificateChain","getPublicKeyFromHint","certificateChain","cert","pem","fromDER","certificates","rawBytes","crypto","createPublicKey","publicKeyID","key","hint","e","signature","messageDigest","calculatedDigest","hash","equals","digest","verifyBlob","envelope","payloadType","payload","dsse","preAuthEncoding","signatures","sig"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/verify.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Verifier = void 0;\nconst ca = __importStar(require(\"./ca/verify\"));\nconst error_1 = require(\"./error\");\nconst tlog = __importStar(require(\"./tlog/verify\"));\nconst sigstore = __importStar(require(\"./types/sigstore\"));\nconst util_1 = require(\"./util\");\nclass Verifier {\n    constructor(trustedRoot, keySelector) {\n        this.trustedRoot = trustedRoot;\n        this.keySelector = keySelector || (() => undefined);\n    }\n    // Verifies the bundle signature, the bundle's certificate chain (if present)\n    // and the bundle's transparency log entries.\n    verify(bundle, options, data) {\n        this.verifyArtifactSignature(bundle, data);\n        if (sigstore.isBundleWithCertificateChain(bundle)) {\n            this.verifySigningCertificate(bundle, options);\n        }\n        if (options.tlogOptions.disable === false) {\n            this.verifyTLogEntries(bundle, options);\n        }\n    }\n    // Performs bundle signature verification. Determines the type of the bundle\n    // content and delegates to the appropriate signature verification function.\n    verifyArtifactSignature(bundle, data) {\n        const publicKey = this.getPublicKey(bundle);\n        switch (bundle.content?.$case) {\n            case 'messageSignature':\n                if (!data) {\n                    throw new error_1.VerificationError('no data provided for message signature verification');\n                }\n                verifyMessageSignature(data, bundle.content.messageSignature, publicKey);\n                break;\n            case 'dsseEnvelope':\n                verifyDSSESignature(bundle.content.dsseEnvelope, publicKey);\n                break;\n        }\n    }\n    // Performs verification of the bundle's certificate chain. The bundle must\n    // contain a certificate chain and the options must contain the required\n    // options for CA verification.\n    // TODO: We've temporarily removed the requirement that the options contain\n    // the list of trusted signer identities. This will be added back in a future\n    // release.\n    verifySigningCertificate(bundle, options) {\n        if (!sigstore.isCAVerificationOptions(options)) {\n            throw new error_1.VerificationError('no trusted certificates provided for verification');\n        }\n        ca.verifySigningCertificate(bundle, this.trustedRoot, options);\n    }\n    // Performs verification of the bundle's transparency log entries. The bundle\n    // must contain a list of transparency log entries.\n    verifyTLogEntries(bundle, options) {\n        tlog.verifyTLogEntries(bundle, this.trustedRoot, options.tlogOptions);\n    }\n    // Returns the public key which will be used to verify the bundle signature.\n    // The public key is selected based on the verification material in the bundle\n    // and the options provided.\n    getPublicKey(bundle) {\n        // Select the key which will be used to verify the signature\n        switch (bundle.verificationMaterial?.content?.$case) {\n            // If the bundle contains a certificate chain, the public key is the\n            // first certificate in the chain (the signing certificate)\n            case 'x509CertificateChain':\n                return getPublicKeyFromCertificateChain(bundle.verificationMaterial.content.x509CertificateChain);\n            // If the bundle contains a public key hint, the public key is selected\n            // from the list of trusted keys in the options\n            case 'publicKey':\n                return getPublicKeyFromHint(bundle.verificationMaterial.content.publicKey, this.keySelector);\n        }\n    }\n}\nexports.Verifier = Verifier;\n// Retrieves the public key from the first certificate in the certificate chain\nfunction getPublicKeyFromCertificateChain(certificateChain) {\n    const cert = util_1.pem.fromDER(certificateChain.certificates[0].rawBytes);\n    return util_1.crypto.createPublicKey(cert);\n}\n// Retrieves the public key through the key selector callback, passing the\n// public key hint from the bundle\nfunction getPublicKeyFromHint(publicKeyID, keySelector) {\n    const key = keySelector(publicKeyID.hint);\n    if (!key) {\n        throw new error_1.VerificationError('no public key found for signature verification');\n    }\n    try {\n        return util_1.crypto.createPublicKey(key);\n    }\n    catch (e) {\n        throw new error_1.VerificationError('invalid public key');\n    }\n}\n// Performs signature verification for bundle containing a message signature.\n// Verifies that the digest and signature found in the bundle match the\n// provided data.\nfunction verifyMessageSignature(data, messageSignature, publicKey) {\n    // Extract signature for message\n    const { signature, messageDigest } = messageSignature;\n    const calculatedDigest = util_1.crypto.hash(data);\n    if (!calculatedDigest.equals(messageDigest.digest)) {\n        throw new error_1.VerificationError('message digest verification failed');\n    }\n    if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {\n        throw new error_1.VerificationError('artifact signature verification failed');\n    }\n}\n// Performs signature verification for bundle containing a DSSE envelope.\n// Calculates the PAE for the DSSE envelope and verifies it against the\n// signature in the envelope.\nfunction verifyDSSESignature(envelope, publicKey) {\n    // Construct payload over which the signature was originally created\n    const { payloadType, payload } = envelope;\n    const data = util_1.dsse.preAuthEncoding(payloadType, payload);\n    // Only support a single signature in DSSE\n    const signature = envelope.signatures[0].sig;\n    if (!util_1.crypto.verifyBlob(data, publicKey, signature)) {\n        throw new error_1.VerificationError('artifact signature verification failed');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}