{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  mkdir,\n  readFile,\n  rm,\n  stat,\n  truncate,\n  writeFile\n} = require('fs/promises');\nconst pMap = require('p-map');\nconst contentPath = require('./content/path');\nconst fsm = require('fs-minipass');\nconst glob = require('./util/glob.js');\nconst index = require('./entry-index');\nconst path = require('path');\nconst ssri = require('ssri');\nconst hasOwnProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\nconst verifyOpts = opts => ({\n  concurrency: 20,\n  log: {\n    silly() {}\n  },\n  ...opts\n});\nmodule.exports = verify;\nfunction verify(_x, _x2) {\n  return _verify.apply(this, arguments);\n}\nfunction _verify() {\n  _verify = _asyncToGenerator(function* (cache, opts) {\n    opts = verifyOpts(opts);\n    opts.log.silly('verify', 'verifying cache at', cache);\n    const steps = [markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime];\n    const stats = {};\n    for (const step of steps) {\n      const label = step.name;\n      const start = new Date();\n      const s = yield step(cache, opts);\n      if (s) {\n        Object.keys(s).forEach(k => {\n          stats[k] = s[k];\n        });\n      }\n      const end = new Date();\n      if (!stats.runTime) {\n        stats.runTime = {};\n      }\n      stats.runTime[label] = end - start;\n    }\n    stats.runTime.total = stats.endTime - stats.startTime;\n    opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`);\n    return stats;\n  });\n  return _verify.apply(this, arguments);\n}\nfunction markStartTime(_x3, _x4) {\n  return _markStartTime.apply(this, arguments);\n}\nfunction _markStartTime() {\n  _markStartTime = _asyncToGenerator(function* (cache, opts) {\n    return {\n      startTime: new Date()\n    };\n  });\n  return _markStartTime.apply(this, arguments);\n}\nfunction markEndTime(_x5, _x6) {\n  return _markEndTime.apply(this, arguments);\n}\nfunction _markEndTime() {\n  _markEndTime = _asyncToGenerator(function* (cache, opts) {\n    return {\n      endTime: new Date()\n    };\n  });\n  return _markEndTime.apply(this, arguments);\n}\nfunction fixPerms(_x7, _x8) {\n  return _fixPerms.apply(this, arguments);\n} // Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rm it.\n//\nfunction _fixPerms() {\n  _fixPerms = _asyncToGenerator(function* (cache, opts) {\n    opts.log.silly('verify', 'fixing cache permissions');\n    yield mkdir(cache, {\n      recursive: true\n    });\n    return null;\n  });\n  return _fixPerms.apply(this, arguments);\n}\nfunction garbageCollect(_x9, _x10) {\n  return _garbageCollect.apply(this, arguments);\n}\nfunction _garbageCollect() {\n  _garbageCollect = _asyncToGenerator(function* (cache, opts) {\n    opts.log.silly('verify', 'garbage collecting content');\n    const indexStream = index.lsStream(cache);\n    const liveContent = new Set();\n    indexStream.on('data', entry => {\n      if (opts.filter && !opts.filter(entry)) {\n        return;\n      }\n\n      // integrity is stringified, re-parse it so we can get each hash\n      const integrity = ssri.parse(entry.integrity);\n      for (const algo in integrity) {\n        liveContent.add(integrity[algo].toString());\n      }\n    });\n    yield new Promise((resolve, reject) => {\n      indexStream.on('end', resolve).on('error', reject);\n    });\n    const contentDir = contentPath.contentDir(cache);\n    const files = yield glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    });\n    const stats = {\n      verifiedContent: 0,\n      reclaimedCount: 0,\n      reclaimedSize: 0,\n      badContentCount: 0,\n      keptSize: 0\n    };\n    yield pMap(files, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (f) {\n        const split = f.split(/[/\\\\]/);\n        const digest = split.slice(split.length - 3).join('');\n        const algo = split[split.length - 4];\n        const integrity = ssri.fromHex(digest, algo);\n        if (liveContent.has(integrity.toString())) {\n          const info = yield verifyContent(f, integrity);\n          if (!info.valid) {\n            stats.reclaimedCount++;\n            stats.badContentCount++;\n            stats.reclaimedSize += info.size;\n          } else {\n            stats.verifiedContent++;\n            stats.keptSize += info.size;\n          }\n        } else {\n          // No entries refer to this content. We can delete.\n          stats.reclaimedCount++;\n          const s = yield stat(f);\n          yield rm(f, {\n            recursive: true,\n            force: true\n          });\n          stats.reclaimedSize += s.size;\n        }\n        return stats;\n      });\n      return function (_x22) {\n        return _ref.apply(this, arguments);\n      };\n    }(), {\n      concurrency: opts.concurrency\n    });\n    return stats;\n  });\n  return _garbageCollect.apply(this, arguments);\n}\nfunction verifyContent(_x11, _x12) {\n  return _verifyContent.apply(this, arguments);\n}\nfunction _verifyContent() {\n  _verifyContent = _asyncToGenerator(function* (filepath, sri) {\n    const contentInfo = {};\n    try {\n      const {\n        size\n      } = yield stat(filepath);\n      contentInfo.size = size;\n      contentInfo.valid = true;\n      yield ssri.checkStream(new fsm.ReadStream(filepath), sri);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return {\n          size: 0,\n          valid: false\n        };\n      }\n      if (err.code !== 'EINTEGRITY') {\n        throw err;\n      }\n      yield rm(filepath, {\n        recursive: true,\n        force: true\n      });\n      contentInfo.valid = false;\n    }\n    return contentInfo;\n  });\n  return _verifyContent.apply(this, arguments);\n}\nfunction rebuildIndex(_x13, _x14) {\n  return _rebuildIndex.apply(this, arguments);\n}\nfunction _rebuildIndex() {\n  _rebuildIndex = _asyncToGenerator(function* (cache, opts) {\n    opts.log.silly('verify', 'rebuilding index');\n    const entries = yield index.ls(cache);\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    };\n    const buckets = {};\n    for (const k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        const hashed = index.hashKey(k);\n        const entry = entries[k];\n        const excluded = opts.filter && !opts.filter(entry);\n        excluded && stats.rejectedEntries++;\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry);\n        } else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = [];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        } else {\n          buckets[hashed] = [entry];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        }\n      }\n    }\n    yield pMap(Object.keys(buckets), key => {\n      return rebuildBucket(cache, buckets[key], stats, opts);\n    }, {\n      concurrency: opts.concurrency\n    });\n    return stats;\n  });\n  return _rebuildIndex.apply(this, arguments);\n}\nfunction rebuildBucket(_x15, _x16, _x17, _x18) {\n  return _rebuildBucket.apply(this, arguments);\n}\nfunction _rebuildBucket() {\n  _rebuildBucket = _asyncToGenerator(function* (cache, bucket, stats, opts) {\n    yield truncate(bucket._path);\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    for (const entry of bucket) {\n      const content = contentPath(cache, entry.integrity);\n      try {\n        yield stat(content);\n        yield index.insert(cache, entry.key, entry.integrity, {\n          metadata: entry.metadata,\n          size: entry.size,\n          time: entry.time\n        });\n        stats.totalEntries++;\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          stats.rejectedEntries++;\n          stats.missingContent++;\n        } else {\n          throw err;\n        }\n      }\n    }\n  });\n  return _rebuildBucket.apply(this, arguments);\n}\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rm(path.join(cache, 'tmp'), {\n    recursive: true,\n    force: true\n  });\n}\nfunction writeVerifile(_x19, _x20) {\n  return _writeVerifile.apply(this, arguments);\n}\nfunction _writeVerifile() {\n  _writeVerifile = _asyncToGenerator(function* (cache, opts) {\n    const verifile = path.join(cache, '_lastverified');\n    opts.log.silly('verify', 'writing verifile to ' + verifile);\n    return writeFile(verifile, `${Date.now()}`);\n  });\n  return _writeVerifile.apply(this, arguments);\n}\nmodule.exports.lastRun = lastRun;\nfunction lastRun(_x21) {\n  return _lastRun.apply(this, arguments);\n}\nfunction _lastRun() {\n  _lastRun = _asyncToGenerator(function* (cache) {\n    const data = yield readFile(path.join(cache, '_lastverified'), {\n      encoding: 'utf8'\n    });\n    return new Date(+data);\n  });\n  return _lastRun.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","mkdir","readFile","rm","stat","truncate","writeFile","pMap","contentPath","fsm","glob","index","path","ssri","hasOwnProperty","obj","key","Object","prototype","call","verifyOpts","opts","concurrency","log","silly","module","exports","verify","_x","_x2","_verify","apply","arguments","cache","steps","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","stats","step","label","name","start","Date","s","keys","forEach","k","end","runTime","total","endTime","startTime","_x3","_x4","_markStartTime","_x5","_x6","_markEndTime","_x7","_x8","_fixPerms","recursive","_x9","_x10","_garbageCollect","indexStream","lsStream","liveContent","Set","on","entry","filter","integrity","parse","algo","add","toString","Promise","resolve","reject","contentDir","files","join","follow","nodir","nosort","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","_ref","f","split","digest","slice","length","fromHex","has","info","verifyContent","valid","size","force","_x22","_x11","_x12","_verifyContent","filepath","sri","contentInfo","checkStream","ReadStream","err","code","_x13","_x14","_rebuildIndex","entries","ls","missingContent","rejectedEntries","totalEntries","buckets","hashed","hashKey","excluded","push","_path","bucketPath","rebuildBucket","_x15","_x16","_x17","_x18","_rebuildBucket","bucket","content","insert","metadata","time","_x19","_x20","_writeVerifile","verifile","now","lastRun","_x21","_lastRun","data","encoding"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/cacache/lib/verify.js"],"sourcesContent":["'use strict'\n\nconst {\n  mkdir,\n  readFile,\n  rm,\n  stat,\n  truncate,\n  writeFile,\n} = require('fs/promises')\nconst pMap = require('p-map')\nconst contentPath = require('./content/path')\nconst fsm = require('fs-minipass')\nconst glob = require('./util/glob.js')\nconst index = require('./entry-index')\nconst path = require('path')\nconst ssri = require('ssri')\n\nconst hasOwnProperty = (obj, key) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nconst verifyOpts = (opts) => ({\n  concurrency: 20,\n  log: { silly () {} },\n  ...opts,\n})\n\nmodule.exports = verify\n\nasync function verify (cache, opts) {\n  opts = verifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n\n  const steps = [\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime,\n  ]\n\n  const stats = {}\n  for (const step of steps) {\n    const label = step.name\n    const start = new Date()\n    const s = await step(cache, opts)\n    if (s) {\n      Object.keys(s).forEach((k) => {\n        stats[k] = s[k]\n      })\n    }\n    const end = new Date()\n    if (!stats.runTime) {\n      stats.runTime = {}\n    }\n    stats.runTime[label] = end - start\n  }\n  stats.runTime.total = stats.endTime - stats.startTime\n  opts.log.silly(\n    'verify',\n    'verification finished for',\n    cache,\n    'in',\n    `${stats.runTime.total}ms`\n  )\n  return stats\n}\n\nasync function markStartTime (cache, opts) {\n  return { startTime: new Date() }\n}\n\nasync function markEndTime (cache, opts) {\n  return { endTime: new Date() }\n}\n\nasync function fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  await mkdir(cache, { recursive: true })\n  return null\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rm it.\n//\nasync function garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', (entry) => {\n    if (opts.filter && !opts.filter(entry)) {\n      return\n    }\n\n    // integrity is stringified, re-parse it so we can get each hash\n    const integrity = ssri.parse(entry.integrity)\n    for (const algo in integrity) {\n      liveContent.add(integrity[algo].toString())\n    }\n  })\n  await new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject)\n  })\n  const contentDir = contentPath.contentDir(cache)\n  const files = await glob(path.join(contentDir, '**'), {\n    follow: false,\n    nodir: true,\n    nosort: true,\n  })\n  const stats = {\n    verifiedContent: 0,\n    reclaimedCount: 0,\n    reclaimedSize: 0,\n    badContentCount: 0,\n    keptSize: 0,\n  }\n  await pMap(\n    files,\n    async (f) => {\n      const split = f.split(/[/\\\\]/)\n      const digest = split.slice(split.length - 3).join('')\n      const algo = split[split.length - 4]\n      const integrity = ssri.fromHex(digest, algo)\n      if (liveContent.has(integrity.toString())) {\n        const info = await verifyContent(f, integrity)\n        if (!info.valid) {\n          stats.reclaimedCount++\n          stats.badContentCount++\n          stats.reclaimedSize += info.size\n        } else {\n          stats.verifiedContent++\n          stats.keptSize += info.size\n        }\n      } else {\n        // No entries refer to this content. We can delete.\n        stats.reclaimedCount++\n        const s = await stat(f)\n        await rm(f, { recursive: true, force: true })\n        stats.reclaimedSize += s.size\n      }\n      return stats\n    },\n    { concurrency: opts.concurrency }\n  )\n  return stats\n}\n\nasync function verifyContent (filepath, sri) {\n  const contentInfo = {}\n  try {\n    const { size } = await stat(filepath)\n    contentInfo.size = size\n    contentInfo.valid = true\n    await ssri.checkStream(new fsm.ReadStream(filepath), sri)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return { size: 0, valid: false }\n    }\n    if (err.code !== 'EINTEGRITY') {\n      throw err\n    }\n\n    await rm(filepath, { recursive: true, force: true })\n    contentInfo.valid = false\n  }\n  return contentInfo\n}\n\nasync function rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  const entries = await index.ls(cache)\n  const stats = {\n    missingContent: 0,\n    rejectedEntries: 0,\n    totalEntries: 0,\n  }\n  const buckets = {}\n  for (const k in entries) {\n    /* istanbul ignore else */\n    if (hasOwnProperty(entries, k)) {\n      const hashed = index.hashKey(k)\n      const entry = entries[k]\n      const excluded = opts.filter && !opts.filter(entry)\n      excluded && stats.rejectedEntries++\n      if (buckets[hashed] && !excluded) {\n        buckets[hashed].push(entry)\n      } else if (buckets[hashed] && excluded) {\n        // skip\n      } else if (excluded) {\n        buckets[hashed] = []\n        buckets[hashed]._path = index.bucketPath(cache, k)\n      } else {\n        buckets[hashed] = [entry]\n        buckets[hashed]._path = index.bucketPath(cache, k)\n      }\n    }\n  }\n  await pMap(\n    Object.keys(buckets),\n    (key) => {\n      return rebuildBucket(cache, buckets[key], stats, opts)\n    },\n    { concurrency: opts.concurrency }\n  )\n  return stats\n}\n\nasync function rebuildBucket (cache, bucket, stats, opts) {\n  await truncate(bucket._path)\n  // This needs to be serialized because cacache explicitly\n  // lets very racy bucket conflicts clobber each other.\n  for (const entry of bucket) {\n    const content = contentPath(cache, entry.integrity)\n    try {\n      await stat(content)\n      await index.insert(cache, entry.key, entry.integrity, {\n        metadata: entry.metadata,\n        size: entry.size,\n        time: entry.time,\n      })\n      stats.totalEntries++\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        stats.rejectedEntries++\n        stats.missingContent++\n      } else {\n        throw err\n      }\n    }\n  }\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rm(path.join(cache, 'tmp'), { recursive: true, force: true })\n}\n\nasync function writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  return writeFile(verifile, `${Date.now()}`)\n}\n\nmodule.exports.lastRun = lastRun\n\nasync function lastRun (cache) {\n  const data = await readFile(path.join(cache, '_lastverified'), { encoding: 'utf8' })\n  return new Date(+data)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}