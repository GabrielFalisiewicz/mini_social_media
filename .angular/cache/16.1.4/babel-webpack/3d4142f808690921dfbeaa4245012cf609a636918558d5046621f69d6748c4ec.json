{"ast":null,"code":"\"use strict\";\n\n// parse a single path portion\nvar _classPrivateMethodInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodInitSpec.js\").default;\nvar _classPrivateFieldInitSpec = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldInitSpec.js\").default;\nvar _defineProperty = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classPrivateMethodGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateMethodGet.js\").default;\nvar _classStaticPrivateMethodGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classStaticPrivateMethodGet.js\").default;\nvar _classPrivateFieldGet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldGet.js\").default;\nvar _classPrivateFieldSet = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/classPrivateFieldSet.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AST = void 0;\nconst brace_expressions_js_1 = require(\"./brace-expressions.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = c => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nvar _root = /*#__PURE__*/new WeakMap();\nvar _hasMagic2 = /*#__PURE__*/new WeakMap();\nvar _uflag = /*#__PURE__*/new WeakMap();\nvar _parts = /*#__PURE__*/new WeakMap();\nvar _parent = /*#__PURE__*/new WeakMap();\nvar _parentIndex = /*#__PURE__*/new WeakMap();\nvar _negs = /*#__PURE__*/new WeakMap();\nvar _filledNegs = /*#__PURE__*/new WeakMap();\nvar _options = /*#__PURE__*/new WeakMap();\nvar _toString = /*#__PURE__*/new WeakMap();\nvar _emptyExt = /*#__PURE__*/new WeakMap();\nvar _fillNegs = /*#__PURE__*/new WeakSet();\nvar _partsToRegExp = /*#__PURE__*/new WeakSet();\nclass AST {\n  constructor(type, parent, options = {}) {\n    _classPrivateMethodInitSpec(this, _partsToRegExp);\n    _classPrivateMethodInitSpec(this, _fillNegs);\n    _defineProperty(this, \"type\", void 0);\n    _classPrivateFieldInitSpec(this, _root, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _hasMagic2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _uflag, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(this, _parts, {\n      writable: true,\n      value: []\n    });\n    _classPrivateFieldInitSpec(this, _parent, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _parentIndex, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _negs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filledNegs, {\n      writable: true,\n      value: false\n    });\n    _classPrivateFieldInitSpec(this, _options, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _toString, {\n      writable: true,\n      value: void 0\n    });\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    _classPrivateFieldInitSpec(this, _emptyExt, {\n      writable: true,\n      value: false\n    });\n    this.type = type;\n    // extglobs are inherently magical\n    if (type) _classPrivateFieldSet(this, _hasMagic2, true);\n    _classPrivateFieldSet(this, _parent, parent);\n    _classPrivateFieldSet(this, _root, _classPrivateFieldGet(this, _parent) ? _classPrivateFieldGet(_classPrivateFieldGet(this, _parent), _root) : this);\n    _classPrivateFieldSet(this, _options, _classPrivateFieldGet(this, _root) === this ? options : _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _options));\n    _classPrivateFieldSet(this, _negs, _classPrivateFieldGet(this, _root) === this ? [] : _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _negs));\n    if (type === '!' && !_classPrivateFieldGet(_classPrivateFieldGet(this, _root), _filledNegs)) _classPrivateFieldGet(this, _negs).push(this);\n    _classPrivateFieldSet(this, _parentIndex, _classPrivateFieldGet(this, _parent) ? _classPrivateFieldGet(_classPrivateFieldGet(this, _parent), _parts).length : 0);\n  }\n  get hasMagic() {\n    /* c8 ignore start */\n    if (_classPrivateFieldGet(this, _hasMagic2) !== undefined) return _classPrivateFieldGet(this, _hasMagic2);\n    /* c8 ignore stop */\n    for (const p of _classPrivateFieldGet(this, _parts)) {\n      if (typeof p === 'string') continue;\n      if (p.type || p.hasMagic) return _classPrivateFieldSet(this, _hasMagic2, true);\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return _classPrivateFieldGet(this, _hasMagic2);\n  }\n  // reconstructs the pattern\n  toString() {\n    if (_classPrivateFieldGet(this, _toString) !== undefined) return _classPrivateFieldGet(this, _toString);\n    if (!this.type) {\n      return _classPrivateFieldSet(this, _toString, _classPrivateFieldGet(this, _parts).map(p => String(p)).join(''));\n    } else {\n      return _classPrivateFieldSet(this, _toString, this.type + '(' + _classPrivateFieldGet(this, _parts).map(p => String(p)).join('|') + ')');\n    }\n  }\n  push(...parts) {\n    for (const p of parts) {\n      if (p === '') continue;\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && _classPrivateFieldGet(p, _parent) === this)) {\n        throw new Error('invalid part: ' + p);\n      }\n      /* c8 ignore stop */\n      _classPrivateFieldGet(this, _parts).push(p);\n    }\n  }\n  toJSON() {\n    const ret = this.type === null ? _classPrivateFieldGet(this, _parts).slice().map(p => typeof p === 'string' ? p : p.toJSON()) : [this.type, ..._classPrivateFieldGet(this, _parts).map(p => p.toJSON())];\n    if (this.isStart() && !this.type) ret.unshift([]);\n    if (this.isEnd() && (this === _classPrivateFieldGet(this, _root) || _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _filledNegs) && _classPrivateFieldGet(this, _parent)?.type === '!')) {\n      ret.push({});\n    }\n    return ret;\n  }\n  isStart() {\n    if (_classPrivateFieldGet(this, _root) === this) return true;\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!_classPrivateFieldGet(this, _parent)?.isStart()) return false;\n    if (_classPrivateFieldGet(this, _parentIndex) === 0) return true;\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = _classPrivateFieldGet(this, _parent);\n    for (let i = 0; i < _classPrivateFieldGet(this, _parentIndex); i++) {\n      const pp = _classPrivateFieldGet(p, _parts)[i];\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEnd() {\n    if (_classPrivateFieldGet(this, _root) === this) return true;\n    if (_classPrivateFieldGet(this, _parent)?.type === '!') return true;\n    if (!_classPrivateFieldGet(this, _parent)?.isEnd()) return false;\n    if (!this.type) return _classPrivateFieldGet(this, _parent)?.isEnd();\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = _classPrivateFieldGet(this, _parent) ? _classPrivateFieldGet(_classPrivateFieldGet(this, _parent), _parts).length : 0;\n    /* c8 ignore stop */\n    return _classPrivateFieldGet(this, _parentIndex) === pl - 1;\n  }\n  copyIn(part) {\n    if (typeof part === 'string') this.push(part);else this.push(part.clone(this));\n  }\n  clone(parent) {\n    const c = new AST(this.type, parent);\n    for (const p of _classPrivateFieldGet(this, _parts)) {\n      c.copyIn(p);\n    }\n    return c;\n  }\n  static fromGlob(pattern, options = {}) {\n    const ast = new AST(null, undefined, options);\n    _classStaticPrivateMethodGet(AST, AST, _parseAST).call(AST, pattern, ast, 0, options);\n    return ast;\n  }\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern() {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== _classPrivateFieldGet(this, _root)) return _classPrivateFieldGet(this, _root).toMMPattern();\n    /* c8 ignore stop */\n    const glob = this.toString();\n    const [re, body, hasMagic, uflag] = this.toRegExpSource();\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic = hasMagic || _classPrivateFieldGet(this, _hasMagic2) || _classPrivateFieldGet(this, _options).nocase && !_classPrivateFieldGet(this, _options).nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n    if (!anyMagic) {\n      return body;\n    }\n    const flags = (_classPrivateFieldGet(this, _options).nocase ? 'i' : '') + (uflag ? 'u' : '');\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob\n    });\n  }\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(allowDot) {\n    const dot = allowDot ?? !!_classPrivateFieldGet(this, _options).dot;\n    if (_classPrivateFieldGet(this, _root) === this) _classPrivateMethodGet(this, _fillNegs, _fillNegs2).call(this);\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd();\n      const src = _classPrivateFieldGet(this, _parts).map(p => {\n        const [re, _, hasMagic, uflag] = typeof p === 'string' ? _classStaticPrivateMethodGet(AST, AST, _parseGlob).call(AST, p, _classPrivateFieldGet(this, _hasMagic2), noEmpty) : p.toRegExpSource(allowDot);\n        _classPrivateFieldSet(this, _hasMagic2, _classPrivateFieldGet(this, _hasMagic2) || hasMagic);\n        _classPrivateFieldSet(this, _uflag, _classPrivateFieldGet(this, _uflag) || uflag);\n        return re;\n      }).join('');\n      let start = '';\n      if (this.isStart()) {\n        if (typeof _classPrivateFieldGet(this, _parts)[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed = _classPrivateFieldGet(this, _parts).length === 1 && justDots.has(_classPrivateFieldGet(this, _parts)[0]);\n          if (!dotTravAllowed) {\n            const aps = addPatternStart;\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n            // dots are allowed, and the pattern starts with [ or .\n            dot && aps.has(src.charAt(0)) ||\n            // the pattern starts with \\., and then [ or .\n            src.startsWith('\\\\.') && aps.has(src.charAt(2)) ||\n            // the pattern starts with \\.\\., and then [ or .\n            src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4));\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n          }\n        }\n      }\n      // append the \"end of path portion\" pattern to negation tails\n      let end = '';\n      if (this.isEnd() && _classPrivateFieldGet(_classPrivateFieldGet(this, _root), _filledNegs) && _classPrivateFieldGet(this, _parent)?.type === '!') {\n        end = '(?:$|\\\\/)';\n      }\n      const final = start + src + end;\n      return [final, (0, unescape_js_1.unescape)(src), _classPrivateFieldSet(this, _hasMagic2, !!_classPrivateFieldGet(this, _hasMagic2)), _classPrivateFieldGet(this, _uflag)];\n    }\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n    const repeated = this.type === '*' || this.type === '+';\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n    let body = _classPrivateMethodGet(this, _partsToRegExp, _partsToRegExp2).call(this, dot);\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString();\n      _classPrivateFieldSet(this, _parts, [s]);\n      this.type = null;\n      _classPrivateFieldSet(this, _hasMagic2, undefined);\n      return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n    }\n    // XXX abstract out this map method\n    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? '' : _classPrivateMethodGet(this, _partsToRegExp, _partsToRegExp2).call(this, true);\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = '';\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`;\n    }\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = '';\n    if (this.type === '!' && _classPrivateFieldGet(this, _emptyExt)) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n    } else {\n      const close = this.type === '!' ?\n      // !() must match something,but !(x) can match ''\n      '))' + (this.isStart() && !dot && !allowDot ? startNoDot : '') + star + ')' : this.type === '@' ? ')' : this.type === '?' ? ')?' : this.type === '+' && bodyDotAllowed ? ')' : this.type === '*' && bodyDotAllowed ? `)?` : `)${this.type}`;\n      final = start + body + close;\n    }\n    return [final, (0, unescape_js_1.unescape)(body), _classPrivateFieldSet(this, _hasMagic2, !!_classPrivateFieldGet(this, _hasMagic2)), _classPrivateFieldGet(this, _uflag)];\n  }\n}\nfunction _fillNegs2() {\n  /* c8 ignore start */\n  if (this !== _classPrivateFieldGet(this, _root)) throw new Error('should only call on root');\n  if (_classPrivateFieldGet(this, _filledNegs)) return this;\n  /* c8 ignore stop */\n  // call toString() once to fill this out\n  this.toString();\n  _classPrivateFieldSet(this, _filledNegs, true);\n  let n;\n  while (n = _classPrivateFieldGet(this, _negs).pop()) {\n    if (n.type !== '!') continue;\n    // walk up the tree, appending everthing that comes AFTER parentIndex\n    let p = n;\n    let pp = _classPrivateFieldGet(p, _parent);\n    while (pp) {\n      for (let i = _classPrivateFieldGet(p, _parentIndex) + 1; !pp.type && i < _classPrivateFieldGet(pp, _parts).length; i++) {\n        for (const part of _classPrivateFieldGet(n, _parts)) {\n          /* c8 ignore start */\n          if (typeof part === 'string') {\n            throw new Error('string part in extglob AST??');\n          }\n          /* c8 ignore stop */\n          part.copyIn(_classPrivateFieldGet(pp, _parts)[i]);\n        }\n      }\n      p = pp;\n      pp = _classPrivateFieldGet(p, _parent);\n    }\n  }\n  return this;\n}\nfunction _parseAST(str, ast, pos, opt) {\n  let escaping = false;\n  let inBrace = false;\n  let braceStart = -1;\n  let braceNeg = false;\n  if (ast.type === null) {\n    // outside of a extglob, append until we find a start\n    let i = pos;\n    let acc = '';\n    while (i < str.length) {\n      const c = str.charAt(i++);\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping;\n        acc += c;\n        continue;\n      }\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true;\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false;\n        }\n        acc += c;\n        continue;\n      } else if (c === '[') {\n        inBrace = true;\n        braceStart = i;\n        braceNeg = false;\n        acc += c;\n        continue;\n      }\n      if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n        ast.push(acc);\n        acc = '';\n        const ext = new AST(c, ast);\n        i = _classStaticPrivateMethodGet(AST, AST, _parseAST).call(AST, str, ext, i, opt);\n        ast.push(ext);\n        continue;\n      }\n      acc += c;\n    }\n    ast.push(acc);\n    return i;\n  }\n  // some kind of extglob, pos is at the (\n  // find the next | or )\n  let i = pos + 1;\n  let part = new AST(null, ast);\n  const parts = [];\n  let acc = '';\n  while (i < str.length) {\n    const c = str.charAt(i++);\n    // still accumulate escapes at this point, but we do ignore\n    // starts that are escaped\n    if (escaping || c === '\\\\') {\n      escaping = !escaping;\n      acc += c;\n      continue;\n    }\n    if (inBrace) {\n      if (i === braceStart + 1) {\n        if (c === '^' || c === '!') {\n          braceNeg = true;\n        }\n      } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n        inBrace = false;\n      }\n      acc += c;\n      continue;\n    } else if (c === '[') {\n      inBrace = true;\n      braceStart = i;\n      braceNeg = false;\n      acc += c;\n      continue;\n    }\n    if (isExtglobType(c) && str.charAt(i) === '(') {\n      part.push(acc);\n      acc = '';\n      const ext = new AST(c, part);\n      part.push(ext);\n      i = _classStaticPrivateMethodGet(AST, AST, _parseAST).call(AST, str, ext, i, opt);\n      continue;\n    }\n    if (c === '|') {\n      part.push(acc);\n      acc = '';\n      parts.push(part);\n      part = new AST(null, ast);\n      continue;\n    }\n    if (c === ')') {\n      if (acc === '' && _classPrivateFieldGet(ast, _parts).length === 0) {\n        _classPrivateFieldSet(ast, _emptyExt, true);\n      }\n      part.push(acc);\n      acc = '';\n      ast.push(...parts, part);\n      return i;\n    }\n    acc += c;\n  }\n  // unfinished extglob\n  // if we got here, it was a malformed extglob! not an extglob, but\n  // maybe something else in there.\n  ast.type = null;\n  _classPrivateFieldSet(ast, _hasMagic2, undefined);\n  _classPrivateFieldSet(ast, _parts, [str.substring(pos - 1)]);\n  return i;\n}\nfunction _partsToRegExp2(dot) {\n  return _classPrivateFieldGet(this, _parts).map(p => {\n    // extglob ASTs should only contain parent ASTs\n    /* c8 ignore start */\n    if (typeof p === 'string') {\n      throw new Error('string type in extglob ast??');\n    }\n    /* c8 ignore stop */\n    // can ignore hasMagic, because extglobs are already always magic\n    const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n    _classPrivateFieldSet(this, _uflag, _classPrivateFieldGet(this, _uflag) || uflag);\n    return re;\n  }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join('|');\n}\nfunction _parseGlob(glob, hasMagic, noEmpty = false) {\n  let escaping = false;\n  let re = '';\n  let uflag = false;\n  for (let i = 0; i < glob.length; i++) {\n    const c = glob.charAt(i);\n    if (escaping) {\n      escaping = false;\n      re += (reSpecials.has(c) ? '\\\\' : '') + c;\n      continue;\n    }\n    if (c === '\\\\') {\n      if (i === glob.length - 1) {\n        re += '\\\\\\\\';\n      } else {\n        escaping = true;\n      }\n      continue;\n    }\n    if (c === '[') {\n      const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n      if (consumed) {\n        re += src;\n        uflag = uflag || needUflag;\n        i += consumed - 1;\n        hasMagic = hasMagic || magic;\n        continue;\n      }\n    }\n    if (c === '*') {\n      if (noEmpty && glob === '*') re += starNoEmpty;else re += star;\n      hasMagic = true;\n      continue;\n    }\n    if (c === '?') {\n      re += qmark;\n      hasMagic = true;\n      continue;\n    }\n    re += regExpEscape(c);\n  }\n  return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n}\nexports.AST = AST;","map":{"version":3,"names":["_classPrivateMethodInitSpec","require","default","_classPrivateFieldInitSpec","_defineProperty","_classPrivateMethodGet","_classStaticPrivateMethodGet","_classPrivateFieldGet","_classPrivateFieldSet","Object","defineProperty","exports","value","AST","brace_expressions_js_1","unescape_js_1","types","Set","isExtglobType","c","has","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","s","replace","qmark","star","starNoEmpty","_root","WeakMap","_hasMagic2","_uflag","_parts","_parent","_parentIndex","_negs","_filledNegs","_options","_toString","_emptyExt","_fillNegs","WeakSet","_partsToRegExp","constructor","type","parent","options","writable","push","length","hasMagic","undefined","p","toString","map","String","join","parts","Error","toJSON","ret","slice","isStart","unshift","isEnd","i","pp","pl","copyIn","part","clone","fromGlob","pattern","ast","_parseAST","call","toMMPattern","glob","re","body","uflag","toRegExpSource","anyMagic","nocase","nocaseMagicOnly","toUpperCase","toLowerCase","flags","assign","RegExp","_src","_glob","allowDot","dot","_fillNegs2","noEmpty","src","_","_parseGlob","start","dotTravAllowed","aps","needNoTrav","charAt","startsWith","needNoDot","end","final","unescape","repeated","_partsToRegExp2","bodyDotAllowed","close","n","pop","str","pos","opt","escaping","inBrace","braceStart","braceNeg","acc","noext","ext","substring","_hasMagic","filter","needUflag","consumed","magic","parseClass"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/minimatch/dist/cjs/ast.js"],"sourcesContent":["\"use strict\";\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AST = void 0;\nconst brace_expressions_js_1 = require(\"./brace-expressions.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() && this.isEnd();\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                (0, unescape_js_1.unescape)(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            (0, unescape_js_1.unescape)(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                if (noEmpty && glob === '*')\n                    re += starNoEmpty;\n                else\n                    re += star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n    }\n}\nexports.AST = AST;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}