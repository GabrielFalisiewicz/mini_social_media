{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPublicKey = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst error_1 = require(\"../error\");\nconst oid_1 = require(\"./oid\");\nconst ASN1_TAG_SEQUENCE = 0x30;\nconst ANS1_TAG_BIT_STRING = 0x03;\nconst NULL_BYTE = 0x00;\nconst OID_EDDSA = '1.3.101.112';\nconst OID_EC_PUBLIC_KEY = '1.2.840.10045.2.1';\nconst OID_EC_CURVE_P256V1 = '1.2.840.10045.3.1.7';\nconst PEM_HEADER = '-----BEGIN PUBLIC KEY-----';\nfunction getPublicKey(keyInfo) {\n  switch (keyInfo.keyType) {\n    case 'rsa':\n      return getRSAPublicKey(keyInfo);\n    case 'ed25519':\n      return getED25519PublicKey(keyInfo);\n    case 'ecdsa':\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n      return getECDCSAPublicKey(keyInfo);\n    default:\n      throw new error_1.UnsupportedAlgorithmError(`Unsupported key type: ${keyInfo.keyType}`);\n  }\n}\nexports.getPublicKey = getPublicKey;\nfunction getRSAPublicKey(keyInfo) {\n  // Only support PEM-encoded RSA keys\n  if (!keyInfo.keyVal.startsWith(PEM_HEADER)) {\n    throw new error_1.CryptoError('Invalid key format');\n  }\n  const key = crypto_1.default.createPublicKey(keyInfo.keyVal);\n  switch (keyInfo.scheme) {\n    case 'rsassa-pss-sha256':\n      return {\n        key: key,\n        padding: crypto_1.default.constants.RSA_PKCS1_PSS_PADDING\n      };\n    default:\n      throw new error_1.UnsupportedAlgorithmError(`Unsupported RSA scheme: ${keyInfo.scheme}`);\n  }\n}\nfunction getED25519PublicKey(keyInfo) {\n  let key;\n  // If key is already PEM-encoded we can just parse it\n  if (keyInfo.keyVal.startsWith(PEM_HEADER)) {\n    key = crypto_1.default.createPublicKey(keyInfo.keyVal);\n  } else {\n    // If key is not PEM-encoded it had better be hex\n    if (!isHex(keyInfo.keyVal)) {\n      throw new error_1.CryptoError('Invalid key format');\n    }\n    key = crypto_1.default.createPublicKey({\n      key: ed25519.hexToDER(keyInfo.keyVal),\n      format: 'der',\n      type: 'spki'\n    });\n  }\n  return {\n    key\n  };\n}\nfunction getECDCSAPublicKey(keyInfo) {\n  let key;\n  // If key is already PEM-encoded we can just parse it\n  if (keyInfo.keyVal.startsWith(PEM_HEADER)) {\n    key = crypto_1.default.createPublicKey(keyInfo.keyVal);\n  } else {\n    // If key is not PEM-encoded it had better be hex\n    if (!isHex(keyInfo.keyVal)) {\n      throw new error_1.CryptoError('Invalid key format');\n    }\n    key = crypto_1.default.createPublicKey({\n      key: ecdsa.hexToDER(keyInfo.keyVal),\n      format: 'der',\n      type: 'spki'\n    });\n  }\n  return {\n    key\n  };\n}\nconst ed25519 = {\n  // Translates a hex key into a crypto KeyObject\n  // https://keygen.sh/blog/how-to-use-hexadecimal-ed25519-keys-in-node/\n  hexToDER: hex => {\n    const key = Buffer.from(hex, 'hex');\n    const oid = (0, oid_1.encodeOIDString)(OID_EDDSA);\n    // Create a byte sequence containing the OID and key\n    const elements = Buffer.concat([Buffer.concat([Buffer.from([ASN1_TAG_SEQUENCE]), Buffer.from([oid.length]), oid]), Buffer.concat([Buffer.from([ANS1_TAG_BIT_STRING]), Buffer.from([key.length + 1]), Buffer.from([NULL_BYTE]), key])]);\n    // Wrap up by creating a sequence of elements\n    const der = Buffer.concat([Buffer.from([ASN1_TAG_SEQUENCE]), Buffer.from([elements.length]), elements]);\n    return der;\n  }\n};\nconst ecdsa = {\n  hexToDER: hex => {\n    const key = Buffer.from(hex, 'hex');\n    const bitString = Buffer.concat([Buffer.from([ANS1_TAG_BIT_STRING]), Buffer.from([key.length + 1]), Buffer.from([NULL_BYTE]), key]);\n    const oids = Buffer.concat([(0, oid_1.encodeOIDString)(OID_EC_PUBLIC_KEY), (0, oid_1.encodeOIDString)(OID_EC_CURVE_P256V1)]);\n    const oidSequence = Buffer.concat([Buffer.from([ASN1_TAG_SEQUENCE]), Buffer.from([oids.length]), oids]);\n    // Wrap up by creating a sequence of elements\n    const der = Buffer.concat([Buffer.from([ASN1_TAG_SEQUENCE]), Buffer.from([oidSequence.length + bitString.length]), oidSequence, bitString]);\n    return der;\n  }\n};\nconst isHex = key => /^[0-9a-fA-F]+$/.test(key);","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","getPublicKey","crypto_1","require","error_1","oid_1","ASN1_TAG_SEQUENCE","ANS1_TAG_BIT_STRING","NULL_BYTE","OID_EDDSA","OID_EC_PUBLIC_KEY","OID_EC_CURVE_P256V1","PEM_HEADER","keyInfo","keyType","getRSAPublicKey","getED25519PublicKey","getECDCSAPublicKey","UnsupportedAlgorithmError","keyVal","startsWith","CryptoError","key","default","createPublicKey","scheme","padding","constants","RSA_PKCS1_PSS_PADDING","isHex","ed25519","hexToDER","format","type","ecdsa","hex","Buffer","from","oid","encodeOIDString","elements","concat","length","der","bitString","oids","oidSequence","test"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@tufjs/models/dist/utils/key.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPublicKey = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst error_1 = require(\"../error\");\nconst oid_1 = require(\"./oid\");\nconst ASN1_TAG_SEQUENCE = 0x30;\nconst ANS1_TAG_BIT_STRING = 0x03;\nconst NULL_BYTE = 0x00;\nconst OID_EDDSA = '1.3.101.112';\nconst OID_EC_PUBLIC_KEY = '1.2.840.10045.2.1';\nconst OID_EC_CURVE_P256V1 = '1.2.840.10045.3.1.7';\nconst PEM_HEADER = '-----BEGIN PUBLIC KEY-----';\nfunction getPublicKey(keyInfo) {\n    switch (keyInfo.keyType) {\n        case 'rsa':\n            return getRSAPublicKey(keyInfo);\n        case 'ed25519':\n            return getED25519PublicKey(keyInfo);\n        case 'ecdsa':\n        case 'ecdsa-sha2-nistp256':\n        case 'ecdsa-sha2-nistp384':\n            return getECDCSAPublicKey(keyInfo);\n        default:\n            throw new error_1.UnsupportedAlgorithmError(`Unsupported key type: ${keyInfo.keyType}`);\n    }\n}\nexports.getPublicKey = getPublicKey;\nfunction getRSAPublicKey(keyInfo) {\n    // Only support PEM-encoded RSA keys\n    if (!keyInfo.keyVal.startsWith(PEM_HEADER)) {\n        throw new error_1.CryptoError('Invalid key format');\n    }\n    const key = crypto_1.default.createPublicKey(keyInfo.keyVal);\n    switch (keyInfo.scheme) {\n        case 'rsassa-pss-sha256':\n            return {\n                key: key,\n                padding: crypto_1.default.constants.RSA_PKCS1_PSS_PADDING,\n            };\n        default:\n            throw new error_1.UnsupportedAlgorithmError(`Unsupported RSA scheme: ${keyInfo.scheme}`);\n    }\n}\nfunction getED25519PublicKey(keyInfo) {\n    let key;\n    // If key is already PEM-encoded we can just parse it\n    if (keyInfo.keyVal.startsWith(PEM_HEADER)) {\n        key = crypto_1.default.createPublicKey(keyInfo.keyVal);\n    }\n    else {\n        // If key is not PEM-encoded it had better be hex\n        if (!isHex(keyInfo.keyVal)) {\n            throw new error_1.CryptoError('Invalid key format');\n        }\n        key = crypto_1.default.createPublicKey({\n            key: ed25519.hexToDER(keyInfo.keyVal),\n            format: 'der',\n            type: 'spki',\n        });\n    }\n    return { key };\n}\nfunction getECDCSAPublicKey(keyInfo) {\n    let key;\n    // If key is already PEM-encoded we can just parse it\n    if (keyInfo.keyVal.startsWith(PEM_HEADER)) {\n        key = crypto_1.default.createPublicKey(keyInfo.keyVal);\n    }\n    else {\n        // If key is not PEM-encoded it had better be hex\n        if (!isHex(keyInfo.keyVal)) {\n            throw new error_1.CryptoError('Invalid key format');\n        }\n        key = crypto_1.default.createPublicKey({\n            key: ecdsa.hexToDER(keyInfo.keyVal),\n            format: 'der',\n            type: 'spki',\n        });\n    }\n    return { key };\n}\nconst ed25519 = {\n    // Translates a hex key into a crypto KeyObject\n    // https://keygen.sh/blog/how-to-use-hexadecimal-ed25519-keys-in-node/\n    hexToDER: (hex) => {\n        const key = Buffer.from(hex, 'hex');\n        const oid = (0, oid_1.encodeOIDString)(OID_EDDSA);\n        // Create a byte sequence containing the OID and key\n        const elements = Buffer.concat([\n            Buffer.concat([\n                Buffer.from([ASN1_TAG_SEQUENCE]),\n                Buffer.from([oid.length]),\n                oid,\n            ]),\n            Buffer.concat([\n                Buffer.from([ANS1_TAG_BIT_STRING]),\n                Buffer.from([key.length + 1]),\n                Buffer.from([NULL_BYTE]),\n                key,\n            ]),\n        ]);\n        // Wrap up by creating a sequence of elements\n        const der = Buffer.concat([\n            Buffer.from([ASN1_TAG_SEQUENCE]),\n            Buffer.from([elements.length]),\n            elements,\n        ]);\n        return der;\n    },\n};\nconst ecdsa = {\n    hexToDER: (hex) => {\n        const key = Buffer.from(hex, 'hex');\n        const bitString = Buffer.concat([\n            Buffer.from([ANS1_TAG_BIT_STRING]),\n            Buffer.from([key.length + 1]),\n            Buffer.from([NULL_BYTE]),\n            key,\n        ]);\n        const oids = Buffer.concat([\n            (0, oid_1.encodeOIDString)(OID_EC_PUBLIC_KEY),\n            (0, oid_1.encodeOIDString)(OID_EC_CURVE_P256V1),\n        ]);\n        const oidSequence = Buffer.concat([\n            Buffer.from([ASN1_TAG_SEQUENCE]),\n            Buffer.from([oids.length]),\n            oids,\n        ]);\n        // Wrap up by creating a sequence of elements\n        const der = Buffer.concat([\n            Buffer.from([ASN1_TAG_SEQUENCE]),\n            Buffer.from([oidSequence.length + bitString.length]),\n            oidSequence,\n            bitString,\n        ]);\n        return der;\n    },\n};\nconst isHex = (key) => /^[0-9a-fA-F]+$/.test(key);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}