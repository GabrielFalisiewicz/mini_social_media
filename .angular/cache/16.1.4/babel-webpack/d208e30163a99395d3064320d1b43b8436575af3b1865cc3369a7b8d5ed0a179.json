{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Root = void 0;\nconst util_1 = __importDefault(require(\"util\"));\nconst base_1 = require(\"./base\");\nconst error_1 = require(\"./error\");\nconst key_1 = require(\"./key\");\nconst role_1 = require(\"./role\");\nconst utils_1 = require(\"./utils\");\n/**\n * A container for the signed part of root metadata.\n *\n * The top-level role and metadata file signed by the root keys.\n * This role specifies trusted keys for all other top-level roles, which may further delegate trust.\n */\nclass Root extends base_1.Signed {\n  constructor(options) {\n    super(options);\n    this.type = base_1.MetadataKind.Root;\n    this.keys = options.keys || {};\n    this.consistentSnapshot = options.consistentSnapshot ?? true;\n    if (!options.roles) {\n      this.roles = role_1.TOP_LEVEL_ROLE_NAMES.reduce((acc, role) => ({\n        ...acc,\n        [role]: new role_1.Role({\n          keyIDs: [],\n          threshold: 1\n        })\n      }), {});\n    } else {\n      const roleNames = new Set(Object.keys(options.roles));\n      if (!role_1.TOP_LEVEL_ROLE_NAMES.every(role => roleNames.has(role))) {\n        throw new error_1.ValueError('missing top-level role');\n      }\n      this.roles = options.roles;\n    }\n  }\n  addKey(key, role) {\n    if (!this.roles[role]) {\n      throw new error_1.ValueError(`role ${role} does not exist`);\n    }\n    if (!this.roles[role].keyIDs.includes(key.keyID)) {\n      this.roles[role].keyIDs.push(key.keyID);\n    }\n    this.keys[key.keyID] = key;\n  }\n  equals(other) {\n    if (!(other instanceof Root)) {\n      return false;\n    }\n    return super.equals(other) && this.consistentSnapshot === other.consistentSnapshot && util_1.default.isDeepStrictEqual(this.keys, other.keys) && util_1.default.isDeepStrictEqual(this.roles, other.roles);\n  }\n  toJSON() {\n    return {\n      _type: this.type,\n      spec_version: this.specVersion,\n      version: this.version,\n      expires: this.expires,\n      keys: keysToJSON(this.keys),\n      roles: rolesToJSON(this.roles),\n      consistent_snapshot: this.consistentSnapshot,\n      ...this.unrecognizedFields\n    };\n  }\n  static fromJSON(data) {\n    const {\n      unrecognizedFields,\n      ...commonFields\n    } = base_1.Signed.commonFieldsFromJSON(data);\n    const {\n      keys,\n      roles,\n      consistent_snapshot,\n      ...rest\n    } = unrecognizedFields;\n    if (typeof consistent_snapshot !== 'boolean') {\n      throw new TypeError('consistent_snapshot must be a boolean');\n    }\n    return new Root({\n      ...commonFields,\n      keys: keysFromJSON(keys),\n      roles: rolesFromJSON(roles),\n      consistentSnapshot: consistent_snapshot,\n      unrecognizedFields: rest\n    });\n  }\n}\nexports.Root = Root;\nfunction keysToJSON(keys) {\n  return Object.entries(keys).reduce((acc, [keyID, key]) => ({\n    ...acc,\n    [keyID]: key.toJSON()\n  }), {});\n}\nfunction rolesToJSON(roles) {\n  return Object.entries(roles).reduce((acc, [roleName, role]) => ({\n    ...acc,\n    [roleName]: role.toJSON()\n  }), {});\n}\nfunction keysFromJSON(data) {\n  let keys;\n  if (utils_1.guard.isDefined(data)) {\n    if (!utils_1.guard.isObjectRecord(data)) {\n      throw new TypeError('keys must be an object');\n    }\n    keys = Object.entries(data).reduce((acc, [keyID, keyData]) => ({\n      ...acc,\n      [keyID]: key_1.Key.fromJSON(keyID, keyData)\n    }), {});\n  }\n  return keys;\n}\nfunction rolesFromJSON(data) {\n  let roles;\n  if (utils_1.guard.isDefined(data)) {\n    if (!utils_1.guard.isObjectRecord(data)) {\n      throw new TypeError('roles must be an object');\n    }\n    roles = Object.entries(data).reduce((acc, [roleName, roleData]) => ({\n      ...acc,\n      [roleName]: role_1.Role.fromJSON(roleData)\n    }), {});\n  }\n  return roles;\n}","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Root","util_1","require","base_1","error_1","key_1","role_1","utils_1","Signed","constructor","options","type","MetadataKind","keys","consistentSnapshot","roles","TOP_LEVEL_ROLE_NAMES","reduce","acc","role","Role","keyIDs","threshold","roleNames","Set","every","has","ValueError","addKey","key","includes","keyID","push","equals","other","default","isDeepStrictEqual","toJSON","_type","spec_version","specVersion","version","expires","keysToJSON","rolesToJSON","consistent_snapshot","unrecognizedFields","fromJSON","data","commonFields","commonFieldsFromJSON","rest","TypeError","keysFromJSON","rolesFromJSON","entries","roleName","guard","isDefined","isObjectRecord","keyData","Key","roleData"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@tufjs/models/dist/root.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Root = void 0;\nconst util_1 = __importDefault(require(\"util\"));\nconst base_1 = require(\"./base\");\nconst error_1 = require(\"./error\");\nconst key_1 = require(\"./key\");\nconst role_1 = require(\"./role\");\nconst utils_1 = require(\"./utils\");\n/**\n * A container for the signed part of root metadata.\n *\n * The top-level role and metadata file signed by the root keys.\n * This role specifies trusted keys for all other top-level roles, which may further delegate trust.\n */\nclass Root extends base_1.Signed {\n    constructor(options) {\n        super(options);\n        this.type = base_1.MetadataKind.Root;\n        this.keys = options.keys || {};\n        this.consistentSnapshot = options.consistentSnapshot ?? true;\n        if (!options.roles) {\n            this.roles = role_1.TOP_LEVEL_ROLE_NAMES.reduce((acc, role) => ({\n                ...acc,\n                [role]: new role_1.Role({ keyIDs: [], threshold: 1 }),\n            }), {});\n        }\n        else {\n            const roleNames = new Set(Object.keys(options.roles));\n            if (!role_1.TOP_LEVEL_ROLE_NAMES.every((role) => roleNames.has(role))) {\n                throw new error_1.ValueError('missing top-level role');\n            }\n            this.roles = options.roles;\n        }\n    }\n    addKey(key, role) {\n        if (!this.roles[role]) {\n            throw new error_1.ValueError(`role ${role} does not exist`);\n        }\n        if (!this.roles[role].keyIDs.includes(key.keyID)) {\n            this.roles[role].keyIDs.push(key.keyID);\n        }\n        this.keys[key.keyID] = key;\n    }\n    equals(other) {\n        if (!(other instanceof Root)) {\n            return false;\n        }\n        return (super.equals(other) &&\n            this.consistentSnapshot === other.consistentSnapshot &&\n            util_1.default.isDeepStrictEqual(this.keys, other.keys) &&\n            util_1.default.isDeepStrictEqual(this.roles, other.roles));\n    }\n    toJSON() {\n        return {\n            _type: this.type,\n            spec_version: this.specVersion,\n            version: this.version,\n            expires: this.expires,\n            keys: keysToJSON(this.keys),\n            roles: rolesToJSON(this.roles),\n            consistent_snapshot: this.consistentSnapshot,\n            ...this.unrecognizedFields,\n        };\n    }\n    static fromJSON(data) {\n        const { unrecognizedFields, ...commonFields } = base_1.Signed.commonFieldsFromJSON(data);\n        const { keys, roles, consistent_snapshot, ...rest } = unrecognizedFields;\n        if (typeof consistent_snapshot !== 'boolean') {\n            throw new TypeError('consistent_snapshot must be a boolean');\n        }\n        return new Root({\n            ...commonFields,\n            keys: keysFromJSON(keys),\n            roles: rolesFromJSON(roles),\n            consistentSnapshot: consistent_snapshot,\n            unrecognizedFields: rest,\n        });\n    }\n}\nexports.Root = Root;\nfunction keysToJSON(keys) {\n    return Object.entries(keys).reduce((acc, [keyID, key]) => ({ ...acc, [keyID]: key.toJSON() }), {});\n}\nfunction rolesToJSON(roles) {\n    return Object.entries(roles).reduce((acc, [roleName, role]) => ({ ...acc, [roleName]: role.toJSON() }), {});\n}\nfunction keysFromJSON(data) {\n    let keys;\n    if (utils_1.guard.isDefined(data)) {\n        if (!utils_1.guard.isObjectRecord(data)) {\n            throw new TypeError('keys must be an object');\n        }\n        keys = Object.entries(data).reduce((acc, [keyID, keyData]) => ({\n            ...acc,\n            [keyID]: key_1.Key.fromJSON(keyID, keyData),\n        }), {});\n    }\n    return keys;\n}\nfunction rolesFromJSON(data) {\n    let roles;\n    if (utils_1.guard.isDefined(data)) {\n        if (!utils_1.guard.isObjectRecord(data)) {\n            throw new TypeError('roles must be an object');\n        }\n        roles = Object.entries(data).reduce((acc, [roleName, roleData]) => ({\n            ...acc,\n            [roleName]: role_1.Role.fromJSON(roleData),\n        }), {});\n    }\n    return roles;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}