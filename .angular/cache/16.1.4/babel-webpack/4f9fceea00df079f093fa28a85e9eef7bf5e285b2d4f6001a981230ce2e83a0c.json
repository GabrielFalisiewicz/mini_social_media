{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyTLogSET = void 0;\nconst util_1 = require(\"../../util\");\n// Verifies the SET for the given entry against the list of trusted\n// transparency logs. Returns true if the SET can be verified against at least\n// one of the trusted logs; otherwise, returns false.\nfunction verifyTLogSET(entry, tlogs) {\n  // Filter the list of tlog instances to only those which might be able to\n  // verify the SET\n  const validTLogs = filterTLogInstances(tlogs, entry.logId.keyId, entry.integratedTime);\n  // Check to see if we can verify the SET against any of the valid tlogs\n  return validTLogs.some(tlog => {\n    if (!tlog.publicKey?.rawBytes) {\n      return false;\n    }\n    const publicKey = util_1.crypto.createPublicKey(tlog.publicKey.rawBytes);\n    // Re-create the original Rekor verification payload\n    const payload = toVerificationPayload(entry);\n    // Canonicalize the payload and turn into a buffer for verification\n    const data = Buffer.from(util_1.json.canonicalize(payload), 'utf8');\n    // Extract the SET from the tlog entry\n    const signature = entry.inclusionPromise.signedEntryTimestamp;\n    return util_1.crypto.verifyBlob(data, publicKey, signature);\n  });\n}\nexports.verifyTLogSET = verifyTLogSET;\n// Returns a properly formatted \"VerificationPayload\" for one of the\n// transaction log entires in the given bundle which can be used for SET\n// verification.\nfunction toVerificationPayload(entry) {\n  const {\n    integratedTime,\n    logIndex,\n    logId,\n    canonicalizedBody\n  } = entry;\n  return {\n    body: canonicalizedBody.toString('base64'),\n    integratedTime: Number(integratedTime),\n    logIndex: Number(logIndex),\n    logID: logId.keyId.toString('hex')\n  };\n}\n// Filter the list of tlog instances to only those which match the given log\n// ID and have public keys which are valid for the given integrated time.\nfunction filterTLogInstances(tlogInstances, logID, integratedTime) {\n  const targetDate = new Date(Number(integratedTime) * 1000);\n  return tlogInstances.filter(tlog => {\n    // If the log IDs don't match, we can't use this tlog\n    if (!tlog.logId?.keyId.equals(logID)) {\n      return false;\n    }\n    // If the tlog doesn't have a public key, we can't use it\n    const publicKey = tlog.publicKey;\n    if (publicKey === undefined) {\n      return false;\n    }\n    // If the tlog doesn't have a rawBytes field, we can't use it\n    if (publicKey.rawBytes === undefined) {\n      return false;\n    }\n    // If the tlog doesn't have a validFor field, we don't need to check it\n    if (publicKey.validFor === undefined) {\n      return true;\n    }\n    // Check that the integrated time is within the validFor range\n    return publicKey.validFor.start && publicKey.validFor.start <= targetDate && (!publicKey.validFor.end || targetDate <= publicKey.validFor.end);\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","verifyTLogSET","util_1","require","entry","tlogs","validTLogs","filterTLogInstances","logId","keyId","integratedTime","some","tlog","publicKey","rawBytes","crypto","createPublicKey","payload","toVerificationPayload","data","Buffer","from","json","canonicalize","signature","inclusionPromise","signedEntryTimestamp","verifyBlob","logIndex","canonicalizedBody","body","toString","Number","logID","tlogInstances","targetDate","Date","filter","equals","undefined","validFor","start","end"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/tlog/verify/set.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyTLogSET = void 0;\nconst util_1 = require(\"../../util\");\n// Verifies the SET for the given entry against the list of trusted\n// transparency logs. Returns true if the SET can be verified against at least\n// one of the trusted logs; otherwise, returns false.\nfunction verifyTLogSET(entry, tlogs) {\n    // Filter the list of tlog instances to only those which might be able to\n    // verify the SET\n    const validTLogs = filterTLogInstances(tlogs, entry.logId.keyId, entry.integratedTime);\n    // Check to see if we can verify the SET against any of the valid tlogs\n    return validTLogs.some((tlog) => {\n        if (!tlog.publicKey?.rawBytes) {\n            return false;\n        }\n        const publicKey = util_1.crypto.createPublicKey(tlog.publicKey.rawBytes);\n        // Re-create the original Rekor verification payload\n        const payload = toVerificationPayload(entry);\n        // Canonicalize the payload and turn into a buffer for verification\n        const data = Buffer.from(util_1.json.canonicalize(payload), 'utf8');\n        // Extract the SET from the tlog entry\n        const signature = entry.inclusionPromise.signedEntryTimestamp;\n        return util_1.crypto.verifyBlob(data, publicKey, signature);\n    });\n}\nexports.verifyTLogSET = verifyTLogSET;\n// Returns a properly formatted \"VerificationPayload\" for one of the\n// transaction log entires in the given bundle which can be used for SET\n// verification.\nfunction toVerificationPayload(entry) {\n    const { integratedTime, logIndex, logId, canonicalizedBody } = entry;\n    return {\n        body: canonicalizedBody.toString('base64'),\n        integratedTime: Number(integratedTime),\n        logIndex: Number(logIndex),\n        logID: logId.keyId.toString('hex'),\n    };\n}\n// Filter the list of tlog instances to only those which match the given log\n// ID and have public keys which are valid for the given integrated time.\nfunction filterTLogInstances(tlogInstances, logID, integratedTime) {\n    const targetDate = new Date(Number(integratedTime) * 1000);\n    return tlogInstances.filter((tlog) => {\n        // If the log IDs don't match, we can't use this tlog\n        if (!tlog.logId?.keyId.equals(logID)) {\n            return false;\n        }\n        // If the tlog doesn't have a public key, we can't use it\n        const publicKey = tlog.publicKey;\n        if (publicKey === undefined) {\n            return false;\n        }\n        // If the tlog doesn't have a rawBytes field, we can't use it\n        if (publicKey.rawBytes === undefined) {\n            return false;\n        }\n        // If the tlog doesn't have a validFor field, we don't need to check it\n        if (publicKey.validFor === undefined) {\n            return true;\n        }\n        // Check that the integrated time is within the validFor range\n        return (publicKey.validFor.start &&\n            publicKey.validFor.start <= targetDate &&\n            (!publicKey.validFor.end || targetDate <= publicKey.validFor.end));\n    });\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,aAAa,GAAG,KAAK,CAAC;AAC9B,MAAMC,MAAM,GAAGC,OAAO,CAAC,YAAY,CAAC;AACpC;AACA;AACA;AACA,SAASF,aAAaA,CAACG,KAAK,EAAEC,KAAK,EAAE;EACjC;EACA;EACA,MAAMC,UAAU,GAAGC,mBAAmB,CAACF,KAAK,EAAED,KAAK,CAACI,KAAK,CAACC,KAAK,EAAEL,KAAK,CAACM,cAAc,CAAC;EACtF;EACA,OAAOJ,UAAU,CAACK,IAAI,CAAEC,IAAI,IAAK;IAC7B,IAAI,CAACA,IAAI,CAACC,SAAS,EAAEC,QAAQ,EAAE;MAC3B,OAAO,KAAK;IAChB;IACA,MAAMD,SAAS,GAAGX,MAAM,CAACa,MAAM,CAACC,eAAe,CAACJ,IAAI,CAACC,SAAS,CAACC,QAAQ,CAAC;IACxE;IACA,MAAMG,OAAO,GAAGC,qBAAqB,CAACd,KAAK,CAAC;IAC5C;IACA,MAAMe,IAAI,GAAGC,MAAM,CAACC,IAAI,CAACnB,MAAM,CAACoB,IAAI,CAACC,YAAY,CAACN,OAAO,CAAC,EAAE,MAAM,CAAC;IACnE;IACA,MAAMO,SAAS,GAAGpB,KAAK,CAACqB,gBAAgB,CAACC,oBAAoB;IAC7D,OAAOxB,MAAM,CAACa,MAAM,CAACY,UAAU,CAACR,IAAI,EAAEN,SAAS,EAAEW,SAAS,CAAC;EAC/D,CAAC,CAAC;AACN;AACAzB,OAAO,CAACE,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA,SAASiB,qBAAqBA,CAACd,KAAK,EAAE;EAClC,MAAM;IAAEM,cAAc;IAAEkB,QAAQ;IAAEpB,KAAK;IAAEqB;EAAkB,CAAC,GAAGzB,KAAK;EACpE,OAAO;IACH0B,IAAI,EAAED,iBAAiB,CAACE,QAAQ,CAAC,QAAQ,CAAC;IAC1CrB,cAAc,EAAEsB,MAAM,CAACtB,cAAc,CAAC;IACtCkB,QAAQ,EAAEI,MAAM,CAACJ,QAAQ,CAAC;IAC1BK,KAAK,EAAEzB,KAAK,CAACC,KAAK,CAACsB,QAAQ,CAAC,KAAK;EACrC,CAAC;AACL;AACA;AACA;AACA,SAASxB,mBAAmBA,CAAC2B,aAAa,EAAED,KAAK,EAAEvB,cAAc,EAAE;EAC/D,MAAMyB,UAAU,GAAG,IAAIC,IAAI,CAACJ,MAAM,CAACtB,cAAc,CAAC,GAAG,IAAI,CAAC;EAC1D,OAAOwB,aAAa,CAACG,MAAM,CAAEzB,IAAI,IAAK;IAClC;IACA,IAAI,CAACA,IAAI,CAACJ,KAAK,EAAEC,KAAK,CAAC6B,MAAM,CAACL,KAAK,CAAC,EAAE;MAClC,OAAO,KAAK;IAChB;IACA;IACA,MAAMpB,SAAS,GAAGD,IAAI,CAACC,SAAS;IAChC,IAAIA,SAAS,KAAK0B,SAAS,EAAE;MACzB,OAAO,KAAK;IAChB;IACA;IACA,IAAI1B,SAAS,CAACC,QAAQ,KAAKyB,SAAS,EAAE;MAClC,OAAO,KAAK;IAChB;IACA;IACA,IAAI1B,SAAS,CAAC2B,QAAQ,KAAKD,SAAS,EAAE;MAClC,OAAO,IAAI;IACf;IACA;IACA,OAAQ1B,SAAS,CAAC2B,QAAQ,CAACC,KAAK,IAC5B5B,SAAS,CAAC2B,QAAQ,CAACC,KAAK,IAAIN,UAAU,KACrC,CAACtB,SAAS,CAAC2B,QAAQ,CAACE,GAAG,IAAIP,UAAU,IAAItB,SAAS,CAAC2B,QAAQ,CAACE,GAAG,CAAC;EACzE,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"script","externalDependencies":[]}