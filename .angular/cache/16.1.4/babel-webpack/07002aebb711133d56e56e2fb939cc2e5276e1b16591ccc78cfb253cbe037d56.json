{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.x509Certificate = void 0;\nconst util_1 = require(\"../util\");\nconst asn1_1 = require(\"../util/asn1\");\nconst stream_1 = require(\"../util/stream\");\nconst ext_1 = require(\"./ext\");\nconst EXTENSION_OID_SUBJECT_KEY_ID = '2.5.29.14';\nconst EXTENSION_OID_KEY_USAGE = '2.5.29.15';\nconst EXTENSION_OID_SUBJECT_ALT_NAME = '2.5.29.17';\nconst EXTENSION_OID_BASIC_CONSTRAINTS = '2.5.29.19';\nconst EXTENSION_OID_AUTHORITY_KEY_ID = '2.5.29.35';\nconst EXTENSION_OID_SCT = '1.3.6.1.4.1.11129.2.4.2';\n// List of recognized critical extensions\n// https://www.rfc-editor.org/rfc/rfc5280#section-4.2\nconst RECOGNIZED_EXTENSIONS = [EXTENSION_OID_KEY_USAGE, EXTENSION_OID_BASIC_CONSTRAINTS, EXTENSION_OID_SUBJECT_ALT_NAME];\nconst ECDSA_SIGNATURE_ALGOS = {\n  '1.2.840.10045.4.3.1': 'sha224',\n  '1.2.840.10045.4.3.2': 'sha256',\n  '1.2.840.10045.4.3.3': 'sha384',\n  '1.2.840.10045.4.3.4': 'sha512'\n};\nclass x509Certificate {\n  constructor(asn1) {\n    this.root = asn1;\n    if (!this.checkRecognizedExtensions()) {\n      throw new Error('Certificate contains unrecognized critical extensions');\n    }\n  }\n  static parse(cert) {\n    const der = typeof cert === 'string' ? util_1.pem.toDER(cert) : cert;\n    const asn1 = asn1_1.ASN1Obj.parseBuffer(der);\n    return new x509Certificate(asn1);\n  }\n  get tbsCertificate() {\n    return this.tbsCertificateObj;\n  }\n  get version() {\n    // version number is the first element of the version context specific tag\n    const ver = this.versionObj.subs[0].toInteger();\n    return `v${(ver + BigInt(1)).toString()}`;\n  }\n  get notBefore() {\n    // notBefore is the first element of the validity sequence\n    return this.validityObj.subs[0].toDate();\n  }\n  get notAfter() {\n    // notAfter is the second element of the validity sequence\n    return this.validityObj.subs[1].toDate();\n  }\n  get issuer() {\n    return this.issuerObj.value;\n  }\n  get subject() {\n    return this.subjectObj.value;\n  }\n  get publicKey() {\n    return this.subjectPublicKeyInfoObj.toDER();\n  }\n  get signatureAlgorithm() {\n    const oid = this.signatureAlgorithmObj.subs[0].toOID();\n    return ECDSA_SIGNATURE_ALGOS[oid];\n  }\n  get signatureValue() {\n    // Signature value is a bit string, so we need to skip the first byte\n    return this.signatureValueObj.value.subarray(1);\n  }\n  get extensions() {\n    // The extension list is the first (and only) element of the extensions\n    // context specific tag\n    const extSeq = this.extensionsObj?.subs[0];\n    return extSeq?.subs || [];\n  }\n  get extKeyUsage() {\n    const ext = this.findExtension(EXTENSION_OID_KEY_USAGE);\n    return ext ? new ext_1.x509KeyUsageExtension(ext) : undefined;\n  }\n  get extBasicConstraints() {\n    const ext = this.findExtension(EXTENSION_OID_BASIC_CONSTRAINTS);\n    return ext ? new ext_1.x509BasicConstraintsExtension(ext) : undefined;\n  }\n  get extSubjectAltName() {\n    const ext = this.findExtension(EXTENSION_OID_SUBJECT_ALT_NAME);\n    return ext ? new ext_1.x509SubjectAlternativeNameExtension(ext) : undefined;\n  }\n  get extAuthorityKeyID() {\n    const ext = this.findExtension(EXTENSION_OID_AUTHORITY_KEY_ID);\n    return ext ? new ext_1.x509AuthorityKeyIDExtension(ext) : undefined;\n  }\n  get extSubjectKeyID() {\n    const ext = this.findExtension(EXTENSION_OID_SUBJECT_KEY_ID);\n    return ext ? new ext_1.x509SubjectKeyIDExtension(ext) : undefined;\n  }\n  get extSCT() {\n    const ext = this.findExtension(EXTENSION_OID_SCT);\n    return ext ? new ext_1.x509SCTExtension(ext) : undefined;\n  }\n  get isCA() {\n    const ca = this.extBasicConstraints?.isCA || false;\n    // If the KeyUsage extension is present, keyCertSign must be set\n    if (this.extKeyUsage) {\n      ca && this.extKeyUsage.keyCertSign;\n    }\n    return ca;\n  }\n  extension(oid) {\n    const ext = this.findExtension(oid);\n    return ext ? new ext_1.x509Extension(ext) : undefined;\n  }\n  verify(issuerCertificate) {\n    // Use the issuer's public key if provided, otherwise use the subject's\n    const publicKey = issuerCertificate?.publicKey || this.publicKey;\n    const key = util_1.crypto.createPublicKey(publicKey);\n    return util_1.crypto.verifyBlob(this.tbsCertificate.toDER(), key, this.signatureValue, this.signatureAlgorithm);\n  }\n  validForDate(date) {\n    return this.notBefore <= date && date <= this.notAfter;\n  }\n  equals(other) {\n    return this.root.toDER().equals(other.root.toDER());\n  }\n  verifySCTs(issuer, logs) {\n    let extSCT;\n    // Verifying the SCT requires that we remove the SCT extension and\n    // re-encode the TBS structure to DER -- this value is part of the data\n    // over which the signature is calculated. Since this is a destructive action\n    // we create a copy of the certificate so we can remove the SCT extension\n    // without affecting the original certificate.\n    const clone = this.clone();\n    // Intentionally not using the findExtension method here because we want to\n    // remove the the SCT extension from the certificate before calculating the\n    // PreCert structure\n    for (let i = 0; i < clone.extensions.length; i++) {\n      const ext = clone.extensions[i];\n      if (ext.subs[0].toOID() === EXTENSION_OID_SCT) {\n        extSCT = new ext_1.x509SCTExtension(ext);\n        // Remove the extension from the certificate\n        clone.extensions.splice(i, 1);\n        break;\n      }\n    }\n    if (!extSCT) {\n      throw new Error('Certificate does not contain SCT extension');\n    }\n    if (extSCT?.signedCertificateTimestamps?.length === 0) {\n      throw new Error('Certificate does not contain any SCTs');\n    }\n    // Construct the PreCert structure\n    // https://www.rfc-editor.org/rfc/rfc6962#section-3.2\n    const preCert = new stream_1.ByteStream();\n    // Calculate hash of the issuer's public key\n    const issuerId = util_1.crypto.hash(issuer.publicKey);\n    preCert.appendView(issuerId);\n    // Re-encodes the certificate to DER after removing the SCT extension\n    const tbs = clone.tbsCertificate.toDER();\n    preCert.appendUint24(tbs.length);\n    preCert.appendView(tbs);\n    // Calculate and return the verification results for each SCT\n    return extSCT.signedCertificateTimestamps.map(sct => ({\n      logID: sct.logID,\n      verified: sct.verify(preCert.buffer, logs)\n    }));\n  }\n  // Creates a copy of the certificate with a new buffer\n  clone() {\n    const der = this.root.toDER();\n    const clone = Buffer.alloc(der.length);\n    der.copy(clone);\n    return x509Certificate.parse(clone);\n  }\n  findExtension(oid) {\n    // Find the extension with the given OID. The OID will always be the first\n    // element of the extension sequence\n    return this.extensions.find(ext => ext.subs[0].toOID() === oid);\n  }\n  // A certificate should be considered invalid if it contains critical\n  // extensions that are not recognized\n  checkRecognizedExtensions() {\n    // The extension list is the first (and only) element of the extensions\n    // context specific tag\n    const extSeq = this.extensionsObj?.subs[0];\n    const exts = extSeq?.subs.map(ext => new ext_1.x509Extension(ext));\n    // Check for unrecognized critical extensions\n    return !exts || exts.every(ext => !ext.critical || RECOGNIZED_EXTENSIONS.includes(ext.oid));\n  }\n  /////////////////////////////////////////////////////////////////////////////\n  // The following properties use the documented x509 structure to locate the\n  // desired ASN.1 object\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.1\n  get tbsCertificateObj() {\n    // tbsCertificate is the first element of the certificate sequence\n    return this.root.subs[0];\n  }\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.2\n  get signatureAlgorithmObj() {\n    // signatureAlgorithm is the second element of the certificate sequence\n    return this.root.subs[1];\n  }\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.3\n  get signatureValueObj() {\n    // signatureValue is the third element of the certificate sequence\n    return this.root.subs[2];\n  }\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.1\n  get versionObj() {\n    // version is the first element of the tbsCertificate sequence\n    return this.tbsCertificateObj.subs[0];\n  }\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.4\n  get issuerObj() {\n    // issuer is the fourth element of the tbsCertificate sequence\n    return this.tbsCertificateObj.subs[3];\n  }\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.5\n  get validityObj() {\n    // version is the fifth element of the tbsCertificate sequence\n    return this.tbsCertificateObj.subs[4];\n  }\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.6\n  get subjectObj() {\n    // subject is the sixth element of the tbsCertificate sequence\n    return this.tbsCertificateObj.subs[5];\n  }\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.7\n  get subjectPublicKeyInfoObj() {\n    // subjectPublicKeyInfo is the seventh element of the tbsCertificate sequence\n    return this.tbsCertificateObj.subs[6];\n  }\n  // Extensions can't be located by index because their position varies. Instead,\n  // we need to find the extensions context specific tag\n  // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.9\n  get extensionsObj() {\n    return this.tbsCertificateObj.subs.find(sub => sub.tag.isContextSpecific(0x03));\n  }\n}\nexports.x509Certificate = x509Certificate;","map":{"version":3,"names":["Object","defineProperty","exports","value","x509Certificate","util_1","require","asn1_1","stream_1","ext_1","EXTENSION_OID_SUBJECT_KEY_ID","EXTENSION_OID_KEY_USAGE","EXTENSION_OID_SUBJECT_ALT_NAME","EXTENSION_OID_BASIC_CONSTRAINTS","EXTENSION_OID_AUTHORITY_KEY_ID","EXTENSION_OID_SCT","RECOGNIZED_EXTENSIONS","ECDSA_SIGNATURE_ALGOS","constructor","asn1","root","checkRecognizedExtensions","Error","parse","cert","der","pem","toDER","ASN1Obj","parseBuffer","tbsCertificate","tbsCertificateObj","version","ver","versionObj","subs","toInteger","BigInt","toString","notBefore","validityObj","toDate","notAfter","issuer","issuerObj","subject","subjectObj","publicKey","subjectPublicKeyInfoObj","signatureAlgorithm","oid","signatureAlgorithmObj","toOID","signatureValue","signatureValueObj","subarray","extensions","extSeq","extensionsObj","extKeyUsage","ext","findExtension","x509KeyUsageExtension","undefined","extBasicConstraints","x509BasicConstraintsExtension","extSubjectAltName","x509SubjectAlternativeNameExtension","extAuthorityKeyID","x509AuthorityKeyIDExtension","extSubjectKeyID","x509SubjectKeyIDExtension","extSCT","x509SCTExtension","isCA","ca","keyCertSign","extension","x509Extension","verify","issuerCertificate","key","crypto","createPublicKey","verifyBlob","validForDate","date","equals","other","verifySCTs","logs","clone","i","length","splice","signedCertificateTimestamps","preCert","ByteStream","issuerId","hash","appendView","tbs","appendUint24","map","sct","logID","verified","buffer","Buffer","alloc","copy","find","exts","every","critical","includes","sub","tag","isContextSpecific"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/sigstore/dist/x509/cert.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.x509Certificate = void 0;\nconst util_1 = require(\"../util\");\nconst asn1_1 = require(\"../util/asn1\");\nconst stream_1 = require(\"../util/stream\");\nconst ext_1 = require(\"./ext\");\nconst EXTENSION_OID_SUBJECT_KEY_ID = '2.5.29.14';\nconst EXTENSION_OID_KEY_USAGE = '2.5.29.15';\nconst EXTENSION_OID_SUBJECT_ALT_NAME = '2.5.29.17';\nconst EXTENSION_OID_BASIC_CONSTRAINTS = '2.5.29.19';\nconst EXTENSION_OID_AUTHORITY_KEY_ID = '2.5.29.35';\nconst EXTENSION_OID_SCT = '1.3.6.1.4.1.11129.2.4.2';\n// List of recognized critical extensions\n// https://www.rfc-editor.org/rfc/rfc5280#section-4.2\nconst RECOGNIZED_EXTENSIONS = [\n    EXTENSION_OID_KEY_USAGE,\n    EXTENSION_OID_BASIC_CONSTRAINTS,\n    EXTENSION_OID_SUBJECT_ALT_NAME,\n];\nconst ECDSA_SIGNATURE_ALGOS = {\n    '1.2.840.10045.4.3.1': 'sha224',\n    '1.2.840.10045.4.3.2': 'sha256',\n    '1.2.840.10045.4.3.3': 'sha384',\n    '1.2.840.10045.4.3.4': 'sha512',\n};\nclass x509Certificate {\n    constructor(asn1) {\n        this.root = asn1;\n        if (!this.checkRecognizedExtensions()) {\n            throw new Error('Certificate contains unrecognized critical extensions');\n        }\n    }\n    static parse(cert) {\n        const der = typeof cert === 'string' ? util_1.pem.toDER(cert) : cert;\n        const asn1 = asn1_1.ASN1Obj.parseBuffer(der);\n        return new x509Certificate(asn1);\n    }\n    get tbsCertificate() {\n        return this.tbsCertificateObj;\n    }\n    get version() {\n        // version number is the first element of the version context specific tag\n        const ver = this.versionObj.subs[0].toInteger();\n        return `v${(ver + BigInt(1)).toString()}`;\n    }\n    get notBefore() {\n        // notBefore is the first element of the validity sequence\n        return this.validityObj.subs[0].toDate();\n    }\n    get notAfter() {\n        // notAfter is the second element of the validity sequence\n        return this.validityObj.subs[1].toDate();\n    }\n    get issuer() {\n        return this.issuerObj.value;\n    }\n    get subject() {\n        return this.subjectObj.value;\n    }\n    get publicKey() {\n        return this.subjectPublicKeyInfoObj.toDER();\n    }\n    get signatureAlgorithm() {\n        const oid = this.signatureAlgorithmObj.subs[0].toOID();\n        return ECDSA_SIGNATURE_ALGOS[oid];\n    }\n    get signatureValue() {\n        // Signature value is a bit string, so we need to skip the first byte\n        return this.signatureValueObj.value.subarray(1);\n    }\n    get extensions() {\n        // The extension list is the first (and only) element of the extensions\n        // context specific tag\n        const extSeq = this.extensionsObj?.subs[0];\n        return extSeq?.subs || [];\n    }\n    get extKeyUsage() {\n        const ext = this.findExtension(EXTENSION_OID_KEY_USAGE);\n        return ext ? new ext_1.x509KeyUsageExtension(ext) : undefined;\n    }\n    get extBasicConstraints() {\n        const ext = this.findExtension(EXTENSION_OID_BASIC_CONSTRAINTS);\n        return ext ? new ext_1.x509BasicConstraintsExtension(ext) : undefined;\n    }\n    get extSubjectAltName() {\n        const ext = this.findExtension(EXTENSION_OID_SUBJECT_ALT_NAME);\n        return ext ? new ext_1.x509SubjectAlternativeNameExtension(ext) : undefined;\n    }\n    get extAuthorityKeyID() {\n        const ext = this.findExtension(EXTENSION_OID_AUTHORITY_KEY_ID);\n        return ext ? new ext_1.x509AuthorityKeyIDExtension(ext) : undefined;\n    }\n    get extSubjectKeyID() {\n        const ext = this.findExtension(EXTENSION_OID_SUBJECT_KEY_ID);\n        return ext ? new ext_1.x509SubjectKeyIDExtension(ext) : undefined;\n    }\n    get extSCT() {\n        const ext = this.findExtension(EXTENSION_OID_SCT);\n        return ext ? new ext_1.x509SCTExtension(ext) : undefined;\n    }\n    get isCA() {\n        const ca = this.extBasicConstraints?.isCA || false;\n        // If the KeyUsage extension is present, keyCertSign must be set\n        if (this.extKeyUsage) {\n            ca && this.extKeyUsage.keyCertSign;\n        }\n        return ca;\n    }\n    extension(oid) {\n        const ext = this.findExtension(oid);\n        return ext ? new ext_1.x509Extension(ext) : undefined;\n    }\n    verify(issuerCertificate) {\n        // Use the issuer's public key if provided, otherwise use the subject's\n        const publicKey = issuerCertificate?.publicKey || this.publicKey;\n        const key = util_1.crypto.createPublicKey(publicKey);\n        return util_1.crypto.verifyBlob(this.tbsCertificate.toDER(), key, this.signatureValue, this.signatureAlgorithm);\n    }\n    validForDate(date) {\n        return this.notBefore <= date && date <= this.notAfter;\n    }\n    equals(other) {\n        return this.root.toDER().equals(other.root.toDER());\n    }\n    verifySCTs(issuer, logs) {\n        let extSCT;\n        // Verifying the SCT requires that we remove the SCT extension and\n        // re-encode the TBS structure to DER -- this value is part of the data\n        // over which the signature is calculated. Since this is a destructive action\n        // we create a copy of the certificate so we can remove the SCT extension\n        // without affecting the original certificate.\n        const clone = this.clone();\n        // Intentionally not using the findExtension method here because we want to\n        // remove the the SCT extension from the certificate before calculating the\n        // PreCert structure\n        for (let i = 0; i < clone.extensions.length; i++) {\n            const ext = clone.extensions[i];\n            if (ext.subs[0].toOID() === EXTENSION_OID_SCT) {\n                extSCT = new ext_1.x509SCTExtension(ext);\n                // Remove the extension from the certificate\n                clone.extensions.splice(i, 1);\n                break;\n            }\n        }\n        if (!extSCT) {\n            throw new Error('Certificate does not contain SCT extension');\n        }\n        if (extSCT?.signedCertificateTimestamps?.length === 0) {\n            throw new Error('Certificate does not contain any SCTs');\n        }\n        // Construct the PreCert structure\n        // https://www.rfc-editor.org/rfc/rfc6962#section-3.2\n        const preCert = new stream_1.ByteStream();\n        // Calculate hash of the issuer's public key\n        const issuerId = util_1.crypto.hash(issuer.publicKey);\n        preCert.appendView(issuerId);\n        // Re-encodes the certificate to DER after removing the SCT extension\n        const tbs = clone.tbsCertificate.toDER();\n        preCert.appendUint24(tbs.length);\n        preCert.appendView(tbs);\n        // Calculate and return the verification results for each SCT\n        return extSCT.signedCertificateTimestamps.map((sct) => ({\n            logID: sct.logID,\n            verified: sct.verify(preCert.buffer, logs),\n        }));\n    }\n    // Creates a copy of the certificate with a new buffer\n    clone() {\n        const der = this.root.toDER();\n        const clone = Buffer.alloc(der.length);\n        der.copy(clone);\n        return x509Certificate.parse(clone);\n    }\n    findExtension(oid) {\n        // Find the extension with the given OID. The OID will always be the first\n        // element of the extension sequence\n        return this.extensions.find((ext) => ext.subs[0].toOID() === oid);\n    }\n    // A certificate should be considered invalid if it contains critical\n    // extensions that are not recognized\n    checkRecognizedExtensions() {\n        // The extension list is the first (and only) element of the extensions\n        // context specific tag\n        const extSeq = this.extensionsObj?.subs[0];\n        const exts = extSeq?.subs.map((ext) => new ext_1.x509Extension(ext));\n        // Check for unrecognized critical extensions\n        return (!exts ||\n            exts.every((ext) => !ext.critical || RECOGNIZED_EXTENSIONS.includes(ext.oid)));\n    }\n    /////////////////////////////////////////////////////////////////////////////\n    // The following properties use the documented x509 structure to locate the\n    // desired ASN.1 object\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.1\n    get tbsCertificateObj() {\n        // tbsCertificate is the first element of the certificate sequence\n        return this.root.subs[0];\n    }\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.2\n    get signatureAlgorithmObj() {\n        // signatureAlgorithm is the second element of the certificate sequence\n        return this.root.subs[1];\n    }\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.1.3\n    get signatureValueObj() {\n        // signatureValue is the third element of the certificate sequence\n        return this.root.subs[2];\n    }\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.1\n    get versionObj() {\n        // version is the first element of the tbsCertificate sequence\n        return this.tbsCertificateObj.subs[0];\n    }\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.4\n    get issuerObj() {\n        // issuer is the fourth element of the tbsCertificate sequence\n        return this.tbsCertificateObj.subs[3];\n    }\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.5\n    get validityObj() {\n        // version is the fifth element of the tbsCertificate sequence\n        return this.tbsCertificateObj.subs[4];\n    }\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.6\n    get subjectObj() {\n        // subject is the sixth element of the tbsCertificate sequence\n        return this.tbsCertificateObj.subs[5];\n    }\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.7\n    get subjectPublicKeyInfoObj() {\n        // subjectPublicKeyInfo is the seventh element of the tbsCertificate sequence\n        return this.tbsCertificateObj.subs[6];\n    }\n    // Extensions can't be located by index because their position varies. Instead,\n    // we need to find the extensions context specific tag\n    // https://www.rfc-editor.org/rfc/rfc5280#section-4.1.2.9\n    get extensionsObj() {\n        return this.tbsCertificateObj.subs.find((sub) => sub.tag.isContextSpecific(0x03));\n    }\n}\nexports.x509Certificate = x509Certificate;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}