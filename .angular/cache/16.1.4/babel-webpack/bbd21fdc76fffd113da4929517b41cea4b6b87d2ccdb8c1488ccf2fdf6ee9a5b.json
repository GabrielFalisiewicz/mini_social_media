{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _asyncToGenerator = require(\"C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst crypto_1 = require(\"crypto\");\nconst path_1 = require(\"path\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst config_1 = require(\"../../utilities/config\");\nconst json_file_1 = require(\"../../utilities/json-file\");\nclass ConfigCommandModule extends command_module_1.CommandModule {\n  constructor() {\n    super(...arguments);\n    this.command = 'config [json-path] [value]';\n    this.describe = 'Retrieves or sets Angular configuration values in the angular.json file for the workspace.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n  }\n  builder(localYargs) {\n    return localYargs.positional('json-path', {\n      description: `The configuration key to set or query, in JSON path format. ` + `For example: \"a[3].foo.bar[2]\". If no new value is provided, returns the current value of this key.`,\n      type: 'string'\n    }).positional('value', {\n      description: 'If provided, a new value for the given configuration key.',\n      type: 'string'\n    }).option('global', {\n      description: `Access the global configuration in the caller's home directory.`,\n      alias: ['g'],\n      type: 'boolean',\n      default: false\n    }).strict();\n  }\n  run(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const level = options.global ? 'global' : 'local';\n      const [config] = yield (0, config_1.getWorkspaceRaw)(level);\n      if (options.value == undefined) {\n        if (!config) {\n          _this.context.logger.error('No config found.');\n          return 1;\n        }\n        return _this.get(config, options);\n      } else {\n        return _this.set(options);\n      }\n    })();\n  }\n  get(jsonFile, options) {\n    const {\n      logger\n    } = this.context;\n    const value = options.jsonPath ? jsonFile.get(parseJsonPath(options.jsonPath)) : jsonFile.content;\n    if (value === undefined) {\n      logger.error('Value cannot be found.');\n      return 1;\n    } else if (typeof value === 'string') {\n      logger.info(value);\n    } else {\n      logger.info(JSON.stringify(value, null, 2));\n    }\n    return 0;\n  }\n  set(options) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!options.jsonPath?.trim()) {\n        throw new command_module_1.CommandModuleError('Invalid Path.');\n      }\n      const [config, configPath] = yield (0, config_1.getWorkspaceRaw)(options.global ? 'global' : 'local');\n      const {\n        logger\n      } = _this2.context;\n      if (!config || !configPath) {\n        throw new command_module_1.CommandModuleError('Confguration file cannot be found.');\n      }\n      const normalizeUUIDValue = v => v === '' ? (0, crypto_1.randomUUID)() : `${v}`;\n      const value = options.jsonPath === 'cli.analyticsSharing.uuid' ? normalizeUUIDValue(options.value) : options.value;\n      const modified = config.modify(parseJsonPath(options.jsonPath), normalizeValue(value));\n      if (!modified) {\n        logger.error('Value cannot be found.');\n        return 1;\n      }\n      yield (0, config_1.validateWorkspace)((0, json_file_1.parseJson)(config.content), options.global ?? false);\n      config.save();\n      return 0;\n    })();\n  }\n}\nexports.default = ConfigCommandModule;\n/**\n * Splits a JSON path string into fragments. Fragments can be used to get the value referenced\n * by the path. For example, a path of \"a[3].foo.bar[2]\" would give you a fragment array of\n * [\"a\", 3, \"foo\", \"bar\", 2].\n * @param path The JSON string to parse.\n * @returns {(string|number)[]} The fragments for the string.\n * @private\n */\nfunction parseJsonPath(path) {\n  const fragments = (path || '').split(/\\./g);\n  const result = [];\n  while (fragments.length > 0) {\n    const fragment = fragments.shift();\n    if (fragment == undefined) {\n      break;\n    }\n    const match = fragment.match(/([^[]+)((\\[.*\\])*)/);\n    if (!match) {\n      throw new command_module_1.CommandModuleError('Invalid JSON path.');\n    }\n    result.push(match[1]);\n    if (match[2]) {\n      const indices = match[2].slice(1, -1).split('][').map(x => /^\\d$/.test(x) ? +x : x.replace(/\"|'/g, ''));\n      result.push(...indices);\n    }\n  }\n  return result.filter(fragment => fragment != null);\n}\nfunction normalizeValue(value) {\n  const valueString = `${value}`.trim();\n  switch (valueString) {\n    case 'true':\n      return true;\n    case 'false':\n      return false;\n    case 'null':\n      return null;\n    case 'undefined':\n      return undefined;\n  }\n  if (isFinite(+valueString)) {\n    return +valueString;\n  }\n  try {\n    // We use `JSON.parse` instead of `parseJson` because the latter will parse UUIDs\n    // and convert them into a numberic entities.\n    // Example: 73b61974-182c-48e4-b4c6-30ddf08c5c98 -> 73.\n    // These values should never contain comments, therefore using `JSON.parse` is safe.\n    return JSON.parse(valueString);\n  } catch {\n    return value;\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","Object","defineProperty","exports","value","crypto_1","path_1","command_module_1","config_1","json_file_1","ConfigCommandModule","CommandModule","constructor","arguments","command","describe","longDescriptionPath","join","__dirname","builder","localYargs","positional","description","type","option","alias","strict","run","options","_this","level","global","config","getWorkspaceRaw","undefined","context","logger","error","get","set","jsonFile","jsonPath","parseJsonPath","content","info","JSON","stringify","_this2","trim","CommandModuleError","configPath","normalizeUUIDValue","v","randomUUID","modified","modify","normalizeValue","validateWorkspace","parseJson","save","path","fragments","split","result","length","fragment","shift","match","push","indices","slice","map","x","test","replace","filter","valueString","isFinite","parse"],"sources":["C:/Users/GabrielFalisiewiczS/OneDrive/Dokumenty/Udemy/backend/kurs1/node_modules/@angular/cli/src/commands/config/cli.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nconst path_1 = require(\"path\");\nconst command_module_1 = require(\"../../command-builder/command-module\");\nconst config_1 = require(\"../../utilities/config\");\nconst json_file_1 = require(\"../../utilities/json-file\");\nclass ConfigCommandModule extends command_module_1.CommandModule {\n    constructor() {\n        super(...arguments);\n        this.command = 'config [json-path] [value]';\n        this.describe = 'Retrieves or sets Angular configuration values in the angular.json file for the workspace.';\n        this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n    }\n    builder(localYargs) {\n        return localYargs\n            .positional('json-path', {\n            description: `The configuration key to set or query, in JSON path format. ` +\n                `For example: \"a[3].foo.bar[2]\". If no new value is provided, returns the current value of this key.`,\n            type: 'string',\n        })\n            .positional('value', {\n            description: 'If provided, a new value for the given configuration key.',\n            type: 'string',\n        })\n            .option('global', {\n            description: `Access the global configuration in the caller's home directory.`,\n            alias: ['g'],\n            type: 'boolean',\n            default: false,\n        })\n            .strict();\n    }\n    async run(options) {\n        const level = options.global ? 'global' : 'local';\n        const [config] = await (0, config_1.getWorkspaceRaw)(level);\n        if (options.value == undefined) {\n            if (!config) {\n                this.context.logger.error('No config found.');\n                return 1;\n            }\n            return this.get(config, options);\n        }\n        else {\n            return this.set(options);\n        }\n    }\n    get(jsonFile, options) {\n        const { logger } = this.context;\n        const value = options.jsonPath\n            ? jsonFile.get(parseJsonPath(options.jsonPath))\n            : jsonFile.content;\n        if (value === undefined) {\n            logger.error('Value cannot be found.');\n            return 1;\n        }\n        else if (typeof value === 'string') {\n            logger.info(value);\n        }\n        else {\n            logger.info(JSON.stringify(value, null, 2));\n        }\n        return 0;\n    }\n    async set(options) {\n        if (!options.jsonPath?.trim()) {\n            throw new command_module_1.CommandModuleError('Invalid Path.');\n        }\n        const [config, configPath] = await (0, config_1.getWorkspaceRaw)(options.global ? 'global' : 'local');\n        const { logger } = this.context;\n        if (!config || !configPath) {\n            throw new command_module_1.CommandModuleError('Confguration file cannot be found.');\n        }\n        const normalizeUUIDValue = (v) => (v === '' ? (0, crypto_1.randomUUID)() : `${v}`);\n        const value = options.jsonPath === 'cli.analyticsSharing.uuid'\n            ? normalizeUUIDValue(options.value)\n            : options.value;\n        const modified = config.modify(parseJsonPath(options.jsonPath), normalizeValue(value));\n        if (!modified) {\n            logger.error('Value cannot be found.');\n            return 1;\n        }\n        await (0, config_1.validateWorkspace)((0, json_file_1.parseJson)(config.content), options.global ?? false);\n        config.save();\n        return 0;\n    }\n}\nexports.default = ConfigCommandModule;\n/**\n * Splits a JSON path string into fragments. Fragments can be used to get the value referenced\n * by the path. For example, a path of \"a[3].foo.bar[2]\" would give you a fragment array of\n * [\"a\", 3, \"foo\", \"bar\", 2].\n * @param path The JSON string to parse.\n * @returns {(string|number)[]} The fragments for the string.\n * @private\n */\nfunction parseJsonPath(path) {\n    const fragments = (path || '').split(/\\./g);\n    const result = [];\n    while (fragments.length > 0) {\n        const fragment = fragments.shift();\n        if (fragment == undefined) {\n            break;\n        }\n        const match = fragment.match(/([^[]+)((\\[.*\\])*)/);\n        if (!match) {\n            throw new command_module_1.CommandModuleError('Invalid JSON path.');\n        }\n        result.push(match[1]);\n        if (match[2]) {\n            const indices = match[2]\n                .slice(1, -1)\n                .split('][')\n                .map((x) => (/^\\d$/.test(x) ? +x : x.replace(/\"|'/g, '')));\n            result.push(...indices);\n        }\n    }\n    return result.filter((fragment) => fragment != null);\n}\nfunction normalizeValue(value) {\n    const valueString = `${value}`.trim();\n    switch (valueString) {\n        case 'true':\n            return true;\n        case 'false':\n            return false;\n        case 'null':\n            return null;\n        case 'undefined':\n            return undefined;\n    }\n    if (isFinite(+valueString)) {\n        return +valueString;\n    }\n    try {\n        // We use `JSON.parse` instead of `parseJson` because the latter will parse UUIDs\n        // and convert them into a numberic entities.\n        // Example: 73b61974-182c-48e4-b4c6-30ddf08c5c98 -> 73.\n        // These values should never contain comments, therefore using `JSON.parse` is safe.\n        return JSON.parse(valueString);\n    }\n    catch {\n        return value;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}